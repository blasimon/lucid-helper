/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsimonblanchard%2FDownloads%2Flucid-assistant%2Fapp%2Fpage.tsx&server=false!":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsimonblanchard%2FDownloads%2Flucid-assistant%2Fapp%2Fpage.tsx&server=false! ***!
  \****************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.tsx */ \"(app-pages-browser)/./app/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRnNpbW9uYmxhbmNoYXJkJTJGRG93bmxvYWRzJTJGbHVjaWQtYXNzaXN0YW50JTJGYXBwJTJGcGFnZS50c3gmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzA4NjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvc2ltb25ibGFuY2hhcmQvRG93bmxvYWRzL2x1Y2lkLWFzc2lzdGFudC9hcHAvcGFnZS50c3hcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fsimonblanchard%2FDownloads%2Flucid-assistant%2Fapp%2Fpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! marked */ \"(app-pages-browser)/./node_modules/marked/lib/marked.esm.js\");\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dompurify */ \"(app-pages-browser)/./node_modules/dompurify/dist/purify.es.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction Home() {\n    _s();\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const messagesEndRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    function renderMarkdown(content) {\n        const html = (0,marked__WEBPACK_IMPORTED_MODULE_2__.marked)(content);\n        const cleanHtml = dompurify__WEBPACK_IMPORTED_MODULE_3__[\"default\"].sanitize(html);\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                padding: \"8px 12px\"\n            },\n            dangerouslySetInnerHTML: {\n                __html: cleanHtml\n            }\n        }, void 0, false, {\n            fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n            lineNumber: 17,\n            columnNumber: 7\n        }, this);\n    }\n    async function sendMessage() {\n        if (!input.trim()) return;\n        setLoading(true);\n        const newMessages = [\n            ...messages,\n            {\n                role: \"user\",\n                content: input\n            }\n        ];\n        setMessages(newMessages);\n        setInput(\"\");\n        const res = await fetch(\"/api/chat\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                messages: newMessages\n            })\n        });\n        const data = await res.json();\n        setMessages([\n            ...newMessages,\n            data\n        ]);\n        setLoading(false);\n    }\n    // Auto-scroll to bottom when messages update\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (messagesEndRef.current) {\n            messagesEndRef.current.scrollIntoView({\n                behavior: \"smooth\"\n            });\n        }\n    }, [\n        messages\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        style: {\n            maxWidth: \"700px\",\n            margin: \"40px auto\",\n            padding: \"0 20px\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                style: {\n                    fontFamily: \"Merriweather, serif\",\n                    fontSize: \"2rem\",\n                    marginBottom: \"1rem\"\n                },\n                children: \"LUCID Research Assistant\"\n            }, void 0, false, {\n                fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                lineNumber: 49,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    border: \"1px solid #ddd\",\n                    borderRadius: \"12px\",\n                    background: \"#f9fafb\",\n                    padding: \"16px\",\n                    height: \"400px\",\n                    overflowY: \"auto\",\n                    marginBottom: \"24px\"\n                },\n                children: [\n                    messages.map((m, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                marginBottom: \"12px\"\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                                    children: [\n                                        m.role === \"user\" ? \"You\" : \"Assistant\",\n                                        \":\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                                    lineNumber: 66,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: renderMarkdown(m.content)\n                                }, void 0, false, {\n                                    fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                                    lineNumber: 67,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, i, true, {\n                            fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                            lineNumber: 65,\n                            columnNumber: 11\n                        }, this)),\n                    loading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"em\", {\n                            children: \"Assistant is typing...\"\n                        }, void 0, false, {\n                            fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                            lineNumber: 70,\n                            columnNumber: 26\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                        lineNumber: 70,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        ref: messagesEndRef\n                    }, void 0, false, {\n                        fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                        lineNumber: 71,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                lineNumber: 53,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    display: \"flex\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"text\",\n                        value: input,\n                        onChange: (e)=>setInput(e.target.value),\n                        onKeyDown: (e)=>e.key === \"Enter\" ? sendMessage() : null,\n                        placeholder: \"Ask me anything about LUCID...\",\n                        style: {\n                            flex: 1,\n                            padding: \"12px 16px\",\n                            borderRadius: \"10px\",\n                            border: \"1px solid #ddd\",\n                            fontSize: \"1rem\",\n                            marginRight: \"12px\"\n                        }\n                    }, void 0, false, {\n                        fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                        lineNumber: 75,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: sendMessage,\n                        style: {\n                            padding: \"12px 24px\",\n                            borderRadius: \"10px\",\n                            background: \"#2563eb\",\n                            color: \"#fff\",\n                            fontWeight: \"bold\",\n                            border: \"none\",\n                            fontSize: \"1rem\",\n                            cursor: \"pointer\"\n                        },\n                        children: \"Send\"\n                    }, void 0, false, {\n                        fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                        lineNumber: 90,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                lineNumber: 74,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginTop: \"32px\",\n                    fontSize: \"0.9rem\",\n                    color: \"#555\",\n                    textAlign: \"center\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: [\n                            \"This assistant was created with the purpose of helping with LUCID setup. The code is open-source, offered without any warranties, at \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                href: \"https://github.com/amgarv/LUCID_TOOL_BACKEND\",\n                                target: \"_blank\",\n                                rel: \"noopener noreferrer\",\n                                style: {\n                                    color: \"#2563eb\"\n                                },\n                                children: \"LUCID Toolkit\"\n                            }, void 0, false, {\n                                fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                                lineNumber: 108,\n                                columnNumber: 138\n                            }, this),\n                            \".\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                        lineNumber: 107,\n                        columnNumber: 3\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: [\n                            \" Remember: Key resources, templates, and setup instructions are available at\",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                href: \"https://lucidresearch.io\",\n                                target: \"_blank\",\n                                rel: \"noopener noreferrer\",\n                                style: {\n                                    color: \"#2563eb\",\n                                    marginLeft: \"4px\"\n                                },\n                                children: \"lucidresearch.io\"\n                            }, void 0, false, {\n                                fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                                lineNumber: 109,\n                                columnNumber: 5\n                            }, this),\n                            \".\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                        lineNumber: 108,\n                        columnNumber: 286\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n                lineNumber: 106,\n                columnNumber: 1\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/simonblanchard/Downloads/lucid-assistant/app/page.tsx\",\n        lineNumber: 48,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"TF3ilbIbvv4BlDuNTeqhzgpM0kg=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixjQUFjOzRCQUNkRCxRQUFROzRCQUNSRixVQUFVOzRCQUNWdUIsYUFBYTt3QkFDZjs7Ozs7O2tDQUVGLDhEQUFDQzt3QkFDQ0MsU0FBUzlDO3dCQUNUSixPQUFPOzRCQUNMQyxTQUFTOzRCQUNUMkIsY0FBYzs0QkFDZEMsWUFBWTs0QkFDWnNCLE9BQU87NEJBQ1BDLFlBQVk7NEJBQ1p6QixRQUFROzRCQUNSRixVQUFVOzRCQUNWNEIsUUFBUTt3QkFDVjtrQ0FDRDs7Ozs7Ozs7Ozs7OzBCQUlULDhEQUFDdEQ7Z0JBQUlDLE9BQU87b0JBQUVzRCxXQUFXO29CQUFRN0IsVUFBVTtvQkFBVTBCLE9BQU87b0JBQVFJLFdBQVc7Z0JBQVM7O2tDQUN0Riw4REFBQ0M7OzRCQUFFOzBDQUNvSSw4REFBQ0M7Z0NBQUVDLE1BQUs7Z0NBQStDZixRQUFPO2dDQUFTZ0IsS0FBSTtnQ0FBc0IzRCxPQUFPO29DQUFFbUQsT0FBTztnQ0FBVTswQ0FBRzs7Ozs7OzRCQUFpQjs7Ozs7OztrQ0FBSyw4REFBQ0s7OzRCQUFFOzBDQUM1Uiw4REFBQ0M7Z0NBQUVDLE1BQUs7Z0NBQTJCZixRQUFPO2dDQUFTZ0IsS0FBSTtnQ0FBc0IzRCxPQUFPO29DQUFFbUQsT0FBTztvQ0FBV1MsWUFBWTtnQ0FBTTswQ0FBRzs7Ozs7OzRCQUFvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtySjtHQTNHd0IxRTtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvcGFnZS50c3g/NzYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IG1hcmtlZCB9IGZyb20gJ21hcmtlZCc7XG5pbXBvcnQgRE9NUHVyaWZ5IGZyb20gJ2RvbXB1cmlmeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlPHsgcm9sZTogc3RyaW5nOyBjb250ZW50OiBzdHJpbmcgfVtdPihbXSk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgbWVzc2FnZXNFbmRSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQgfCBudWxsPihudWxsKTtcblxuICBmdW5jdGlvbiByZW5kZXJNYXJrZG93bihjb250ZW50OiBzdHJpbmcpIHtcbiAgICBjb25zdCBodG1sID0gbWFya2VkKGNvbnRlbnQpO1xuICAgIGNvbnN0IGNsZWFuSHRtbCA9IERPTVB1cmlmeS5zYW5pdGl6ZShodG1sKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBzdHlsZT17eyBwYWRkaW5nOiAnOHB4IDEycHgnIH19IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogY2xlYW5IdG1sIH19IC8+XG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHNlbmRNZXNzYWdlKCkge1xuICAgIGlmICghaW5wdXQudHJpbSgpKSByZXR1cm47XG5cbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIGNvbnN0IG5ld01lc3NhZ2VzID0gWy4uLm1lc3NhZ2VzLCB7IHJvbGU6ICd1c2VyJywgY29udGVudDogaW5wdXQgfV07XG4gICAgc2V0TWVzc2FnZXMobmV3TWVzc2FnZXMpO1xuICAgIHNldElucHV0KCcnKTtcblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcvYXBpL2NoYXQnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBtZXNzYWdlczogbmV3TWVzc2FnZXMgfSksXG4gICAgfSk7XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBzZXRNZXNzYWdlcyhbLi4ubmV3TWVzc2FnZXMsIGRhdGFdKTtcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgfVxuXG4gIC8vIEF1dG8tc2Nyb2xsIHRvIGJvdHRvbSB3aGVuIG1lc3NhZ2VzIHVwZGF0ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtZXNzYWdlc0VuZFJlZi5jdXJyZW50KSB7XG4gICAgICBtZXNzYWdlc0VuZFJlZi5jdXJyZW50LnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3I6ICdzbW9vdGgnIH0pO1xuICAgIH1cbiAgfSwgW21lc3NhZ2VzXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8bWFpbiBzdHlsZT17eyBtYXhXaWR0aDogJzcwMHB4JywgbWFyZ2luOiAnNDBweCBhdXRvJywgcGFkZGluZzogJzAgMjBweCcgfX0+XG4gICAgICA8aDEgc3R5bGU9e3sgZm9udEZhbWlseTogJ01lcnJpd2VhdGhlciwgc2VyaWYnLCBmb250U2l6ZTogJzJyZW0nLCBtYXJnaW5Cb3R0b206ICcxcmVtJyB9fT5cbiAgICAgICAgTFVDSUQgUmVzZWFyY2ggQXNzaXN0YW50XG4gICAgICA8L2gxPlxuXG4gICAgICA8ZGl2XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICNkZGQnLFxuICAgICAgICAgIGJvcmRlclJhZGl1czogJzEycHgnLFxuICAgICAgICAgIGJhY2tncm91bmQ6ICcjZjlmYWZiJyxcbiAgICAgICAgICBwYWRkaW5nOiAnMTZweCcsXG4gICAgICAgICAgaGVpZ2h0OiAnNDAwcHgnLFxuICAgICAgICAgIG92ZXJmbG93WTogJ2F1dG8nLFxuICAgICAgICAgIG1hcmdpbkJvdHRvbTogJzI0cHgnLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7bWVzc2FnZXMubWFwKChtLCBpKSA9PiAoXG4gICAgICAgICAgPGRpdiBrZXk9e2l9IHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogJzEycHgnIH19PlxuICAgICAgICAgICAgPHN0cm9uZz57bS5yb2xlID09PSAndXNlcicgPyAnWW91JyA6ICdBc3Npc3RhbnQnfTo8L3N0cm9uZz5cbiAgICAgICAgICAgIDxkaXY+e3JlbmRlck1hcmtkb3duKG0uY29udGVudCl9PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICkpfVxuICAgICAgICB7bG9hZGluZyAmJiA8ZGl2PjxlbT5Bc3Npc3RhbnQgaXMgdHlwaW5nLi4uPC9lbT48L2Rpdj59XG4gICAgICAgIDxkaXYgcmVmPXttZXNzYWdlc0VuZFJlZn0gLz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6ICdmbGV4JyB9fT5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgIHZhbHVlPXtpbnB1dH1cbiAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldElucHV0KGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICBvbktleURvd249eyhlKSA9PiAoZS5rZXkgPT09ICdFbnRlcicgPyBzZW5kTWVzc2FnZSgpIDogbnVsbCl9XG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJBc2sgbWUgYW55dGhpbmcgYWJvdXQgTFVDSUQuLi5cIlxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICBmbGV4OiAxLFxuICAgICAgICAgICAgcGFkZGluZzogJzEycHggMTZweCcsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcxMHB4JyxcbiAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjZGRkJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMXJlbScsXG4gICAgICAgICAgICBtYXJnaW5SaWdodDogJzEycHgnLFxuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBvbkNsaWNrPXtzZW5kTWVzc2FnZX1cbiAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgcGFkZGluZzogJzEycHggMjRweCcsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcxMHB4JyxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjMjU2M2ViJyxcbiAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMXJlbScsXG4gICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgU2VuZFxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuPGRpdiBzdHlsZT17eyBtYXJnaW5Ub3A6ICczMnB4JywgZm9udFNpemU6ICcwLjlyZW0nLCBjb2xvcjogJyM1NTUnLCB0ZXh0QWxpZ246ICdjZW50ZXInIH19PlxuICA8cD5cbiAgICBUaGlzIGFzc2lzdGFudCB3YXMgY3JlYXRlZCB3aXRoIHRoZSBwdXJwb3NlIG9mIGhlbHBpbmcgd2l0aCBMVUNJRCBzZXR1cC4gVGhlIGNvZGUgaXMgb3Blbi1zb3VyY2UsIG9mZmVyZWQgd2l0aG91dCBhbnkgd2FycmFudGllcywgYXQgPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9hbWdhcnYvTFVDSURfVE9PTF9CQUNLRU5EXCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiIHN0eWxlPXt7IGNvbG9yOiAnIzI1NjNlYicgfX0+TFVDSUQgVG9vbGtpdDwvYT4uPC9wPjxwPiBSZW1lbWJlcjogS2V5IHJlc291cmNlcywgdGVtcGxhdGVzLCBhbmQgc2V0dXAgaW5zdHJ1Y3Rpb25zIGFyZSBhdmFpbGFibGUgYXQgXG4gICAgPGEgaHJlZj1cImh0dHBzOi8vbHVjaWRyZXNlYXJjaC5pb1wiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIiBzdHlsZT17eyBjb2xvcjogJyMyNTYzZWInLCBtYXJnaW5MZWZ0OiAnNHB4JyB9fT5sdWNpZHJlc2VhcmNoLmlvPC9hPi5cbiAgPC9wPlxuPC9kaXY+XG4gICAgPC9tYWluPlxuICApO1xufSJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsIm1hcmtlZCIsIkRPTVB1cmlmeSIsIkhvbWUiLCJpbnB1dCIsInNldElucHV0IiwibWVzc2FnZXMiLCJzZXRNZXNzYWdlcyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwibWVzc2FnZXNFbmRSZWYiLCJyZW5kZXJNYXJrZG93biIsImNvbnRlbnQiLCJodG1sIiwiY2xlYW5IdG1sIiwic2FuaXRpemUiLCJkaXYiLCJzdHlsZSIsInBhZGRpbmciLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsInNlbmRNZXNzYWdlIiwidHJpbSIsIm5ld01lc3NhZ2VzIiwicm9sZSIsInJlcyIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZGF0YSIsImpzb24iLCJjdXJyZW50Iiwic2Nyb2xsSW50b1ZpZXciLCJiZWhhdmlvciIsIm1haW4iLCJtYXhXaWR0aCIsIm1hcmdpbiIsImgxIiwiZm9udEZhbWlseSIsImZvbnRTaXplIiwibWFyZ2luQm90dG9tIiwiYm9yZGVyIiwiYm9yZGVyUmFkaXVzIiwiYmFja2dyb3VuZCIsImhlaWdodCIsIm92ZXJmbG93WSIsIm1hcCIsIm0iLCJpIiwic3Ryb25nIiwiZW0iLCJyZWYiLCJkaXNwbGF5IiwidHlwZSIsInZhbHVlIiwib25DaGFuZ2UiLCJlIiwidGFyZ2V0Iiwib25LZXlEb3duIiwia2V5IiwicGxhY2Vob2xkZXIiLCJmbGV4IiwibWFyZ2luUmlnaHQiLCJidXR0b24iLCJvbkNsaWNrIiwiY29sb3IiLCJmb250V2VpZ2h0IiwiY3Vyc29yIiwibWFyZ2luVG9wIiwidGV4dEFsaWduIiwicCIsImEiLCJocmVmIiwicmVsIiwibWFyZ2luTGVmdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/dompurify/dist/purify.es.mjs":
/*!***************************************************!*\
  !*** ./node_modules/dompurify/dist/purify.es.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ purify; }\n/* harmony export */ });\n/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */ const { entries, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor } = Object;\nlet { freeze, seal, create } = Object; // eslint-disable-line import/no-mutable-exports\nlet { apply, construct } = typeof Reflect !== \"undefined\" && Reflect;\nif (!freeze) {\n    freeze = function freeze(x) {\n        return x;\n    };\n}\nif (!seal) {\n    seal = function seal(x) {\n        return x;\n    };\n}\nif (!apply) {\n    apply = function apply(fun, thisValue, args) {\n        return fun.apply(thisValue, args);\n    };\n}\nif (!construct) {\n    construct = function construct(Func, args) {\n        return new Func(...args);\n    };\n}\nconst arrayForEach = unapply(Array.prototype.forEach);\nconst arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);\nconst arrayPop = unapply(Array.prototype.pop);\nconst arrayPush = unapply(Array.prototype.push);\nconst arraySplice = unapply(Array.prototype.splice);\nconst stringToLowerCase = unapply(String.prototype.toLowerCase);\nconst stringToString = unapply(String.prototype.toString);\nconst stringMatch = unapply(String.prototype.match);\nconst stringReplace = unapply(String.prototype.replace);\nconst stringIndexOf = unapply(String.prototype.indexOf);\nconst stringTrim = unapply(String.prototype.trim);\nconst objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\nconst regExpTest = unapply(RegExp.prototype.test);\nconst typeErrorCreate = unconstruct(TypeError);\n/**\n * Creates a new function that calls the given function with a specified thisArg and arguments.\n *\n * @param func - The function to be wrapped and called.\n * @returns A new function that calls the given function with a specified thisArg and arguments.\n */ function unapply(func) {\n    return function(thisArg) {\n        if (thisArg instanceof RegExp) {\n            thisArg.lastIndex = 0;\n        }\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        return apply(func, thisArg, args);\n    };\n}\n/**\n * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n *\n * @param func - The constructor function to be wrapped and called.\n * @returns A new function that constructs an instance of the given constructor function with the provided arguments.\n */ function unconstruct(func) {\n    return function() {\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        return construct(func, args);\n    };\n}\n/**\n * Add properties to a lookup table\n *\n * @param set - The set to which elements will be added.\n * @param array - The array containing elements to be added to the set.\n * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n * @returns The modified set with added elements.\n */ function addToSet(set, array) {\n    let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;\n    if (setPrototypeOf) {\n        // Make 'in' and truthy checks like Boolean(set.constructor)\n        // independent of any properties defined on Object.prototype.\n        // Prevent prototype setters from intercepting set as a this value.\n        setPrototypeOf(set, null);\n    }\n    let l = array.length;\n    while(l--){\n        let element = array[l];\n        if (typeof element === \"string\") {\n            const lcElement = transformCaseFunc(element);\n            if (lcElement !== element) {\n                // Config presets (e.g. tags.js, attrs.js) are immutable.\n                if (!isFrozen(array)) {\n                    array[l] = lcElement;\n                }\n                element = lcElement;\n            }\n        }\n        set[element] = true;\n    }\n    return set;\n}\n/**\n * Clean up an array to harden against CSPP\n *\n * @param array - The array to be cleaned.\n * @returns The cleaned version of the array\n */ function cleanArray(array) {\n    for(let index = 0; index < array.length; index++){\n        const isPropertyExist = objectHasOwnProperty(array, index);\n        if (!isPropertyExist) {\n            array[index] = null;\n        }\n    }\n    return array;\n}\n/**\n * Shallow clone an object\n *\n * @param object - The object to be cloned.\n * @returns A new object that copies the original.\n */ function clone(object) {\n    const newObject = create(null);\n    for (const [property, value] of entries(object)){\n        const isPropertyExist = objectHasOwnProperty(object, property);\n        if (isPropertyExist) {\n            if (Array.isArray(value)) {\n                newObject[property] = cleanArray(value);\n            } else if (value && typeof value === \"object\" && value.constructor === Object) {\n                newObject[property] = clone(value);\n            } else {\n                newObject[property] = value;\n            }\n        }\n    }\n    return newObject;\n}\n/**\n * This method automatically checks if the prop is function or getter and behaves accordingly.\n *\n * @param object - The object to look up the getter function in its prototype chain.\n * @param prop - The property name for which to find the getter function.\n * @returns The getter function found in the prototype chain or a fallback function.\n */ function lookupGetter(object, prop) {\n    while(object !== null){\n        const desc = getOwnPropertyDescriptor(object, prop);\n        if (desc) {\n            if (desc.get) {\n                return unapply(desc.get);\n            }\n            if (typeof desc.value === \"function\") {\n                return unapply(desc.value);\n            }\n        }\n        object = getPrototypeOf(object);\n    }\n    function fallbackValue() {\n        return null;\n    }\n    return fallbackValue;\n}\nconst html$1 = freeze([\n    \"a\",\n    \"abbr\",\n    \"acronym\",\n    \"address\",\n    \"area\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"bdi\",\n    \"bdo\",\n    \"big\",\n    \"blink\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"center\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"content\",\n    \"data\",\n    \"datalist\",\n    \"dd\",\n    \"decorator\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"dialog\",\n    \"dir\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"element\",\n    \"em\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"font\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"head\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"main\",\n    \"map\",\n    \"mark\",\n    \"marquee\",\n    \"menu\",\n    \"menuitem\",\n    \"meter\",\n    \"nav\",\n    \"nobr\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"output\",\n    \"p\",\n    \"picture\",\n    \"pre\",\n    \"progress\",\n    \"q\",\n    \"rp\",\n    \"rt\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"section\",\n    \"select\",\n    \"shadow\",\n    \"small\",\n    \"source\",\n    \"spacer\",\n    \"span\",\n    \"strike\",\n    \"strong\",\n    \"style\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"template\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"tr\",\n    \"track\",\n    \"tt\",\n    \"u\",\n    \"ul\",\n    \"var\",\n    \"video\",\n    \"wbr\"\n]);\nconst svg$1 = freeze([\n    \"svg\",\n    \"a\",\n    \"altglyph\",\n    \"altglyphdef\",\n    \"altglyphitem\",\n    \"animatecolor\",\n    \"animatemotion\",\n    \"animatetransform\",\n    \"circle\",\n    \"clippath\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"filter\",\n    \"font\",\n    \"g\",\n    \"glyph\",\n    \"glyphref\",\n    \"hkern\",\n    \"image\",\n    \"line\",\n    \"lineargradient\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"mpath\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialgradient\",\n    \"rect\",\n    \"stop\",\n    \"style\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"textpath\",\n    \"title\",\n    \"tref\",\n    \"tspan\",\n    \"view\",\n    \"vkern\"\n]);\nconst svgFilters = freeze([\n    \"feBlend\",\n    \"feColorMatrix\",\n    \"feComponentTransfer\",\n    \"feComposite\",\n    \"feConvolveMatrix\",\n    \"feDiffuseLighting\",\n    \"feDisplacementMap\",\n    \"feDistantLight\",\n    \"feDropShadow\",\n    \"feFlood\",\n    \"feFuncA\",\n    \"feFuncB\",\n    \"feFuncG\",\n    \"feFuncR\",\n    \"feGaussianBlur\",\n    \"feImage\",\n    \"feMerge\",\n    \"feMergeNode\",\n    \"feMorphology\",\n    \"feOffset\",\n    \"fePointLight\",\n    \"feSpecularLighting\",\n    \"feSpotLight\",\n    \"feTile\",\n    \"feTurbulence\"\n]);\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nconst svgDisallowed = freeze([\n    \"animate\",\n    \"color-profile\",\n    \"cursor\",\n    \"discard\",\n    \"font-face\",\n    \"font-face-format\",\n    \"font-face-name\",\n    \"font-face-src\",\n    \"font-face-uri\",\n    \"foreignobject\",\n    \"hatch\",\n    \"hatchpath\",\n    \"mesh\",\n    \"meshgradient\",\n    \"meshpatch\",\n    \"meshrow\",\n    \"missing-glyph\",\n    \"script\",\n    \"set\",\n    \"solidcolor\",\n    \"unknown\",\n    \"use\"\n]);\nconst mathMl$1 = freeze([\n    \"math\",\n    \"menclose\",\n    \"merror\",\n    \"mfenced\",\n    \"mfrac\",\n    \"mglyph\",\n    \"mi\",\n    \"mlabeledtr\",\n    \"mmultiscripts\",\n    \"mn\",\n    \"mo\",\n    \"mover\",\n    \"mpadded\",\n    \"mphantom\",\n    \"mroot\",\n    \"mrow\",\n    \"ms\",\n    \"mspace\",\n    \"msqrt\",\n    \"mstyle\",\n    \"msub\",\n    \"msup\",\n    \"msubsup\",\n    \"mtable\",\n    \"mtd\",\n    \"mtext\",\n    \"mtr\",\n    \"munder\",\n    \"munderover\",\n    \"mprescripts\"\n]);\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nconst mathMlDisallowed = freeze([\n    \"maction\",\n    \"maligngroup\",\n    \"malignmark\",\n    \"mlongdiv\",\n    \"mscarries\",\n    \"mscarry\",\n    \"msgroup\",\n    \"mstack\",\n    \"msline\",\n    \"msrow\",\n    \"semantics\",\n    \"annotation\",\n    \"annotation-xml\",\n    \"mprescripts\",\n    \"none\"\n]);\nconst text = freeze([\n    \"#text\"\n]);\nconst html = freeze([\n    \"accept\",\n    \"action\",\n    \"align\",\n    \"alt\",\n    \"autocapitalize\",\n    \"autocomplete\",\n    \"autopictureinpicture\",\n    \"autoplay\",\n    \"background\",\n    \"bgcolor\",\n    \"border\",\n    \"capture\",\n    \"cellpadding\",\n    \"cellspacing\",\n    \"checked\",\n    \"cite\",\n    \"class\",\n    \"clear\",\n    \"color\",\n    \"cols\",\n    \"colspan\",\n    \"controls\",\n    \"controlslist\",\n    \"coords\",\n    \"crossorigin\",\n    \"datetime\",\n    \"decoding\",\n    \"default\",\n    \"dir\",\n    \"disabled\",\n    \"disablepictureinpicture\",\n    \"disableremoteplayback\",\n    \"download\",\n    \"draggable\",\n    \"enctype\",\n    \"enterkeyhint\",\n    \"face\",\n    \"for\",\n    \"headers\",\n    \"height\",\n    \"hidden\",\n    \"high\",\n    \"href\",\n    \"hreflang\",\n    \"id\",\n    \"inputmode\",\n    \"integrity\",\n    \"ismap\",\n    \"kind\",\n    \"label\",\n    \"lang\",\n    \"list\",\n    \"loading\",\n    \"loop\",\n    \"low\",\n    \"max\",\n    \"maxlength\",\n    \"media\",\n    \"method\",\n    \"min\",\n    \"minlength\",\n    \"multiple\",\n    \"muted\",\n    \"name\",\n    \"nonce\",\n    \"noshade\",\n    \"novalidate\",\n    \"nowrap\",\n    \"open\",\n    \"optimum\",\n    \"pattern\",\n    \"placeholder\",\n    \"playsinline\",\n    \"popover\",\n    \"popovertarget\",\n    \"popovertargetaction\",\n    \"poster\",\n    \"preload\",\n    \"pubdate\",\n    \"radiogroup\",\n    \"readonly\",\n    \"rel\",\n    \"required\",\n    \"rev\",\n    \"reversed\",\n    \"role\",\n    \"rows\",\n    \"rowspan\",\n    \"spellcheck\",\n    \"scope\",\n    \"selected\",\n    \"shape\",\n    \"size\",\n    \"sizes\",\n    \"span\",\n    \"srclang\",\n    \"start\",\n    \"src\",\n    \"srcset\",\n    \"step\",\n    \"style\",\n    \"summary\",\n    \"tabindex\",\n    \"title\",\n    \"translate\",\n    \"type\",\n    \"usemap\",\n    \"valign\",\n    \"value\",\n    \"width\",\n    \"wrap\",\n    \"xmlns\",\n    \"slot\"\n]);\nconst svg = freeze([\n    \"accent-height\",\n    \"accumulate\",\n    \"additive\",\n    \"alignment-baseline\",\n    \"amplitude\",\n    \"ascent\",\n    \"attributename\",\n    \"attributetype\",\n    \"azimuth\",\n    \"basefrequency\",\n    \"baseline-shift\",\n    \"begin\",\n    \"bias\",\n    \"by\",\n    \"class\",\n    \"clip\",\n    \"clippathunits\",\n    \"clip-path\",\n    \"clip-rule\",\n    \"color\",\n    \"color-interpolation\",\n    \"color-interpolation-filters\",\n    \"color-profile\",\n    \"color-rendering\",\n    \"cx\",\n    \"cy\",\n    \"d\",\n    \"dx\",\n    \"dy\",\n    \"diffuseconstant\",\n    \"direction\",\n    \"display\",\n    \"divisor\",\n    \"dur\",\n    \"edgemode\",\n    \"elevation\",\n    \"end\",\n    \"exponent\",\n    \"fill\",\n    \"fill-opacity\",\n    \"fill-rule\",\n    \"filter\",\n    \"filterunits\",\n    \"flood-color\",\n    \"flood-opacity\",\n    \"font-family\",\n    \"font-size\",\n    \"font-size-adjust\",\n    \"font-stretch\",\n    \"font-style\",\n    \"font-variant\",\n    \"font-weight\",\n    \"fx\",\n    \"fy\",\n    \"g1\",\n    \"g2\",\n    \"glyph-name\",\n    \"glyphref\",\n    \"gradientunits\",\n    \"gradienttransform\",\n    \"height\",\n    \"href\",\n    \"id\",\n    \"image-rendering\",\n    \"in\",\n    \"in2\",\n    \"intercept\",\n    \"k\",\n    \"k1\",\n    \"k2\",\n    \"k3\",\n    \"k4\",\n    \"kerning\",\n    \"keypoints\",\n    \"keysplines\",\n    \"keytimes\",\n    \"lang\",\n    \"lengthadjust\",\n    \"letter-spacing\",\n    \"kernelmatrix\",\n    \"kernelunitlength\",\n    \"lighting-color\",\n    \"local\",\n    \"marker-end\",\n    \"marker-mid\",\n    \"marker-start\",\n    \"markerheight\",\n    \"markerunits\",\n    \"markerwidth\",\n    \"maskcontentunits\",\n    \"maskunits\",\n    \"max\",\n    \"mask\",\n    \"media\",\n    \"method\",\n    \"mode\",\n    \"min\",\n    \"name\",\n    \"numoctaves\",\n    \"offset\",\n    \"operator\",\n    \"opacity\",\n    \"order\",\n    \"orient\",\n    \"orientation\",\n    \"origin\",\n    \"overflow\",\n    \"paint-order\",\n    \"path\",\n    \"pathlength\",\n    \"patterncontentunits\",\n    \"patterntransform\",\n    \"patternunits\",\n    \"points\",\n    \"preservealpha\",\n    \"preserveaspectratio\",\n    \"primitiveunits\",\n    \"r\",\n    \"rx\",\n    \"ry\",\n    \"radius\",\n    \"refx\",\n    \"refy\",\n    \"repeatcount\",\n    \"repeatdur\",\n    \"restart\",\n    \"result\",\n    \"rotate\",\n    \"scale\",\n    \"seed\",\n    \"shape-rendering\",\n    \"slope\",\n    \"specularconstant\",\n    \"specularexponent\",\n    \"spreadmethod\",\n    \"startoffset\",\n    \"stddeviation\",\n    \"stitchtiles\",\n    \"stop-color\",\n    \"stop-opacity\",\n    \"stroke-dasharray\",\n    \"stroke-dashoffset\",\n    \"stroke-linecap\",\n    \"stroke-linejoin\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke\",\n    \"stroke-width\",\n    \"style\",\n    \"surfacescale\",\n    \"systemlanguage\",\n    \"tabindex\",\n    \"tablevalues\",\n    \"targetx\",\n    \"targety\",\n    \"transform\",\n    \"transform-origin\",\n    \"text-anchor\",\n    \"text-decoration\",\n    \"text-rendering\",\n    \"textlength\",\n    \"type\",\n    \"u1\",\n    \"u2\",\n    \"unicode\",\n    \"values\",\n    \"viewbox\",\n    \"visibility\",\n    \"version\",\n    \"vert-adv-y\",\n    \"vert-origin-x\",\n    \"vert-origin-y\",\n    \"width\",\n    \"word-spacing\",\n    \"wrap\",\n    \"writing-mode\",\n    \"xchannelselector\",\n    \"ychannelselector\",\n    \"x\",\n    \"x1\",\n    \"x2\",\n    \"xmlns\",\n    \"y\",\n    \"y1\",\n    \"y2\",\n    \"z\",\n    \"zoomandpan\"\n]);\nconst mathMl = freeze([\n    \"accent\",\n    \"accentunder\",\n    \"align\",\n    \"bevelled\",\n    \"close\",\n    \"columnsalign\",\n    \"columnlines\",\n    \"columnspan\",\n    \"denomalign\",\n    \"depth\",\n    \"dir\",\n    \"display\",\n    \"displaystyle\",\n    \"encoding\",\n    \"fence\",\n    \"frame\",\n    \"height\",\n    \"href\",\n    \"id\",\n    \"largeop\",\n    \"length\",\n    \"linethickness\",\n    \"lspace\",\n    \"lquote\",\n    \"mathbackground\",\n    \"mathcolor\",\n    \"mathsize\",\n    \"mathvariant\",\n    \"maxsize\",\n    \"minsize\",\n    \"movablelimits\",\n    \"notation\",\n    \"numalign\",\n    \"open\",\n    \"rowalign\",\n    \"rowlines\",\n    \"rowspacing\",\n    \"rowspan\",\n    \"rspace\",\n    \"rquote\",\n    \"scriptlevel\",\n    \"scriptminsize\",\n    \"scriptsizemultiplier\",\n    \"selection\",\n    \"separator\",\n    \"separators\",\n    \"stretchy\",\n    \"subscriptshift\",\n    \"supscriptshift\",\n    \"symmetric\",\n    \"voffset\",\n    \"width\",\n    \"xmlns\"\n]);\nconst xml = freeze([\n    \"xlink:href\",\n    \"xml:id\",\n    \"xlink:title\",\n    \"xml:space\",\n    \"xmlns:xlink\"\n]);\n// eslint-disable-next-line unicorn/better-regex\nconst MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nconst ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\nconst TMPLIT_EXPR = seal(/\\$\\{[\\w\\W]*/gm); // eslint-disable-line unicorn/better-regex\nconst DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]+$/); // eslint-disable-line no-useless-escape\nconst ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nconst IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nconst IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nconst ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\nconst DOCTYPE_NAME = seal(/^html$/i);\nconst CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\nvar EXPRESSIONS = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ARIA_ATTR: ARIA_ATTR,\n    ATTR_WHITESPACE: ATTR_WHITESPACE,\n    CUSTOM_ELEMENT: CUSTOM_ELEMENT,\n    DATA_ATTR: DATA_ATTR,\n    DOCTYPE_NAME: DOCTYPE_NAME,\n    ERB_EXPR: ERB_EXPR,\n    IS_ALLOWED_URI: IS_ALLOWED_URI,\n    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n    MUSTACHE_EXPR: MUSTACHE_EXPR,\n    TMPLIT_EXPR: TMPLIT_EXPR\n});\n/* eslint-disable @typescript-eslint/indent */ // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\nconst NODE_TYPE = {\n    element: 1,\n    attribute: 2,\n    text: 3,\n    cdataSection: 4,\n    entityReference: 5,\n    // Deprecated\n    entityNode: 6,\n    // Deprecated\n    progressingInstruction: 7,\n    comment: 8,\n    document: 9,\n    documentType: 10,\n    documentFragment: 11,\n    notation: 12 // Deprecated\n};\nconst getGlobal = function getGlobal() {\n    return  false ? 0 : window;\n};\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param trustedTypes The policy factory.\n * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n * @return The policy created (or null, if Trusted Types\n * are not supported or creating the policy failed).\n */ const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n    if (typeof trustedTypes !== \"object\" || typeof trustedTypes.createPolicy !== \"function\") {\n        return null;\n    }\n    // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    let suffix = null;\n    const ATTR_NAME = \"data-tt-policy-suffix\";\n    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n        suffix = purifyHostElement.getAttribute(ATTR_NAME);\n    }\n    const policyName = \"dompurify\" + (suffix ? \"#\" + suffix : \"\");\n    try {\n        return trustedTypes.createPolicy(policyName, {\n            createHTML (html) {\n                return html;\n            },\n            createScriptURL (scriptUrl) {\n                return scriptUrl;\n            }\n        });\n    } catch (_) {\n        // Policy creation failed (most likely another DOMPurify script has\n        // already run). Skip creating the policy, as this will only cause errors\n        // if TT are enforced.\n        console.warn(\"TrustedTypes policy \" + policyName + \" could not be created.\");\n        return null;\n    }\n};\nconst _createHooksMap = function _createHooksMap() {\n    return {\n        afterSanitizeAttributes: [],\n        afterSanitizeElements: [],\n        afterSanitizeShadowDOM: [],\n        beforeSanitizeAttributes: [],\n        beforeSanitizeElements: [],\n        beforeSanitizeShadowDOM: [],\n        uponSanitizeAttribute: [],\n        uponSanitizeElement: [],\n        uponSanitizeShadowNode: []\n    };\n};\nfunction createDOMPurify() {\n    let window1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n    const DOMPurify = (root)=>createDOMPurify(root);\n    DOMPurify.version = \"3.2.6\";\n    DOMPurify.removed = [];\n    if (!window1 || !window1.document || window1.document.nodeType !== NODE_TYPE.document || !window1.Element) {\n        // Not running in a browser, provide a factory function\n        // so that you can pass your own Window\n        DOMPurify.isSupported = false;\n        return DOMPurify;\n    }\n    let { document } = window1;\n    const originalDocument = document;\n    const currentScript = originalDocument.currentScript;\n    const { DocumentFragment, HTMLTemplateElement, Node, Element, NodeFilter, NamedNodeMap = window1.NamedNodeMap || window1.MozNamedAttrMap, HTMLFormElement, DOMParser, trustedTypes } = window1;\n    const ElementPrototype = Element.prototype;\n    const cloneNode = lookupGetter(ElementPrototype, \"cloneNode\");\n    const remove = lookupGetter(ElementPrototype, \"remove\");\n    const getNextSibling = lookupGetter(ElementPrototype, \"nextSibling\");\n    const getChildNodes = lookupGetter(ElementPrototype, \"childNodes\");\n    const getParentNode = lookupGetter(ElementPrototype, \"parentNode\");\n    // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === \"function\") {\n        const template = document.createElement(\"template\");\n        if (template.content && template.content.ownerDocument) {\n            document = template.content.ownerDocument;\n        }\n    }\n    let trustedTypesPolicy;\n    let emptyHTML = \"\";\n    const { implementation, createNodeIterator, createDocumentFragment, getElementsByTagName } = document;\n    const { importNode } = originalDocument;\n    let hooks = _createHooksMap();\n    /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */ DOMPurify.isSupported = typeof entries === \"function\" && typeof getParentNode === \"function\" && implementation && implementation.createHTMLDocument !== undefined;\n    const { MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR, DATA_ATTR, ARIA_ATTR, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE, CUSTOM_ELEMENT } = EXPRESSIONS;\n    let { IS_ALLOWED_URI: IS_ALLOWED_URI$1 } = EXPRESSIONS;\n    /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */ /* allowed element names */ let ALLOWED_TAGS = null;\n    const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n        ...html$1,\n        ...svg$1,\n        ...svgFilters,\n        ...mathMl$1,\n        ...text\n    ]);\n    /* Allowed attribute names */ let ALLOWED_ATTR = null;\n    const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n        ...html,\n        ...svg,\n        ...mathMl,\n        ...xml\n    ]);\n    /*\n   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.\n   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n   */ let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {\n        tagNameCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        attributeNameCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        allowCustomizedBuiltInElements: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: false\n        }\n    }));\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */ let FORBID_TAGS = null;\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */ let FORBID_ATTR = null;\n    /* Decide if ARIA attributes are okay */ let ALLOW_ARIA_ATTR = true;\n    /* Decide if custom data attributes are okay */ let ALLOW_DATA_ATTR = true;\n    /* Decide if unknown protocols are okay */ let ALLOW_UNKNOWN_PROTOCOLS = false;\n    /* Decide if self-closing tags in attributes are allowed.\n   * Usually removed due to a mXSS issue in jQuery 3.0 */ let ALLOW_SELF_CLOSE_IN_ATTR = true;\n    /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */ let SAFE_FOR_TEMPLATES = false;\n    /* Output should be safe even for XML used within HTML and alike.\n   * This means, DOMPurify removes comments when containing risky content.\n   */ let SAFE_FOR_XML = true;\n    /* Decide if document with <html>... should be returned */ let WHOLE_DOCUMENT = false;\n    /* Track whether config is already set on this instance of DOMPurify. */ let SET_CONFIG = false;\n    /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */ let FORCE_BODY = false;\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */ let RETURN_DOM = false;\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */ let RETURN_DOM_FRAGMENT = false;\n    /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */ let RETURN_TRUSTED_TYPE = false;\n    /* Output should be free from DOM clobbering attacks?\n   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n   */ let SANITIZE_DOM = true;\n    /* Achieve full DOM Clobbering protection by isolating the namespace of named\n   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n   *\n   * HTML/DOM spec rules that enable DOM Clobbering:\n   *   - Named Access on Window (7.3.3)\n   *   - DOM Tree Accessors (3.1.5)\n   *   - Form Element Parent-Child Relations (4.10.3)\n   *   - Iframe srcdoc / Nested WindowProxies (4.8.5)\n   *   - HTMLCollection (4.2.10.2)\n   *\n   * Namespace isolation is implemented by prefixing `id` and `name` attributes\n   * with a constant string, i.e., `user-content-`\n   */ let SANITIZE_NAMED_PROPS = false;\n    const SANITIZE_NAMED_PROPS_PREFIX = \"user-content-\";\n    /* Keep element content when removing element? */ let KEEP_CONTENT = true;\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */ let IN_PLACE = false;\n    /* Allow usage of profiles like html, svg and mathMl */ let USE_PROFILES = {};\n    /* Tags to ignore content of when KEEP_CONTENT is true */ let FORBID_CONTENTS = null;\n    const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n        \"annotation-xml\",\n        \"audio\",\n        \"colgroup\",\n        \"desc\",\n        \"foreignobject\",\n        \"head\",\n        \"iframe\",\n        \"math\",\n        \"mi\",\n        \"mn\",\n        \"mo\",\n        \"ms\",\n        \"mtext\",\n        \"noembed\",\n        \"noframes\",\n        \"noscript\",\n        \"plaintext\",\n        \"script\",\n        \"style\",\n        \"svg\",\n        \"template\",\n        \"thead\",\n        \"title\",\n        \"video\",\n        \"xmp\"\n    ]);\n    /* Tags that are safe for data: URIs */ let DATA_URI_TAGS = null;\n    const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n        \"audio\",\n        \"video\",\n        \"img\",\n        \"source\",\n        \"image\",\n        \"track\"\n    ]);\n    /* Attributes safe for values like \"javascript:\" */ let URI_SAFE_ATTRIBUTES = null;\n    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n        \"alt\",\n        \"class\",\n        \"for\",\n        \"id\",\n        \"label\",\n        \"name\",\n        \"pattern\",\n        \"placeholder\",\n        \"role\",\n        \"summary\",\n        \"title\",\n        \"value\",\n        \"style\",\n        \"xmlns\"\n    ]);\n    const MATHML_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\n    const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\n    const HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n    /* Document namespace */ let NAMESPACE = HTML_NAMESPACE;\n    let IS_EMPTY_INPUT = false;\n    /* Allowed XHTML+XML namespaces */ let ALLOWED_NAMESPACES = null;\n    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [\n        MATHML_NAMESPACE,\n        SVG_NAMESPACE,\n        HTML_NAMESPACE\n    ], stringToString);\n    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n        \"mi\",\n        \"mo\",\n        \"mn\",\n        \"ms\",\n        \"mtext\"\n    ]);\n    let HTML_INTEGRATION_POINTS = addToSet({}, [\n        \"annotation-xml\"\n    ]);\n    // Certain elements are allowed in both SVG and HTML\n    // namespace. We need to specify them explicitly\n    // so that they don't get erroneously deleted from\n    // HTML namespace.\n    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n        \"title\",\n        \"style\",\n        \"font\",\n        \"a\",\n        \"script\"\n    ]);\n    /* Parsing of strict XHTML documents */ let PARSER_MEDIA_TYPE = null;\n    const SUPPORTED_PARSER_MEDIA_TYPES = [\n        \"application/xhtml+xml\",\n        \"text/html\"\n    ];\n    const DEFAULT_PARSER_MEDIA_TYPE = \"text/html\";\n    let transformCaseFunc = null;\n    /* Keep a reference to config to pass to hooks */ let CONFIG = null;\n    /* Ideally, do not touch anything below this line */ /* ______________________________________________ */ const formElement = document.createElement(\"form\");\n    const isRegexOrFunction = function isRegexOrFunction(testValue) {\n        return testValue instanceof RegExp || testValue instanceof Function;\n    };\n    /**\n   * _parseConfig\n   *\n   * @param cfg optional config literal\n   */ // eslint-disable-next-line complexity\n    const _parseConfig = function _parseConfig() {\n        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (CONFIG && CONFIG === cfg) {\n            return;\n        }\n        /* Shield configuration object from tampering */ if (!cfg || typeof cfg !== \"object\") {\n            cfg = {};\n        }\n        /* Shield configuration object from prototype pollution */ cfg = clone(cfg);\n        PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes\n        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;\n        // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n        transformCaseFunc = PARSER_MEDIA_TYPE === \"application/xhtml+xml\" ? stringToString : stringToLowerCase;\n        /* Set configuration parameters */ ALLOWED_TAGS = objectHasOwnProperty(cfg, \"ALLOWED_TAGS\") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n        ALLOWED_ATTR = objectHasOwnProperty(cfg, \"ALLOWED_ATTR\") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n        ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, \"ALLOWED_NAMESPACES\") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n        URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, \"ADD_URI_SAFE_ATTR\") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\n        DATA_URI_TAGS = objectHasOwnProperty(cfg, \"ADD_DATA_URI_TAGS\") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\n        FORBID_CONTENTS = objectHasOwnProperty(cfg, \"FORBID_CONTENTS\") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n        FORBID_TAGS = objectHasOwnProperty(cfg, \"FORBID_TAGS\") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});\n        FORBID_ATTR = objectHasOwnProperty(cfg, \"FORBID_ATTR\") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});\n        USE_PROFILES = objectHasOwnProperty(cfg, \"USE_PROFILES\") ? cfg.USE_PROFILES : false;\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n        RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n        FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n        IN_PLACE = cfg.IN_PLACE || false; // Default false\n        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n        MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;\n        HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;\n        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === \"boolean\") {\n            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n            ALLOW_DATA_ATTR = false;\n        }\n        if (RETURN_DOM_FRAGMENT) {\n            RETURN_DOM = true;\n        }\n        /* Parse profile info */ if (USE_PROFILES) {\n            ALLOWED_TAGS = addToSet({}, text);\n            ALLOWED_ATTR = [];\n            if (USE_PROFILES.html === true) {\n                addToSet(ALLOWED_TAGS, html$1);\n                addToSet(ALLOWED_ATTR, html);\n            }\n            if (USE_PROFILES.svg === true) {\n                addToSet(ALLOWED_TAGS, svg$1);\n                addToSet(ALLOWED_ATTR, svg);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n            if (USE_PROFILES.svgFilters === true) {\n                addToSet(ALLOWED_TAGS, svgFilters);\n                addToSet(ALLOWED_ATTR, svg);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n            if (USE_PROFILES.mathMl === true) {\n                addToSet(ALLOWED_TAGS, mathMl$1);\n                addToSet(ALLOWED_ATTR, mathMl);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n        }\n        /* Merge configuration parameters */ if (cfg.ADD_TAGS) {\n            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n                ALLOWED_TAGS = clone(ALLOWED_TAGS);\n            }\n            addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n        }\n        if (cfg.ADD_ATTR) {\n            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n                ALLOWED_ATTR = clone(ALLOWED_ATTR);\n            }\n            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n        }\n        if (cfg.ADD_URI_SAFE_ATTR) {\n            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n        }\n        if (cfg.FORBID_CONTENTS) {\n            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n                FORBID_CONTENTS = clone(FORBID_CONTENTS);\n            }\n            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n        }\n        /* Add #text in case KEEP_CONTENT is set to true */ if (KEEP_CONTENT) {\n            ALLOWED_TAGS[\"#text\"] = true;\n        }\n        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */ if (WHOLE_DOCUMENT) {\n            addToSet(ALLOWED_TAGS, [\n                \"html\",\n                \"head\",\n                \"body\"\n            ]);\n        }\n        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */ if (ALLOWED_TAGS.table) {\n            addToSet(ALLOWED_TAGS, [\n                \"tbody\"\n            ]);\n            delete FORBID_TAGS.tbody;\n        }\n        if (cfg.TRUSTED_TYPES_POLICY) {\n            if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== \"function\") {\n                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n            }\n            if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== \"function\") {\n                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n            }\n            // Overwrite existing TrustedTypes policy.\n            trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n            // Sign local variables required by `sanitize`.\n            emptyHTML = trustedTypesPolicy.createHTML(\"\");\n        } else {\n            // Uninitialized policy, attempt to initialize the internal dompurify policy.\n            if (trustedTypesPolicy === undefined) {\n                trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n            }\n            // If creating the internal policy succeeded sign internal variables.\n            if (trustedTypesPolicy !== null && typeof emptyHTML === \"string\") {\n                emptyHTML = trustedTypesPolicy.createHTML(\"\");\n            }\n        }\n        // Prevent further manipulation of configuration.\n        // Not available in IE8, Safari 5, etc.\n        if (freeze) {\n            freeze(cfg);\n        }\n        CONFIG = cfg;\n    };\n    /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */ const ALL_SVG_TAGS = addToSet({}, [\n        ...svg$1,\n        ...svgFilters,\n        ...svgDisallowed\n    ]);\n    const ALL_MATHML_TAGS = addToSet({}, [\n        ...mathMl$1,\n        ...mathMlDisallowed\n    ]);\n    /**\n   * @param element a DOM element whose namespace is being checked\n   * @returns Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */ const _checkValidNamespace = function _checkValidNamespace(element) {\n        let parent = getParentNode(element);\n        // In JSDOM, if we're inside shadow DOM, then parentNode\n        // can be null. We just simulate parent in this case.\n        if (!parent || !parent.tagName) {\n            parent = {\n                namespaceURI: NAMESPACE,\n                tagName: \"template\"\n            };\n        }\n        const tagName = stringToLowerCase(element.tagName);\n        const parentTagName = stringToLowerCase(parent.tagName);\n        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n            return false;\n        }\n        if (element.namespaceURI === SVG_NAMESPACE) {\n            // The only way to switch from HTML namespace to SVG\n            // is via <svg>. If it happens via any other tag, then\n            // it should be killed.\n            if (parent.namespaceURI === HTML_NAMESPACE) {\n                return tagName === \"svg\";\n            }\n            // The only way to switch from MathML to SVG is via`\n            // svg if parent is either <annotation-xml> or MathML\n            // text integration points.\n            if (parent.namespaceURI === MATHML_NAMESPACE) {\n                return tagName === \"svg\" && (parentTagName === \"annotation-xml\" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n            }\n            // We only allow elements that are defined in SVG\n            // spec. All others are disallowed in SVG namespace.\n            return Boolean(ALL_SVG_TAGS[tagName]);\n        }\n        if (element.namespaceURI === MATHML_NAMESPACE) {\n            // The only way to switch from HTML namespace to MathML\n            // is via <math>. If it happens via any other tag, then\n            // it should be killed.\n            if (parent.namespaceURI === HTML_NAMESPACE) {\n                return tagName === \"math\";\n            }\n            // The only way to switch from SVG to MathML is via\n            // <math> and HTML integration points\n            if (parent.namespaceURI === SVG_NAMESPACE) {\n                return tagName === \"math\" && HTML_INTEGRATION_POINTS[parentTagName];\n            }\n            // We only allow elements that are defined in MathML\n            // spec. All others are disallowed in MathML namespace.\n            return Boolean(ALL_MATHML_TAGS[tagName]);\n        }\n        if (element.namespaceURI === HTML_NAMESPACE) {\n            // The only way to switch from SVG to HTML is via\n            // HTML integration points, and from MathML to HTML\n            // is via MathML text integration points\n            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n                return false;\n            }\n            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n                return false;\n            }\n            // We disallow tags that are specific for MathML\n            // or SVG and should never appear in HTML namespace\n            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n        }\n        // For XHTML and XML documents that support custom namespaces\n        if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && ALLOWED_NAMESPACES[element.namespaceURI]) {\n            return true;\n        }\n        // The code should never reach this place (this means\n        // that the element somehow got namespace that is not\n        // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n        // Return false just in case.\n        return false;\n    };\n    /**\n   * _forceRemove\n   *\n   * @param node a DOM node\n   */ const _forceRemove = function _forceRemove(node) {\n        arrayPush(DOMPurify.removed, {\n            element: node\n        });\n        try {\n            // eslint-disable-next-line unicorn/prefer-dom-node-remove\n            getParentNode(node).removeChild(node);\n        } catch (_) {\n            remove(node);\n        }\n    };\n    /**\n   * _removeAttribute\n   *\n   * @param name an Attribute name\n   * @param element a DOM node\n   */ const _removeAttribute = function _removeAttribute(name, element) {\n        try {\n            arrayPush(DOMPurify.removed, {\n                attribute: element.getAttributeNode(name),\n                from: element\n            });\n        } catch (_) {\n            arrayPush(DOMPurify.removed, {\n                attribute: null,\n                from: element\n            });\n        }\n        element.removeAttribute(name);\n        // We void attribute values for unremovable \"is\" attributes\n        if (name === \"is\") {\n            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n                try {\n                    _forceRemove(element);\n                } catch (_) {}\n            } else {\n                try {\n                    element.setAttribute(name, \"\");\n                } catch (_) {}\n            }\n        }\n    };\n    /**\n   * _initDocument\n   *\n   * @param dirty - a string of dirty markup\n   * @return a DOM, filled with the dirty markup\n   */ const _initDocument = function _initDocument(dirty) {\n        /* Create a HTML document */ let doc = null;\n        let leadingWhitespace = null;\n        if (FORCE_BODY) {\n            dirty = \"<remove></remove>\" + dirty;\n        } else {\n            /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */ const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n            leadingWhitespace = matches && matches[0];\n        }\n        if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && NAMESPACE === HTML_NAMESPACE) {\n            // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n            dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + \"</body></html>\";\n        }\n        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */ if (NAMESPACE === HTML_NAMESPACE) {\n            try {\n                doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n            } catch (_) {}\n        }\n        /* Use createHTMLDocument in case DOMParser is not available */ if (!doc || !doc.documentElement) {\n            doc = implementation.createDocument(NAMESPACE, \"template\", null);\n            try {\n                doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n            } catch (_) {\n            // Syntax error if dirtyPayload is invalid xml\n            }\n        }\n        const body = doc.body || doc.documentElement;\n        if (dirty && leadingWhitespace) {\n            body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n        }\n        /* Work on whole document or just its body */ if (NAMESPACE === HTML_NAMESPACE) {\n            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? \"html\" : \"body\")[0];\n        }\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n    /**\n   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n   *\n   * @param root The root element or node to start traversing on.\n   * @return The created NodeIterator\n   */ const _createNodeIterator = function _createNodeIterator(root) {\n        return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise\n        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);\n    };\n    /**\n   * _isClobbered\n   *\n   * @param element element to check for clobbering attacks\n   * @return true if clobbered, false if safe\n   */ const _isClobbered = function _isClobbered(element) {\n        return element instanceof HTMLFormElement && (typeof element.nodeName !== \"string\" || typeof element.textContent !== \"string\" || typeof element.removeChild !== \"function\" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== \"function\" || typeof element.setAttribute !== \"function\" || typeof element.namespaceURI !== \"string\" || typeof element.insertBefore !== \"function\" || typeof element.hasChildNodes !== \"function\");\n    };\n    /**\n   * Checks whether the given object is a DOM node.\n   *\n   * @param value object to check whether it's a DOM node\n   * @return true is object is a DOM node\n   */ const _isNode = function _isNode(value) {\n        return typeof Node === \"function\" && value instanceof Node;\n    };\n    function _executeHooks(hooks, currentNode, data) {\n        arrayForEach(hooks, (hook)=>{\n            hook.call(DOMPurify, currentNode, data, CONFIG);\n        });\n    }\n    /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   * @param currentNode to check for permission to exist\n   * @return true if node was killed, false if left alive\n   */ const _sanitizeElements = function _sanitizeElements(currentNode) {\n        let content = null;\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeElements, currentNode, null);\n        /* Check if element is clobbered or can clobber */ if (_isClobbered(currentNode)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Now let's check the element's type and name */ const tagName = transformCaseFunc(currentNode.nodeName);\n        /* Execute a hook if present */ _executeHooks(hooks.uponSanitizeElement, currentNode, {\n            tagName,\n            allowedTags: ALLOWED_TAGS\n        });\n        /* Detect mXSS attempts abusing namespace confusion */ if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\\w!]/g, currentNode.textContent)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove any occurrence of processing instructions */ if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove any kind of possibly harmful comments */ if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\\w]/g, currentNode.data)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove element if anything forbids its presence */ if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n            /* Check if we have a custom element to handle */ if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {\n                    return false;\n                }\n                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {\n                    return false;\n                }\n            }\n            /* Keep content except for bad-listed elements */ if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n                const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n                const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n                if (childNodes && parentNode) {\n                    const childCount = childNodes.length;\n                    for(let i = childCount - 1; i >= 0; --i){\n                        const childClone = cloneNode(childNodes[i], true);\n                        childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n                        parentNode.insertBefore(childClone, getNextSibling(currentNode));\n                    }\n                }\n            }\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Check whether element has a valid namespace */ if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Make sure that older browsers don't get fallback-tag mXSS */ if ((tagName === \"noscript\" || tagName === \"noembed\" || tagName === \"noframes\") && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Sanitize element content to be template-safe */ if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n            /* Get the element's text content */ content = currentNode.textContent;\n            arrayForEach([\n                MUSTACHE_EXPR,\n                ERB_EXPR,\n                TMPLIT_EXPR\n            ], (expr)=>{\n                content = stringReplace(content, expr, \" \");\n            });\n            if (currentNode.textContent !== content) {\n                arrayPush(DOMPurify.removed, {\n                    element: currentNode.cloneNode()\n                });\n                currentNode.textContent = content;\n            }\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeElements, currentNode, null);\n        return false;\n    };\n    /**\n   * _isValidAttribute\n   *\n   * @param lcTag Lowercase tag name of containing element.\n   * @param lcName Lowercase attribute name.\n   * @param value Attribute value.\n   * @return Returns true if `value` is valid, otherwise false.\n   */ // eslint-disable-next-line complexity\n    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n        /* Make sure attribute cannot clobber */ if (SANITIZE_DOM && (lcName === \"id\" || lcName === \"name\") && (value in document || value in formElement)) {\n            return false;\n        }\n        /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */ if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;\n        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;\n        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n            if (// First condition does a very basic check if a) it's basically a valid custom element tagname AND\n            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n            _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND\n            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n            lcName === \"is\" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;\n            else {\n                return false;\n            }\n        /* Check value is safe. First, is attr inert? If so, is safe */ } else if (URI_SAFE_ATTRIBUTES[lcName]) ;\n        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, \"\"))) ;\n        else if ((lcName === \"src\" || lcName === \"xlink:href\" || lcName === \"href\") && lcTag !== \"script\" && stringIndexOf(value, \"data:\") === 0 && DATA_URI_TAGS[lcTag]) ;\n        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, \"\"))) ;\n        else if (value) {\n            return false;\n        } else ;\n        return true;\n    };\n    /**\n   * _isBasicCustomElement\n   * checks if at least one dash is included in tagName, and it's not the first char\n   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n   *\n   * @param tagName name of the tag of the node to sanitize\n   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n   */ const _isBasicCustomElement = function _isBasicCustomElement(tagName) {\n        return tagName !== \"annotation-xml\" && stringMatch(tagName, CUSTOM_ELEMENT);\n    };\n    /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param currentNode to sanitize\n   */ const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);\n        const { attributes } = currentNode;\n        /* Check if we have attributes; if not we might have a text node */ if (!attributes || _isClobbered(currentNode)) {\n            return;\n        }\n        const hookEvent = {\n            attrName: \"\",\n            attrValue: \"\",\n            keepAttr: true,\n            allowedAttributes: ALLOWED_ATTR,\n            forceKeepAttr: undefined\n        };\n        let l = attributes.length;\n        /* Go backwards over all attributes; safely remove bad ones */ while(l--){\n            const attr = attributes[l];\n            const { name, namespaceURI, value: attrValue } = attr;\n            const lcName = transformCaseFunc(name);\n            const initValue = attrValue;\n            let value = name === \"value\" ? initValue : stringTrim(initValue);\n            /* Execute a hook if present */ hookEvent.attrName = lcName;\n            hookEvent.attrValue = value;\n            hookEvent.keepAttr = true;\n            hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n            _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);\n            value = hookEvent.attrValue;\n            /* Full DOM Clobbering protection via namespace isolation,\n       * Prefix id and name attributes with `user-content-`\n       */ if (SANITIZE_NAMED_PROPS && (lcName === \"id\" || lcName === \"name\")) {\n                // Remove the attribute with this value\n                _removeAttribute(name, currentNode);\n                // Prefix the value and later re-create the attribute with the sanitized value\n                value = SANITIZE_NAMED_PROPS_PREFIX + value;\n            }\n            /* Work around a security issue with comments inside attributes */ if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\\/(style|title)/i, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Did the hooks approve of the attribute? */ if (hookEvent.forceKeepAttr) {\n                continue;\n            }\n            /* Did the hooks approve of the attribute? */ if (!hookEvent.keepAttr) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Work around a security issue in jQuery 3.0 */ if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Sanitize attribute content to be template-safe */ if (SAFE_FOR_TEMPLATES) {\n                arrayForEach([\n                    MUSTACHE_EXPR,\n                    ERB_EXPR,\n                    TMPLIT_EXPR\n                ], (expr)=>{\n                    value = stringReplace(value, expr, \" \");\n                });\n            }\n            /* Is `value` valid for this attribute? */ const lcTag = transformCaseFunc(currentNode.nodeName);\n            if (!_isValidAttribute(lcTag, lcName, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Handle attributes that require Trusted Types */ if (trustedTypesPolicy && typeof trustedTypes === \"object\" && typeof trustedTypes.getAttributeType === \"function\") {\n                if (namespaceURI) ;\n                else {\n                    switch(trustedTypes.getAttributeType(lcTag, lcName)){\n                        case \"TrustedHTML\":\n                            {\n                                value = trustedTypesPolicy.createHTML(value);\n                                break;\n                            }\n                        case \"TrustedScriptURL\":\n                            {\n                                value = trustedTypesPolicy.createScriptURL(value);\n                                break;\n                            }\n                    }\n                }\n            }\n            /* Handle invalid data-* attribute set by try-catching it */ if (value !== initValue) {\n                try {\n                    if (namespaceURI) {\n                        currentNode.setAttributeNS(namespaceURI, name, value);\n                    } else {\n                        /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */ currentNode.setAttribute(name, value);\n                    }\n                    if (_isClobbered(currentNode)) {\n                        _forceRemove(currentNode);\n                    } else {\n                        arrayPop(DOMPurify.removed);\n                    }\n                } catch (_) {\n                    _removeAttribute(name, currentNode);\n                }\n            }\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);\n    };\n    /**\n   * _sanitizeShadowDOM\n   *\n   * @param fragment to iterate over recursively\n   */ const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n        let shadowNode = null;\n        const shadowIterator = _createNodeIterator(fragment);\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);\n        while(shadowNode = shadowIterator.nextNode()){\n            /* Execute a hook if present */ _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);\n            /* Sanitize tags and elements */ _sanitizeElements(shadowNode);\n            /* Check attributes next */ _sanitizeAttributes(shadowNode);\n            /* Deep shadow DOM detected */ if (shadowNode.content instanceof DocumentFragment) {\n                _sanitizeShadowDOM(shadowNode.content);\n            }\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);\n    };\n    // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function(dirty) {\n        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let body = null;\n        let importedNode = null;\n        let currentNode = null;\n        let returnNode = null;\n        /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */ IS_EMPTY_INPUT = !dirty;\n        if (IS_EMPTY_INPUT) {\n            dirty = \"<!-->\";\n        }\n        /* Stringify, in case dirty is an object */ if (typeof dirty !== \"string\" && !_isNode(dirty)) {\n            if (typeof dirty.toString === \"function\") {\n                dirty = dirty.toString();\n                if (typeof dirty !== \"string\") {\n                    throw typeErrorCreate(\"dirty is not a string, aborting\");\n                }\n            } else {\n                throw typeErrorCreate(\"toString is not a function\");\n            }\n        }\n        /* Return dirty HTML if DOMPurify cannot run */ if (!DOMPurify.isSupported) {\n            return dirty;\n        }\n        /* Assign config vars */ if (!SET_CONFIG) {\n            _parseConfig(cfg);\n        }\n        /* Clean up removed elements */ DOMPurify.removed = [];\n        /* Check if dirty is correctly typed for IN_PLACE */ if (typeof dirty === \"string\") {\n            IN_PLACE = false;\n        }\n        if (IN_PLACE) {\n            /* Do some early pre-sanitization to avoid unsafe root nodes */ if (dirty.nodeName) {\n                const tagName = transformCaseFunc(dirty.nodeName);\n                if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n                    throw typeErrorCreate(\"root node is forbidden and cannot be sanitized in-place\");\n                }\n            }\n        } else if (dirty instanceof Node) {\n            /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */ body = _initDocument(\"<!---->\");\n            importedNode = body.ownerDocument.importNode(dirty, true);\n            if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === \"BODY\") {\n                /* Node is already a body, use as is */ body = importedNode;\n            } else if (importedNode.nodeName === \"HTML\") {\n                body = importedNode;\n            } else {\n                // eslint-disable-next-line unicorn/prefer-dom-node-append\n                body.appendChild(importedNode);\n            }\n        } else {\n            /* Exit directly if we have nothing to do */ if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes\n            dirty.indexOf(\"<\") === -1) {\n                return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n            }\n            /* Initialize the document to work on */ body = _initDocument(dirty);\n            /* Check we have a DOM node from the data */ if (!body) {\n                return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : \"\";\n            }\n        }\n        /* Remove first element node (ours) if FORCE_BODY is set */ if (body && FORCE_BODY) {\n            _forceRemove(body.firstChild);\n        }\n        /* Get node iterator */ const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n        /* Now start iterating over the created document */ while(currentNode = nodeIterator.nextNode()){\n            /* Sanitize tags and elements */ _sanitizeElements(currentNode);\n            /* Check attributes next */ _sanitizeAttributes(currentNode);\n            /* Shadow DOM detected, sanitize it */ if (currentNode.content instanceof DocumentFragment) {\n                _sanitizeShadowDOM(currentNode.content);\n            }\n        }\n        /* If we sanitized `dirty` in-place, return it. */ if (IN_PLACE) {\n            return dirty;\n        }\n        /* Return sanitized string or DOM */ if (RETURN_DOM) {\n            if (RETURN_DOM_FRAGMENT) {\n                returnNode = createDocumentFragment.call(body.ownerDocument);\n                while(body.firstChild){\n                    // eslint-disable-next-line unicorn/prefer-dom-node-append\n                    returnNode.appendChild(body.firstChild);\n                }\n            } else {\n                returnNode = body;\n            }\n            if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n                /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */ returnNode = importNode.call(originalDocument, returnNode, true);\n            }\n            return returnNode;\n        }\n        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n        /* Serialize doctype if allowed */ if (WHOLE_DOCUMENT && ALLOWED_TAGS[\"!doctype\"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n            serializedHTML = \"<!DOCTYPE \" + body.ownerDocument.doctype.name + \">\\n\" + serializedHTML;\n        }\n        /* Sanitize final string template-safe */ if (SAFE_FOR_TEMPLATES) {\n            arrayForEach([\n                MUSTACHE_EXPR,\n                ERB_EXPR,\n                TMPLIT_EXPR\n            ], (expr)=>{\n                serializedHTML = stringReplace(serializedHTML, expr, \" \");\n            });\n        }\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n    DOMPurify.setConfig = function() {\n        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _parseConfig(cfg);\n        SET_CONFIG = true;\n    };\n    DOMPurify.clearConfig = function() {\n        CONFIG = null;\n        SET_CONFIG = false;\n    };\n    DOMPurify.isValidAttribute = function(tag, attr, value) {\n        /* Initialize shared config vars if necessary. */ if (!CONFIG) {\n            _parseConfig({});\n        }\n        const lcTag = transformCaseFunc(tag);\n        const lcName = transformCaseFunc(attr);\n        return _isValidAttribute(lcTag, lcName, value);\n    };\n    DOMPurify.addHook = function(entryPoint, hookFunction) {\n        if (typeof hookFunction !== \"function\") {\n            return;\n        }\n        arrayPush(hooks[entryPoint], hookFunction);\n    };\n    DOMPurify.removeHook = function(entryPoint, hookFunction) {\n        if (hookFunction !== undefined) {\n            const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);\n            return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];\n        }\n        return arrayPop(hooks[entryPoint]);\n    };\n    DOMPurify.removeHooks = function(entryPoint) {\n        hooks[entryPoint] = [];\n    };\n    DOMPurify.removeAllHooks = function() {\n        hooks = _createHooksMap();\n    };\n    return DOMPurify;\n}\nvar purify = createDOMPurify();\n //# sourceMappingURL=purify.es.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kb21wdXJpZnkvZGlzdC9wdXJpZnkuZXMubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx5TEFBeUwsR0FFekwsTUFBTSxFQUNKQSxPQUFPLEVBQ1BDLGNBQWMsRUFDZEMsUUFBUSxFQUNSQyxjQUFjLEVBQ2RDLHdCQUF3QixFQUN6QixHQUFHQztBQUNKLElBQUksRUFDRkMsTUFBTSxFQUNOQyxJQUFJLEVBQ0pDLE1BQU0sRUFDUCxHQUFHSCxRQUFRLGdEQUFnRDtBQUM1RCxJQUFJLEVBQ0ZJLEtBQUssRUFDTEMsU0FBUyxFQUNWLEdBQUcsT0FBT0MsWUFBWSxlQUFlQTtBQUN0QyxJQUFJLENBQUNMLFFBQVE7SUFDWEEsU0FBUyxTQUFTQSxPQUFPTSxDQUFDO1FBQ3hCLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBLElBQUksQ0FBQ0wsTUFBTTtJQUNUQSxPQUFPLFNBQVNBLEtBQUtLLENBQUM7UUFDcEIsT0FBT0E7SUFDVDtBQUNGO0FBQ0EsSUFBSSxDQUFDSCxPQUFPO0lBQ1ZBLFFBQVEsU0FBU0EsTUFBTUksR0FBRyxFQUFFQyxTQUFTLEVBQUVDLElBQUk7UUFDekMsT0FBT0YsSUFBSUosS0FBSyxDQUFDSyxXQUFXQztJQUM5QjtBQUNGO0FBQ0EsSUFBSSxDQUFDTCxXQUFXO0lBQ2RBLFlBQVksU0FBU0EsVUFBVU0sSUFBSSxFQUFFRCxJQUFJO1FBQ3ZDLE9BQU8sSUFBSUMsUUFBUUQ7SUFDckI7QUFDRjtBQUNBLE1BQU1FLGVBQWVDLFFBQVFDLE1BQU1DLFNBQVMsQ0FBQ0MsT0FBTztBQUNwRCxNQUFNQyxtQkFBbUJKLFFBQVFDLE1BQU1DLFNBQVMsQ0FBQ0csV0FBVztBQUM1RCxNQUFNQyxXQUFXTixRQUFRQyxNQUFNQyxTQUFTLENBQUNLLEdBQUc7QUFDNUMsTUFBTUMsWUFBWVIsUUFBUUMsTUFBTUMsU0FBUyxDQUFDTyxJQUFJO0FBQzlDLE1BQU1DLGNBQWNWLFFBQVFDLE1BQU1DLFNBQVMsQ0FBQ1Ms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c291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kb21wdXJpZnkvZGlzdC9wdXJpZnkuZXMubWpzPzE0Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIEBsaWNlbnNlIERPTVB1cmlmeSAzLjIuNiB8IChjKSBDdXJlNTMgYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyB8IFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgbGljZW5zZSAyLjAgYW5kIE1vemlsbGEgUHVibGljIExpY2Vuc2UgMi4wIHwgZ2l0aHViLmNvbS9jdXJlNTMvRE9NUHVyaWZ5L2Jsb2IvMy4yLjYvTElDRU5TRSAqL1xuXG5jb25zdCB7XG4gIGVudHJpZXMsXG4gIHNldFByb3RvdHlwZU9mLFxuICBpc0Zyb3plbixcbiAgZ2V0UHJvdG90eXBlT2YsXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvclxufSA9IE9iamVjdDtcbmxldCB7XG4gIGZyZWV6ZSxcbiAgc2VhbCxcbiAgY3JlYXRlXG59ID0gT2JqZWN0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1tdXRhYmxlLWV4cG9ydHNcbmxldCB7XG4gIGFwcGx5LFxuICBjb25zdHJ1Y3Rcbn0gPSB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdDtcbmlmICghZnJlZXplKSB7XG4gIGZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5pZiAoIXNlYWwpIHtcbiAgc2VhbCA9IGZ1bmN0aW9uIHNlYWwoeCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuaWYgKCFhcHBseSkge1xuICBhcHBseSA9IGZ1bmN0aW9uIGFwcGx5KGZ1biwgdGhpc1ZhbHVlLCBhcmdzKSB7XG4gICAgcmV0dXJuIGZ1bi5hcHBseSh0aGlzVmFsdWUsIGFyZ3MpO1xuICB9O1xufVxuaWYgKCFjb25zdHJ1Y3QpIHtcbiAgY29uc3RydWN0ID0gZnVuY3Rpb24gY29uc3RydWN0KEZ1bmMsIGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmMoLi4uYXJncyk7XG4gIH07XG59XG5jb25zdCBhcnJheUZvckVhY2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKTtcbmNvbnN0IGFycmF5TGFzdEluZGV4T2YgPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZik7XG5jb25zdCBhcnJheVBvcCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLnBvcCk7XG5jb25zdCBhcnJheVB1c2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbmNvbnN0IGFycmF5U3BsaWNlID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbmNvbnN0IHN0cmluZ1RvTG93ZXJDYXNlID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlKTtcbmNvbnN0IHN0cmluZ1RvU3RyaW5nID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nKTtcbmNvbnN0IHN0cmluZ01hdGNoID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLm1hdGNoKTtcbmNvbnN0IHN0cmluZ1JlcGxhY2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG5jb25zdCBzdHJpbmdJbmRleE9mID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLmluZGV4T2YpO1xuY29uc3Qgc3RyaW5nVHJpbSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS50cmltKTtcbmNvbnN0IG9iamVjdEhhc093blByb3BlcnR5ID0gdW5hcHBseShPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbmNvbnN0IHJlZ0V4cFRlc3QgPSB1bmFwcGx5KFJlZ0V4cC5wcm90b3R5cGUudGVzdCk7XG5jb25zdCB0eXBlRXJyb3JDcmVhdGUgPSB1bmNvbnN0cnVjdChUeXBlRXJyb3IpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIHdpdGggYSBzcGVjaWZpZWQgdGhpc0FyZyBhbmQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIHdyYXBwZWQgYW5kIGNhbGxlZC5cbiAqIEByZXR1cm5zIEEgbmV3IGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIHdpdGggYSBzcGVjaWZpZWQgdGhpc0FyZyBhbmQgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiB1bmFwcGx5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGlzQXJnKSB7XG4gICAgaWYgKHRoaXNBcmcgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHRoaXNBcmcubGFzdEluZGV4ID0gMDtcbiAgICB9XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmdW5jdGlvbiB0aGF0IGNvbnN0cnVjdHMgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBiZSB3cmFwcGVkIGFuZCBjYWxsZWQuXG4gKiBAcmV0dXJucyBBIG5ldyBmdW5jdGlvbiB0aGF0IGNvbnN0cnVjdHMgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gdW5jb25zdHJ1Y3QoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RydWN0KGZ1bmMsIGFyZ3MpO1xuICB9O1xufVxuLyoqXG4gKiBBZGQgcHJvcGVydGllcyB0byBhIGxvb2t1cCB0YWJsZVxuICpcbiAqIEBwYXJhbSBzZXQgLSBUaGUgc2V0IHRvIHdoaWNoIGVsZW1lbnRzIHdpbGwgYmUgYWRkZWQuXG4gKiBAcGFyYW0gYXJyYXkgLSBUaGUgYXJyYXkgY29udGFpbmluZyBlbGVtZW50cyB0byBiZSBhZGRlZCB0byB0aGUgc2V0LlxuICogQHBhcmFtIHRyYW5zZm9ybUNhc2VGdW5jIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHRoZSBjYXNlIG9mIGVhY2ggZWxlbWVudCBiZWZvcmUgYWRkaW5nIHRvIHRoZSBzZXQuXG4gKiBAcmV0dXJucyBUaGUgbW9kaWZpZWQgc2V0IHdpdGggYWRkZWQgZWxlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIGFkZFRvU2V0KHNldCwgYXJyYXkpIHtcbiAgbGV0IHRyYW5zZm9ybUNhc2VGdW5jID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBzdHJpbmdUb0xvd2VyQ2FzZTtcbiAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgLy8gTWFrZSAnaW4nIGFuZCB0cnV0aHkgY2hlY2tzIGxpa2UgQm9vbGVhbihzZXQuY29uc3RydWN0b3IpXG4gICAgLy8gaW5kZXBlbmRlbnQgb2YgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiBPYmplY3QucHJvdG90eXBlLlxuICAgIC8vIFByZXZlbnQgcHJvdG90eXBlIHNldHRlcnMgZnJvbSBpbnRlcmNlcHRpbmcgc2V0IGFzIGEgdGhpcyB2YWx1ZS5cbiAgICBzZXRQcm90b3R5cGVPZihzZXQsIG51bGwpO1xuICB9XG4gIGxldCBsID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobC0tKSB7XG4gICAgbGV0IGVsZW1lbnQgPSBhcnJheVtsXTtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsY0VsZW1lbnQgPSB0cmFuc2Zvcm1DYXNlRnVuYyhlbGVtZW50KTtcbiAgICAgIGlmIChsY0VsZW1lbnQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgLy8gQ29uZmlnIHByZXNldHMgKGUuZy4gdGFncy5qcywgYXR0cnMuanMpIGFyZSBpbW11dGFibGUuXG4gICAgICAgIGlmICghaXNGcm96ZW4oYXJyYXkpKSB7XG4gICAgICAgICAgYXJyYXlbbF0gPSBsY0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudCA9IGxjRWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0W2VsZW1lbnRdID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gc2V0O1xufVxuLyoqXG4gKiBDbGVhbiB1cCBhbiBhcnJheSB0byBoYXJkZW4gYWdhaW5zdCBDU1BQXG4gKlxuICogQHBhcmFtIGFycmF5IC0gVGhlIGFycmF5IHRvIGJlIGNsZWFuZWQuXG4gKiBAcmV0dXJucyBUaGUgY2xlYW5lZCB2ZXJzaW9uIG9mIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBjbGVhbkFycmF5KGFycmF5KSB7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBpc1Byb3BlcnR5RXhpc3QgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShhcnJheSwgaW5kZXgpO1xuICAgIGlmICghaXNQcm9wZXJ0eUV4aXN0KSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG4vKipcbiAqIFNoYWxsb3cgY2xvbmUgYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3QgdG8gYmUgY2xvbmVkLlxuICogQHJldHVybnMgQSBuZXcgb2JqZWN0IHRoYXQgY29waWVzIHRoZSBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gY2xvbmUob2JqZWN0KSB7XG4gIGNvbnN0IG5ld09iamVjdCA9IGNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBbcHJvcGVydHksIHZhbHVlXSBvZiBlbnRyaWVzKG9iamVjdCkpIHtcbiAgICBjb25zdCBpc1Byb3BlcnR5RXhpc3QgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5KTtcbiAgICBpZiAoaXNQcm9wZXJ0eUV4aXN0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbmV3T2JqZWN0W3Byb3BlcnR5XSA9IGNsZWFuQXJyYXkodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgbmV3T2JqZWN0W3Byb3BlcnR5XSA9IGNsb25lKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09iamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld09iamVjdDtcbn1cbi8qKlxuICogVGhpcyBtZXRob2QgYXV0b21hdGljYWxseSBjaGVja3MgaWYgdGhlIHByb3AgaXMgZnVuY3Rpb24gb3IgZ2V0dGVyIGFuZCBiZWhhdmVzIGFjY29yZGluZ2x5LlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIGxvb2sgdXAgdGhlIGdldHRlciBmdW5jdGlvbiBpbiBpdHMgcHJvdG90eXBlIGNoYWluLlxuICogQHBhcmFtIHByb3AgLSBUaGUgcHJvcGVydHkgbmFtZSBmb3Igd2hpY2ggdG8gZmluZCB0aGUgZ2V0dGVyIGZ1bmN0aW9uLlxuICogQHJldHVybnMgVGhlIGdldHRlciBmdW5jdGlvbiBmb3VuZCBpbiB0aGUgcHJvdG90eXBlIGNoYWluIG9yIGEgZmFsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGxvb2t1cEdldHRlcihvYmplY3QsIHByb3ApIHtcbiAgd2hpbGUgKG9iamVjdCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGRlc2MgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wKTtcbiAgICBpZiAoZGVzYykge1xuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiB1bmFwcGx5KGRlc2MuZ2V0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGVzYy52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgfVxuICBmdW5jdGlvbiBmYWxsYmFja1ZhbHVlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBmYWxsYmFja1ZhbHVlO1xufVxuXG5jb25zdCBodG1sJDEgPSBmcmVlemUoWydhJywgJ2FiYnInLCAnYWNyb255bScsICdhZGRyZXNzJywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdhdWRpbycsICdiJywgJ2JkaScsICdiZG8nLCAnYmlnJywgJ2JsaW5rJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NpdGUnLCAnY29kZScsICdjb2wnLCAnY29sZ3JvdXAnLCAnY29udGVudCcsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RkJywgJ2RlY29yYXRvcicsICdkZWwnLCAnZGV0YWlscycsICdkZm4nLCAnZGlhbG9nJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZWxlbWVudCcsICdlbScsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb250JywgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2knLCAnaW1nJywgJ2lucHV0JywgJ2lucycsICdrYmQnLCAnbGFiZWwnLCAnbGVnZW5kJywgJ2xpJywgJ21haW4nLCAnbWFwJywgJ21hcmsnLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGVyJywgJ25hdicsICdub2JyJywgJ29sJywgJ29wdGdyb3VwJywgJ29wdGlvbicsICdvdXRwdXQnLCAncCcsICdwaWN0dXJlJywgJ3ByZScsICdwcm9ncmVzcycsICdxJywgJ3JwJywgJ3J0JywgJ3J1YnknLCAncycsICdzYW1wJywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NoYWRvdycsICdzbWFsbCcsICdzb3VyY2UnLCAnc3BhY2VyJywgJ3NwYW4nLCAnc3RyaWtlJywgJ3N0cm9uZycsICdzdHlsZScsICdzdWInLCAnc3VtbWFyeScsICdzdXAnLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGltZScsICd0cicsICd0cmFjaycsICd0dCcsICd1JywgJ3VsJywgJ3ZhcicsICd2aWRlbycsICd3YnInXSk7XG5jb25zdCBzdmckMSA9IGZyZWV6ZShbJ3N2ZycsICdhJywgJ2FsdGdseXBoJywgJ2FsdGdseXBoZGVmJywgJ2FsdGdseXBoaXRlbScsICdhbmltYXRlY29sb3InLCAnYW5pbWF0ZW1vdGlvbicsICdhbmltYXRldHJhbnNmb3JtJywgJ2NpcmNsZScsICdjbGlwcGF0aCcsICdkZWZzJywgJ2Rlc2MnLCAnZWxsaXBzZScsICdmaWx0ZXInLCAnZm9udCcsICdnJywgJ2dseXBoJywgJ2dseXBocmVmJywgJ2hrZXJuJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyZ3JhZGllbnQnLCAnbWFya2VyJywgJ21hc2snLCAnbWV0YWRhdGEnLCAnbXBhdGgnLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsZ3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3N0eWxlJywgJ3N3aXRjaCcsICdzeW1ib2wnLCAndGV4dCcsICd0ZXh0cGF0aCcsICd0aXRsZScsICd0cmVmJywgJ3RzcGFuJywgJ3ZpZXcnLCAndmtlcm4nXSk7XG5jb25zdCBzdmdGaWx0ZXJzID0gZnJlZXplKFsnZmVCbGVuZCcsICdmZUNvbG9yTWF0cml4JywgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLCAnZmVDb21wb3NpdGUnLCAnZmVDb252b2x2ZU1hdHJpeCcsICdmZURpZmZ1c2VMaWdodGluZycsICdmZURpc3BsYWNlbWVudE1hcCcsICdmZURpc3RhbnRMaWdodCcsICdmZURyb3BTaGFkb3cnLCAnZmVGbG9vZCcsICdmZUZ1bmNBJywgJ2ZlRnVuY0InLCAnZmVGdW5jRycsICdmZUZ1bmNSJywgJ2ZlR2F1c3NpYW5CbHVyJywgJ2ZlSW1hZ2UnLCAnZmVNZXJnZScsICdmZU1lcmdlTm9kZScsICdmZU1vcnBob2xvZ3knLCAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JywgJ2ZlU3BlY3VsYXJMaWdodGluZycsICdmZVNwb3RMaWdodCcsICdmZVRpbGUnLCAnZmVUdXJidWxlbmNlJ10pO1xuLy8gTGlzdCBvZiBTVkcgZWxlbWVudHMgdGhhdCBhcmUgZGlzYWxsb3dlZCBieSBkZWZhdWx0LlxuLy8gV2Ugc3RpbGwgbmVlZCB0byBrbm93IHRoZW0gc28gdGhhdCB3ZSBjYW4gZG8gbmFtZXNwYWNlXG4vLyBjaGVja3MgcHJvcGVybHkgaW4gY2FzZSBvbmUgd2FudHMgdG8gYWRkIHRoZW0gdG9cbi8vIGFsbG93LWxpc3QuXG5jb25zdCBzdmdEaXNhbGxvd2VkID0gZnJlZXplKFsnYW5pbWF0ZScsICdjb2xvci1wcm9maWxlJywgJ2N1cnNvcicsICdkaXNjYXJkJywgJ2ZvbnQtZmFjZScsICdmb250LWZhY2UtZm9ybWF0JywgJ2ZvbnQtZmFjZS1uYW1lJywgJ2ZvbnQtZmFjZS1zcmMnLCAnZm9udC1mYWNlLXVyaScsICdmb3JlaWdub2JqZWN0JywgJ2hhdGNoJywgJ2hhdGNocGF0aCcsICdtZXNoJywgJ21lc2hncmFkaWVudCcsICdtZXNocGF0Y2gnLCAnbWVzaHJvdycsICdtaXNzaW5nLWdseXBoJywgJ3NjcmlwdCcsICdzZXQnLCAnc29saWRjb2xvcicsICd1bmtub3duJywgJ3VzZSddKTtcbmNvbnN0IG1hdGhNbCQxID0gZnJlZXplKFsnbWF0aCcsICdtZW5jbG9zZScsICdtZXJyb3InLCAnbWZlbmNlZCcsICdtZnJhYycsICdtZ2x5cGgnLCAnbWknLCAnbWxhYmVsZWR0cicsICdtbXVsdGlzY3JpcHRzJywgJ21uJywgJ21vJywgJ21vdmVyJywgJ21wYWRkZWQnLCAnbXBoYW50b20nLCAnbXJvb3QnLCAnbXJvdycsICdtcycsICdtc3BhY2UnLCAnbXNxcnQnLCAnbXN0eWxlJywgJ21zdWInLCAnbXN1cCcsICdtc3Vic3VwJywgJ210YWJsZScsICdtdGQnLCAnbXRleHQnLCAnbXRyJywgJ211bmRlcicsICdtdW5kZXJvdmVyJywgJ21wcmVzY3JpcHRzJ10pO1xuLy8gU2ltaWxhcmx5IHRvIFNWRywgd2Ugd2FudCB0byBrbm93IGFsbCBNYXRoTUwgZWxlbWVudHMsXG4vLyBldmVuIHRob3NlIHRoYXQgd2UgZGlzYWxsb3cgYnkgZGVmYXVsdC5cbmNvbnN0IG1hdGhNbERpc2FsbG93ZWQgPSBmcmVlemUoWydtYWN0aW9uJywgJ21hbGlnbmdyb3VwJywgJ21hbGlnbm1hcmsnLCAnbWxvbmdkaXYnLCAnbXNjYXJyaWVzJywgJ21zY2FycnknLCAnbXNncm91cCcsICdtc3RhY2snLCAnbXNsaW5lJywgJ21zcm93JywgJ3NlbWFudGljcycsICdhbm5vdGF0aW9uJywgJ2Fubm90YXRpb24teG1sJywgJ21wcmVzY3JpcHRzJywgJ25vbmUnXSk7XG5jb25zdCB0ZXh0ID0gZnJlZXplKFsnI3RleHQnXSk7XG5cbmNvbnN0IGh0bWwgPSBmcmVlemUoWydhY2NlcHQnLCAnYWN0aW9uJywgJ2FsaWduJywgJ2FsdCcsICdhdXRvY2FwaXRhbGl6ZScsICdhdXRvY29tcGxldGUnLCAnYXV0b3BpY3R1cmVpbnBpY3R1cmUnLCAnYXV0b3BsYXknLCAnYmFja2dyb3VuZCcsICdiZ2NvbG9yJywgJ2JvcmRlcicsICdjYXB0dXJlJywgJ2NlbGxwYWRkaW5nJywgJ2NlbGxzcGFjaW5nJywgJ2NoZWNrZWQnLCAnY2l0ZScsICdjbGFzcycsICdjbGVhcicsICdjb2xvcicsICdjb2xzJywgJ2NvbHNwYW4nLCAnY29udHJvbHMnLCAnY29udHJvbHNsaXN0JywgJ2Nvb3JkcycsICdjcm9zc29yaWdpbicsICdkYXRldGltZScsICdkZWNvZGluZycsICdkZWZhdWx0JywgJ2RpcicsICdkaXNhYmxlZCcsICdkaXNhYmxlcGljdHVyZWlucGljdHVyZScsICdkaXNhYmxlcmVtb3RlcGxheWJhY2snLCAnZG93bmxvYWQnLCAnZHJhZ2dhYmxlJywgJ2VuY3R5cGUnLCAnZW50ZXJrZXloaW50JywgJ2ZhY2UnLCAnZm9yJywgJ2hlYWRlcnMnLCAnaGVpZ2h0JywgJ2hpZGRlbicsICdoaWdoJywgJ2hyZWYnLCAnaHJlZmxhbmcnLCAnaWQnLCAnaW5wdXRtb2RlJywgJ2ludGVncml0eScsICdpc21hcCcsICdraW5kJywgJ2xhYmVsJywgJ2xhbmcnLCAnbGlzdCcsICdsb2FkaW5nJywgJ2xvb3AnLCAnbG93JywgJ21heCcsICdtYXhsZW5ndGgnLCAnbWVkaWEnLCAnbWV0aG9kJywgJ21pbicsICdtaW5sZW5ndGgnLCAnbXVsdGlwbGUnLCAnbXV0ZWQnLCAnbmFtZScsICdub25jZScsICdub3NoYWRlJywgJ25vdmFsaWRhdGUnLCAnbm93cmFwJywgJ29wZW4nLCAnb3B0aW11bScsICdwYXR0ZXJuJywgJ3BsYWNlaG9sZGVyJywgJ3BsYXlzaW5saW5lJywgJ3BvcG92ZXInLCAncG9wb3ZlcnRhcmdldCcsICdwb3BvdmVydGFyZ2V0YWN0aW9uJywgJ3Bvc3RlcicsICdwcmVsb2FkJywgJ3B1YmRhdGUnLCAncmFkaW9ncm91cCcsICdyZWFkb25seScsICdyZWwnLCAncmVxdWlyZWQnLCAncmV2JywgJ3JldmVyc2VkJywgJ3JvbGUnLCAncm93cycsICdyb3dzcGFuJywgJ3NwZWxsY2hlY2snLCAnc2NvcGUnLCAnc2VsZWN0ZWQnLCAnc2hhcGUnLCAnc2l6ZScsICdzaXplcycsICdzcGFuJywgJ3NyY2xhbmcnLCAnc3RhcnQnLCAnc3JjJywgJ3NyY3NldCcsICdzdGVwJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFiaW5kZXgnLCAndGl0bGUnLCAndHJhbnNsYXRlJywgJ3R5cGUnLCAndXNlbWFwJywgJ3ZhbGlnbicsICd2YWx1ZScsICd3aWR0aCcsICd3cmFwJywgJ3htbG5zJywgJ3Nsb3QnXSk7XG5jb25zdCBzdmcgPSBmcmVlemUoWydhY2NlbnQtaGVpZ2h0JywgJ2FjY3VtdWxhdGUnLCAnYWRkaXRpdmUnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FtcGxpdHVkZScsICdhc2NlbnQnLCAnYXR0cmlidXRlbmFtZScsICdhdHRyaWJ1dGV0eXBlJywgJ2F6aW11dGgnLCAnYmFzZWZyZXF1ZW5jeScsICdiYXNlbGluZS1zaGlmdCcsICdiZWdpbicsICdiaWFzJywgJ2J5JywgJ2NsYXNzJywgJ2NsaXAnLCAnY2xpcHBhdGh1bml0cycsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2N4JywgJ2N5JywgJ2QnLCAnZHgnLCAnZHknLCAnZGlmZnVzZWNvbnN0YW50JywgJ2RpcmVjdGlvbicsICdkaXNwbGF5JywgJ2Rpdmlzb3InLCAnZHVyJywgJ2VkZ2Vtb2RlJywgJ2VsZXZhdGlvbicsICdlbmQnLCAnZXhwb25lbnQnLCAnZmlsbCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2ZpbHRlcicsICdmaWx0ZXJ1bml0cycsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdmeCcsICdmeScsICdnMScsICdnMicsICdnbHlwaC1uYW1lJywgJ2dseXBocmVmJywgJ2dyYWRpZW50dW5pdHMnLCAnZ3JhZGllbnR0cmFuc2Zvcm0nLCAnaGVpZ2h0JywgJ2hyZWYnLCAnaWQnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2luJywgJ2luMicsICdpbnRlcmNlcHQnLCAnaycsICdrMScsICdrMicsICdrMycsICdrNCcsICdrZXJuaW5nJywgJ2tleXBvaW50cycsICdrZXlzcGxpbmVzJywgJ2tleXRpbWVzJywgJ2xhbmcnLCAnbGVuZ3RoYWRqdXN0JywgJ2xldHRlci1zcGFjaW5nJywgJ2tlcm5lbG1hdHJpeCcsICdrZXJuZWx1bml0bGVuZ3RoJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ2xvY2FsJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnbWFya2VyaGVpZ2h0JywgJ21hcmtlcnVuaXRzJywgJ21hcmtlcndpZHRoJywgJ21hc2tjb250ZW50dW5pdHMnLCAnbWFza3VuaXRzJywgJ21heCcsICdtYXNrJywgJ21lZGlhJywgJ21ldGhvZCcsICdtb2RlJywgJ21pbicsICduYW1lJywgJ251bW9jdGF2ZXMnLCAnb2Zmc2V0JywgJ29wZXJhdG9yJywgJ29wYWNpdHknLCAnb3JkZXInLCAnb3JpZW50JywgJ29yaWVudGF0aW9uJywgJ29yaWdpbicsICdvdmVyZmxvdycsICdwYWludC1vcmRlcicsICdwYXRoJywgJ3BhdGhsZW5ndGgnLCAncGF0dGVybmNvbnRlbnR1bml0cycsICdwYXR0ZXJudHJhbnNmb3JtJywgJ3BhdHRlcm51bml0cycsICdwb2ludHMnLCAncHJlc2VydmVhbHBoYScsICdwcmVzZXJ2ZWFzcGVjdHJhdGlvJywgJ3ByaW1pdGl2ZXVuaXRzJywgJ3InLCAncngnLCAncnknLCAncmFkaXVzJywgJ3JlZngnLCAncmVmeScsICdyZXBlYXRjb3VudCcsICdyZXBlYXRkdXInLCAncmVzdGFydCcsICdyZXN1bHQnLCAncm90YXRlJywgJ3NjYWxlJywgJ3NlZWQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3Nsb3BlJywgJ3NwZWN1bGFyY29uc3RhbnQnLCAnc3BlY3VsYXJleHBvbmVudCcsICdzcHJlYWRtZXRob2QnLCAnc3RhcnRvZmZzZXQnLCAnc3RkZGV2aWF0aW9uJywgJ3N0aXRjaHRpbGVzJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZScsICdzdHJva2Utd2lkdGgnLCAnc3R5bGUnLCAnc3VyZmFjZXNjYWxlJywgJ3N5c3RlbWxhbmd1YWdlJywgJ3RhYmluZGV4JywgJ3RhYmxldmFsdWVzJywgJ3RhcmdldHgnLCAndGFyZ2V0eScsICd0cmFuc2Zvcm0nLCAndHJhbnNmb3JtLW9yaWdpbicsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndGV4dGxlbmd0aCcsICd0eXBlJywgJ3UxJywgJ3UyJywgJ3VuaWNvZGUnLCAndmFsdWVzJywgJ3ZpZXdib3gnLCAndmlzaWJpbGl0eScsICd2ZXJzaW9uJywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dpZHRoJywgJ3dvcmQtc3BhY2luZycsICd3cmFwJywgJ3dyaXRpbmctbW9kZScsICd4Y2hhbm5lbHNlbGVjdG9yJywgJ3ljaGFubmVsc2VsZWN0b3InLCAneCcsICd4MScsICd4MicsICd4bWxucycsICd5JywgJ3kxJywgJ3kyJywgJ3onLCAnem9vbWFuZHBhbiddKTtcbmNvbnN0IG1hdGhNbCA9IGZyZWV6ZShbJ2FjY2VudCcsICdhY2NlbnR1bmRlcicsICdhbGlnbicsICdiZXZlbGxlZCcsICdjbG9zZScsICdjb2x1bW5zYWxpZ24nLCAnY29sdW1ubGluZXMnLCAnY29sdW1uc3BhbicsICdkZW5vbWFsaWduJywgJ2RlcHRoJywgJ2RpcicsICdkaXNwbGF5JywgJ2Rpc3BsYXlzdHlsZScsICdlbmNvZGluZycsICdmZW5jZScsICdmcmFtZScsICdoZWlnaHQnLCAnaHJlZicsICdpZCcsICdsYXJnZW9wJywgJ2xlbmd0aCcsICdsaW5ldGhpY2tuZXNzJywgJ2xzcGFjZScsICdscXVvdGUnLCAnbWF0aGJhY2tncm91bmQnLCAnbWF0aGNvbG9yJywgJ21hdGhzaXplJywgJ21hdGh2YXJpYW50JywgJ21heHNpemUnLCAnbWluc2l6ZScsICdtb3ZhYmxlbGltaXRzJywgJ25vdGF0aW9uJywgJ251bWFsaWduJywgJ29wZW4nLCAncm93YWxpZ24nLCAncm93bGluZXMnLCAncm93c3BhY2luZycsICdyb3dzcGFuJywgJ3JzcGFjZScsICdycXVvdGUnLCAnc2NyaXB0bGV2ZWwnLCAnc2NyaXB0bWluc2l6ZScsICdzY3JpcHRzaXplbXVsdGlwbGllcicsICdzZWxlY3Rpb24nLCAnc2VwYXJhdG9yJywgJ3NlcGFyYXRvcnMnLCAnc3RyZXRjaHknLCAnc3Vic2NyaXB0c2hpZnQnLCAnc3Vwc2NyaXB0c2hpZnQnLCAnc3ltbWV0cmljJywgJ3ZvZmZzZXQnLCAnd2lkdGgnLCAneG1sbnMnXSk7XG5jb25zdCB4bWwgPSBmcmVlemUoWyd4bGluazpocmVmJywgJ3htbDppZCcsICd4bGluazp0aXRsZScsICd4bWw6c3BhY2UnLCAneG1sbnM6eGxpbmsnXSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL2JldHRlci1yZWdleFxuY29uc3QgTVVTVEFDSEVfRVhQUiA9IHNlYWwoL1xce1xce1tcXHdcXFddKnxbXFx3XFxXXSpcXH1cXH0vZ20pOyAvLyBTcGVjaWZ5IHRlbXBsYXRlIGRldGVjdGlvbiByZWdleCBmb3IgU0FGRV9GT1JfVEVNUExBVEVTIG1vZGVcbmNvbnN0IEVSQl9FWFBSID0gc2VhbCgvPCVbXFx3XFxXXSp8W1xcd1xcV10qJT4vZ20pO1xuY29uc3QgVE1QTElUX0VYUFIgPSBzZWFsKC9cXCRcXHtbXFx3XFxXXSovZ20pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHVuaWNvcm4vYmV0dGVyLXJlZ2V4XG5jb25zdCBEQVRBX0FUVFIgPSBzZWFsKC9eZGF0YS1bXFwtXFx3LlxcdTAwQjctXFx1RkZGRl0rJC8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5jb25zdCBBUklBX0FUVFIgPSBzZWFsKC9eYXJpYS1bXFwtXFx3XSskLyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbmNvbnN0IElTX0FMTE9XRURfVVJJID0gc2VhbCgvXig/Oig/Oig/OmZ8aHQpdHBzP3xtYWlsdG98dGVsfGNhbGx0b3xzbXN8Y2lkfHhtcHB8bWF0cml4KTp8W15hLXpdfFthLXorLlxcLV0rKD86W15hLXorLlxcLTpdfCQpKS9pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbik7XG5jb25zdCBJU19TQ1JJUFRfT1JfREFUQSA9IHNlYWwoL14oPzpcXHcrc2NyaXB0fGRhdGEpOi9pKTtcbmNvbnN0IEFUVFJfV0hJVEVTUEFDRSA9IHNlYWwoL1tcXHUwMDAwLVxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMjlcXHUyMDVGXFx1MzAwMF0vZyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbik7XG5jb25zdCBET0NUWVBFX05BTUUgPSBzZWFsKC9eaHRtbCQvaSk7XG5jb25zdCBDVVNUT01fRUxFTUVOVCA9IHNlYWwoL15bYS16XVsuXFx3XSooLVsuXFx3XSspKyQvaSk7XG5cbnZhciBFWFBSRVNTSU9OUyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBUklBX0FUVFI6IEFSSUFfQVRUUixcbiAgQVRUUl9XSElURVNQQUNFOiBBVFRSX1dISVRFU1BBQ0UsXG4gIENVU1RPTV9FTEVNRU5UOiBDVVNUT01fRUxFTUVOVCxcbiAgREFUQV9BVFRSOiBEQVRBX0FUVFIsXG4gIERPQ1RZUEVfTkFNRTogRE9DVFlQRV9OQU1FLFxuICBFUkJfRVhQUjogRVJCX0VYUFIsXG4gIElTX0FMTE9XRURfVVJJOiBJU19BTExPV0VEX1VSSSxcbiAgSVNfU0NSSVBUX09SX0RBVEE6IElTX1NDUklQVF9PUl9EQVRBLFxuICBNVVNUQUNIRV9FWFBSOiBNVVNUQUNIRV9FWFBSLFxuICBUTVBMSVRfRVhQUjogVE1QTElUX0VYUFJcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvaW5kZW50ICovXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9ub2RlVHlwZVxuY29uc3QgTk9ERV9UWVBFID0ge1xuICBlbGVtZW50OiAxLFxuICBhdHRyaWJ1dGU6IDIsXG4gIHRleHQ6IDMsXG4gIGNkYXRhU2VjdGlvbjogNCxcbiAgZW50aXR5UmVmZXJlbmNlOiA1LFxuICAvLyBEZXByZWNhdGVkXG4gIGVudGl0eU5vZGU6IDYsXG4gIC8vIERlcHJlY2F0ZWRcbiAgcHJvZ3Jlc3NpbmdJbnN0cnVjdGlvbjogNyxcbiAgY29tbWVudDogOCxcbiAgZG9jdW1lbnQ6IDksXG4gIGRvY3VtZW50VHlwZTogMTAsXG4gIGRvY3VtZW50RnJhZ21lbnQ6IDExLFxuICBub3RhdGlvbjogMTIgLy8gRGVwcmVjYXRlZFxufTtcbmNvbnN0IGdldEdsb2JhbCA9IGZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdztcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuby1vcCBwb2xpY3kgZm9yIGludGVybmFsIHVzZSBvbmx5LlxuICogRG9uJ3QgZXhwb3J0IHRoaXMgZnVuY3Rpb24gb3V0c2lkZSB0aGlzIG1vZHVsZSFcbiAqIEBwYXJhbSB0cnVzdGVkVHlwZXMgVGhlIHBvbGljeSBmYWN0b3J5LlxuICogQHBhcmFtIHB1cmlmeUhvc3RFbGVtZW50IFRoZSBTY3JpcHQgZWxlbWVudCB1c2VkIHRvIGxvYWQgRE9NUHVyaWZ5ICh0byBkZXRlcm1pbmUgcG9saWN5IG5hbWUgc3VmZml4KS5cbiAqIEByZXR1cm4gVGhlIHBvbGljeSBjcmVhdGVkIChvciBudWxsLCBpZiBUcnVzdGVkIFR5cGVzXG4gKiBhcmUgbm90IHN1cHBvcnRlZCBvciBjcmVhdGluZyB0aGUgcG9saWN5IGZhaWxlZCkuXG4gKi9cbmNvbnN0IF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kgPSBmdW5jdGlvbiBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHRydXN0ZWRUeXBlcywgcHVyaWZ5SG9zdEVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiB0cnVzdGVkVHlwZXMgIT09ICdvYmplY3QnIHx8IHR5cGVvZiB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gQWxsb3cgdGhlIGNhbGxlcnMgdG8gY29udHJvbCB0aGUgdW5pcXVlIHBvbGljeSBuYW1lXG4gIC8vIGJ5IGFkZGluZyBhIGRhdGEtdHQtcG9saWN5LXN1ZmZpeCB0byB0aGUgc2NyaXB0IGVsZW1lbnQgd2l0aCB0aGUgRE9NUHVyaWZ5LlxuICAvLyBQb2xpY3kgY3JlYXRpb24gd2l0aCBkdXBsaWNhdGUgbmFtZXMgdGhyb3dzIGluIFRydXN0ZWQgVHlwZXMuXG4gIGxldCBzdWZmaXggPSBudWxsO1xuICBjb25zdCBBVFRSX05BTUUgPSAnZGF0YS10dC1wb2xpY3ktc3VmZml4JztcbiAgaWYgKHB1cmlmeUhvc3RFbGVtZW50ICYmIHB1cmlmeUhvc3RFbGVtZW50Lmhhc0F0dHJpYnV0ZShBVFRSX05BTUUpKSB7XG4gICAgc3VmZml4ID0gcHVyaWZ5SG9zdEVsZW1lbnQuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSk7XG4gIH1cbiAgY29uc3QgcG9saWN5TmFtZSA9ICdkb21wdXJpZnknICsgKHN1ZmZpeCA/ICcjJyArIHN1ZmZpeCA6ICcnKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShwb2xpY3lOYW1lLCB7XG4gICAgICBjcmVhdGVIVE1MKGh0bWwpIHtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICB9LFxuICAgICAgY3JlYXRlU2NyaXB0VVJMKHNjcmlwdFVybCkge1xuICAgICAgICByZXR1cm4gc2NyaXB0VXJsO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7XG4gICAgLy8gUG9saWN5IGNyZWF0aW9uIGZhaWxlZCAobW9zdCBsaWtlbHkgYW5vdGhlciBET01QdXJpZnkgc2NyaXB0IGhhc1xuICAgIC8vIGFscmVhZHkgcnVuKS4gU2tpcCBjcmVhdGluZyB0aGUgcG9saWN5LCBhcyB0aGlzIHdpbGwgb25seSBjYXVzZSBlcnJvcnNcbiAgICAvLyBpZiBUVCBhcmUgZW5mb3JjZWQuXG4gICAgY29uc29sZS53YXJuKCdUcnVzdGVkVHlwZXMgcG9saWN5ICcgKyBwb2xpY3lOYW1lICsgJyBjb3VsZCBub3QgYmUgY3JlYXRlZC4nKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbmNvbnN0IF9jcmVhdGVIb29rc01hcCA9IGZ1bmN0aW9uIF9jcmVhdGVIb29rc01hcCgpIHtcbiAgcmV0dXJuIHtcbiAgICBhZnRlclNhbml0aXplQXR0cmlidXRlczogW10sXG4gICAgYWZ0ZXJTYW5pdGl6ZUVsZW1lbnRzOiBbXSxcbiAgICBhZnRlclNhbml0aXplU2hhZG93RE9NOiBbXSxcbiAgICBiZWZvcmVTYW5pdGl6ZUF0dHJpYnV0ZXM6IFtdLFxuICAgIGJlZm9yZVNhbml0aXplRWxlbWVudHM6IFtdLFxuICAgIGJlZm9yZVNhbml0aXplU2hhZG93RE9NOiBbXSxcbiAgICB1cG9uU2FuaXRpemVBdHRyaWJ1dGU6IFtdLFxuICAgIHVwb25TYW5pdGl6ZUVsZW1lbnQ6IFtdLFxuICAgIHVwb25TYW5pdGl6ZVNoYWRvd05vZGU6IFtdXG4gIH07XG59O1xuZnVuY3Rpb24gY3JlYXRlRE9NUHVyaWZ5KCkge1xuICBsZXQgd2luZG93ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBnZXRHbG9iYWwoKTtcbiAgY29uc3QgRE9NUHVyaWZ5ID0gcm9vdCA9PiBjcmVhdGVET01QdXJpZnkocm9vdCk7XG4gIERPTVB1cmlmeS52ZXJzaW9uID0gJzMuMi42JztcbiAgRE9NUHVyaWZ5LnJlbW92ZWQgPSBbXTtcbiAgaWYgKCF3aW5kb3cgfHwgIXdpbmRvdy5kb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQubm9kZVR5cGUgIT09IE5PREVfVFlQRS5kb2N1bWVudCB8fCAhd2luZG93LkVsZW1lbnQpIHtcbiAgICAvLyBOb3QgcnVubmluZyBpbiBhIGJyb3dzZXIsIHByb3ZpZGUgYSBmYWN0b3J5IGZ1bmN0aW9uXG4gICAgLy8gc28gdGhhdCB5b3UgY2FuIHBhc3MgeW91ciBvd24gV2luZG93XG4gICAgRE9NUHVyaWZ5LmlzU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIERPTVB1cmlmeTtcbiAgfVxuICBsZXQge1xuICAgIGRvY3VtZW50XG4gIH0gPSB3aW5kb3c7XG4gIGNvbnN0IG9yaWdpbmFsRG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgY29uc3QgY3VycmVudFNjcmlwdCA9IG9yaWdpbmFsRG9jdW1lbnQuY3VycmVudFNjcmlwdDtcbiAgY29uc3Qge1xuICAgIERvY3VtZW50RnJhZ21lbnQsXG4gICAgSFRNTFRlbXBsYXRlRWxlbWVudCxcbiAgICBOb2RlLFxuICAgIEVsZW1lbnQsXG4gICAgTm9kZUZpbHRlcixcbiAgICBOYW1lZE5vZGVNYXAgPSB3aW5kb3cuTmFtZWROb2RlTWFwIHx8IHdpbmRvdy5Nb3pOYW1lZEF0dHJNYXAsXG4gICAgSFRNTEZvcm1FbGVtZW50LFxuICAgIERPTVBhcnNlcixcbiAgICB0cnVzdGVkVHlwZXNcbiAgfSA9IHdpbmRvdztcbiAgY29uc3QgRWxlbWVudFByb3RvdHlwZSA9IEVsZW1lbnQucHJvdG90eXBlO1xuICBjb25zdCBjbG9uZU5vZGUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ2Nsb25lTm9kZScpO1xuICBjb25zdCByZW1vdmUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ3JlbW92ZScpO1xuICBjb25zdCBnZXROZXh0U2libGluZyA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnbmV4dFNpYmxpbmcnKTtcbiAgY29uc3QgZ2V0Q2hpbGROb2RlcyA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnY2hpbGROb2RlcycpO1xuICBjb25zdCBnZXRQYXJlbnROb2RlID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdwYXJlbnROb2RlJyk7XG4gIC8vIEFzIHBlciBpc3N1ZSAjNDcsIHRoZSB3ZWItY29tcG9uZW50cyByZWdpc3RyeSBpcyBpbmhlcml0ZWQgYnkgYVxuICAvLyBuZXcgZG9jdW1lbnQgY3JlYXRlZCB2aWEgY3JlYXRlSFRNTERvY3VtZW50LiBBcyBwZXIgdGhlIHNwZWNcbiAgLy8gKGh0dHA6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2NyZWF0aW5nLWFuZC1wYXNzaW5nLXJlZ2lzdHJpZXMpXG4gIC8vIGEgbmV3IGVtcHR5IHJlZ2lzdHJ5IGlzIHVzZWQgd2hlbiBjcmVhdGluZyBhIHRlbXBsYXRlIGNvbnRlbnRzIG93bmVyXG4gIC8vIGRvY3VtZW50LCBzbyB3ZSB1c2UgdGhhdCBhcyBvdXIgcGFyZW50IGRvY3VtZW50IHRvIGVuc3VyZSBub3RoaW5nXG4gIC8vIGlzIGluaGVyaXRlZC5cbiAgaWYgKHR5cGVvZiBIVE1MVGVtcGxhdGVFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIGlmICh0ZW1wbGF0ZS5jb250ZW50ICYmIHRlbXBsYXRlLmNvbnRlbnQub3duZXJEb2N1bWVudCkge1xuICAgICAgZG9jdW1lbnQgPSB0ZW1wbGF0ZS5jb250ZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuICB9XG4gIGxldCB0cnVzdGVkVHlwZXNQb2xpY3k7XG4gIGxldCBlbXB0eUhUTUwgPSAnJztcbiAgY29uc3Qge1xuICAgIGltcGxlbWVudGF0aW9uLFxuICAgIGNyZWF0ZU5vZGVJdGVyYXRvcixcbiAgICBjcmVhdGVEb2N1bWVudEZyYWdtZW50LFxuICAgIGdldEVsZW1lbnRzQnlUYWdOYW1lXG4gIH0gPSBkb2N1bWVudDtcbiAgY29uc3Qge1xuICAgIGltcG9ydE5vZGVcbiAgfSA9IG9yaWdpbmFsRG9jdW1lbnQ7XG4gIGxldCBob29rcyA9IF9jcmVhdGVIb29rc01hcCgpO1xuICAvKipcbiAgICogRXhwb3NlIHdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHJ1bm5pbmcgdGhlIGZ1bGwgRE9NUHVyaWZ5LlxuICAgKi9cbiAgRE9NUHVyaWZ5LmlzU3VwcG9ydGVkID0gdHlwZW9mIGVudHJpZXMgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGdldFBhcmVudE5vZGUgPT09ICdmdW5jdGlvbicgJiYgaW1wbGVtZW50YXRpb24gJiYgaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50ICE9PSB1bmRlZmluZWQ7XG4gIGNvbnN0IHtcbiAgICBNVVNUQUNIRV9FWFBSLFxuICAgIEVSQl9FWFBSLFxuICAgIFRNUExJVF9FWFBSLFxuICAgIERBVEFfQVRUUixcbiAgICBBUklBX0FUVFIsXG4gICAgSVNfU0NSSVBUX09SX0RBVEEsXG4gICAgQVRUUl9XSElURVNQQUNFLFxuICAgIENVU1RPTV9FTEVNRU5UXG4gIH0gPSBFWFBSRVNTSU9OUztcbiAgbGV0IHtcbiAgICBJU19BTExPV0VEX1VSSTogSVNfQUxMT1dFRF9VUkkkMVxuICB9ID0gRVhQUkVTU0lPTlM7XG4gIC8qKlxuICAgKiBXZSBjb25zaWRlciB0aGUgZWxlbWVudHMgYW5kIGF0dHJpYnV0ZXMgYmVsb3cgdG8gYmUgc2FmZS4gSWRlYWxseVxuICAgKiBkb24ndCBhZGQgYW55IG5ldyBvbmVzIGJ1dCBmZWVsIGZyZWUgdG8gcmVtb3ZlIHVud2FudGVkIG9uZXMuXG4gICAqL1xuICAvKiBhbGxvd2VkIGVsZW1lbnQgbmFtZXMgKi9cbiAgbGV0IEFMTE9XRURfVEFHUyA9IG51bGw7XG4gIGNvbnN0IERFRkFVTFRfQUxMT1dFRF9UQUdTID0gYWRkVG9TZXQoe30sIFsuLi5odG1sJDEsIC4uLnN2ZyQxLCAuLi5zdmdGaWx0ZXJzLCAuLi5tYXRoTWwkMSwgLi4udGV4dF0pO1xuICAvKiBBbGxvd2VkIGF0dHJpYnV0ZSBuYW1lcyAqL1xuICBsZXQgQUxMT1dFRF9BVFRSID0gbnVsbDtcbiAgY29uc3QgREVGQVVMVF9BTExPV0VEX0FUVFIgPSBhZGRUb1NldCh7fSwgWy4uLmh0bWwsIC4uLnN2ZywgLi4ubWF0aE1sLCAuLi54bWxdKTtcbiAgLypcbiAgICogQ29uZmlndXJlIGhvdyBET01QdXJpZnkgc2hvdWxkIGhhbmRsZSBjdXN0b20gZWxlbWVudHMgYW5kIHRoZWlyIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBjdXN0b21pemVkIGJ1aWx0LWluIGVsZW1lbnRzLlxuICAgKiBAcHJvcGVydHkge1JlZ0V4cHxGdW5jdGlvbnxudWxsfSB0YWdOYW1lQ2hlY2sgb25lIG9mIFtudWxsLCByZWdleFBhdHRlcm4sIHByZWRpY2F0ZV0uIERlZmF1bHQ6IGBudWxsYCAoZGlzYWxsb3cgYW55IGN1c3RvbSBlbGVtZW50cylcbiAgICogQHByb3BlcnR5IHtSZWdFeHB8RnVuY3Rpb258bnVsbH0gYXR0cmlidXRlTmFtZUNoZWNrIG9uZSBvZiBbbnVsbCwgcmVnZXhQYXR0ZXJuLCBwcmVkaWNhdGVdLiBEZWZhdWx0OiBgbnVsbGAgKGRpc2FsbG93IGFueSBhdHRyaWJ1dGVzIG5vdCBvbiB0aGUgYWxsb3cgbGlzdClcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBhbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMgYWxsb3cgY3VzdG9tIGVsZW1lbnRzIGRlcml2ZWQgZnJvbSBidWlsdC1pbnMgaWYgdGhleSBwYXNzIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjay4gRGVmYXVsdDogYGZhbHNlYC5cbiAgICovXG4gIGxldCBDVVNUT01fRUxFTUVOVF9IQU5ETElORyA9IE9iamVjdC5zZWFsKGNyZWF0ZShudWxsLCB7XG4gICAgdGFnTmFtZUNoZWNrOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIGF0dHJpYnV0ZU5hbWVDaGVjazoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSxcbiAgICBhbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHM6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9XG4gIH0pKTtcbiAgLyogRXhwbGljaXRseSBmb3JiaWRkZW4gdGFncyAob3ZlcnJpZGVzIEFMTE9XRURfVEFHUy9BRERfVEFHUykgKi9cbiAgbGV0IEZPUkJJRF9UQUdTID0gbnVsbDtcbiAgLyogRXhwbGljaXRseSBmb3JiaWRkZW4gYXR0cmlidXRlcyAob3ZlcnJpZGVzIEFMTE9XRURfQVRUUi9BRERfQVRUUikgKi9cbiAgbGV0IEZPUkJJRF9BVFRSID0gbnVsbDtcbiAgLyogRGVjaWRlIGlmIEFSSUEgYXR0cmlidXRlcyBhcmUgb2theSAqL1xuICBsZXQgQUxMT1dfQVJJQV9BVFRSID0gdHJ1ZTtcbiAgLyogRGVjaWRlIGlmIGN1c3RvbSBkYXRhIGF0dHJpYnV0ZXMgYXJlIG9rYXkgKi9cbiAgbGV0IEFMTE9XX0RBVEFfQVRUUiA9IHRydWU7XG4gIC8qIERlY2lkZSBpZiB1bmtub3duIHByb3RvY29scyBhcmUgb2theSAqL1xuICBsZXQgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgPSBmYWxzZTtcbiAgLyogRGVjaWRlIGlmIHNlbGYtY2xvc2luZyB0YWdzIGluIGF0dHJpYnV0ZXMgYXJlIGFsbG93ZWQuXG4gICAqIFVzdWFsbHkgcmVtb3ZlZCBkdWUgdG8gYSBtWFNTIGlzc3VlIGluIGpRdWVyeSAzLjAgKi9cbiAgbGV0IEFMTE9XX1NFTEZfQ0xPU0VfSU5fQVRUUiA9IHRydWU7XG4gIC8qIE91dHB1dCBzaG91bGQgYmUgc2FmZSBmb3IgY29tbW9uIHRlbXBsYXRlIGVuZ2luZXMuXG4gICAqIFRoaXMgbWVhbnMsIERPTVB1cmlmeSByZW1vdmVzIGRhdGEgYXR0cmlidXRlcywgbXVzdGFjaGVzIGFuZCBFUkJcbiAgICovXG4gIGxldCBTQUZFX0ZPUl9URU1QTEFURVMgPSBmYWxzZTtcbiAgLyogT3V0cHV0IHNob3VsZCBiZSBzYWZlIGV2ZW4gZm9yIFhNTCB1c2VkIHdpdGhpbiBIVE1MIGFuZCBhbGlrZS5cbiAgICogVGhpcyBtZWFucywgRE9NUHVyaWZ5IHJlbW92ZXMgY29tbWVudHMgd2hlbiBjb250YWluaW5nIHJpc2t5IGNvbnRlbnQuXG4gICAqL1xuICBsZXQgU0FGRV9GT1JfWE1MID0gdHJ1ZTtcbiAgLyogRGVjaWRlIGlmIGRvY3VtZW50IHdpdGggPGh0bWw+Li4uIHNob3VsZCBiZSByZXR1cm5lZCAqL1xuICBsZXQgV0hPTEVfRE9DVU1FTlQgPSBmYWxzZTtcbiAgLyogVHJhY2sgd2hldGhlciBjb25maWcgaXMgYWxyZWFkeSBzZXQgb24gdGhpcyBpbnN0YW5jZSBvZiBET01QdXJpZnkuICovXG4gIGxldCBTRVRfQ09ORklHID0gZmFsc2U7XG4gIC8qIERlY2lkZSBpZiBhbGwgZWxlbWVudHMgKGUuZy4gc3R5bGUsIHNjcmlwdCkgbXVzdCBiZSBjaGlsZHJlbiBvZlxuICAgKiBkb2N1bWVudC5ib2R5LiBCeSBkZWZhdWx0LCBicm93c2VycyBtaWdodCBtb3ZlIHRoZW0gdG8gZG9jdW1lbnQuaGVhZCAqL1xuICBsZXQgRk9SQ0VfQk9EWSA9IGZhbHNlO1xuICAvKiBEZWNpZGUgaWYgYSBET00gYEhUTUxCb2R5RWxlbWVudGAgc2hvdWxkIGJlIHJldHVybmVkLCBpbnN0ZWFkIG9mIGEgaHRtbFxuICAgKiBzdHJpbmcgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkuXG4gICAqIElmIGBXSE9MRV9ET0NVTUVOVGAgaXMgZW5hYmxlZCBhIGBIVE1MSHRtbEVsZW1lbnRgIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZFxuICAgKi9cbiAgbGV0IFJFVFVSTl9ET00gPSBmYWxzZTtcbiAgLyogRGVjaWRlIGlmIGEgRE9NIGBEb2N1bWVudEZyYWdtZW50YCBzaG91bGQgYmUgcmV0dXJuZWQsIGluc3RlYWQgb2YgYSBodG1sXG4gICAqIHN0cmluZyAgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkgKi9cbiAgbGV0IFJFVFVSTl9ET01fRlJBR01FTlQgPSBmYWxzZTtcbiAgLyogVHJ5IHRvIHJldHVybiBhIFRydXN0ZWQgVHlwZSBvYmplY3QgaW5zdGVhZCBvZiBhIHN0cmluZywgcmV0dXJuIGEgc3RyaW5nIGluXG4gICAqIGNhc2UgVHJ1c3RlZCBUeXBlcyBhcmUgbm90IHN1cHBvcnRlZCAgKi9cbiAgbGV0IFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBmYWxzZTtcbiAgLyogT3V0cHV0IHNob3VsZCBiZSBmcmVlIGZyb20gRE9NIGNsb2JiZXJpbmcgYXR0YWNrcz9cbiAgICogVGhpcyBzYW5pdGl6ZXMgbWFya3VwcyBuYW1lZCB3aXRoIGNvbGxpZGluZywgY2xvYmJlcmFibGUgYnVpbHQtaW4gRE9NIEFQSXMuXG4gICAqL1xuICBsZXQgU0FOSVRJWkVfRE9NID0gdHJ1ZTtcbiAgLyogQWNoaWV2ZSBmdWxsIERPTSBDbG9iYmVyaW5nIHByb3RlY3Rpb24gYnkgaXNvbGF0aW5nIHRoZSBuYW1lc3BhY2Ugb2YgbmFtZWRcbiAgICogcHJvcGVydGllcyBhbmQgSlMgdmFyaWFibGVzLCBtaXRpZ2F0aW5nIGF0dGFja3MgdGhhdCBhYnVzZSB0aGUgSFRNTC9ET00gc3BlYyBydWxlcy5cbiAgICpcbiAgICogSFRNTC9ET00gc3BlYyBydWxlcyB0aGF0IGVuYWJsZSBET00gQ2xvYmJlcmluZzpcbiAgICogICAtIE5hbWVkIEFjY2VzcyBvbiBXaW5kb3cgKMKnNy4zLjMpXG4gICAqICAgLSBET00gVHJlZSBBY2Nlc3NvcnMgKMKnMy4xLjUpXG4gICAqICAgLSBGb3JtIEVsZW1lbnQgUGFyZW50LUNoaWxkIFJlbGF0aW9ucyAowqc0LjEwLjMpXG4gICAqICAgLSBJZnJhbWUgc3JjZG9jIC8gTmVzdGVkIFdpbmRvd1Byb3hpZXMgKMKnNC44LjUpXG4gICAqICAgLSBIVE1MQ29sbGVjdGlvbiAowqc0LjIuMTAuMilcbiAgICpcbiAgICogTmFtZXNwYWNlIGlzb2xhdGlvbiBpcyBpbXBsZW1lbnRlZCBieSBwcmVmaXhpbmcgYGlkYCBhbmQgYG5hbWVgIGF0dHJpYnV0ZXNcbiAgICogd2l0aCBhIGNvbnN0YW50IHN0cmluZywgaS5lLiwgYHVzZXItY29udGVudC1gXG4gICAqL1xuICBsZXQgU0FOSVRJWkVfTkFNRURfUFJPUFMgPSBmYWxzZTtcbiAgY29uc3QgU0FOSVRJWkVfTkFNRURfUFJPUFNfUFJFRklYID0gJ3VzZXItY29udGVudC0nO1xuICAvKiBLZWVwIGVsZW1lbnQgY29udGVudCB3aGVuIHJlbW92aW5nIGVsZW1lbnQ/ICovXG4gIGxldCBLRUVQX0NPTlRFTlQgPSB0cnVlO1xuICAvKiBJZiBhIGBOb2RlYCBpcyBwYXNzZWQgdG8gc2FuaXRpemUoKSwgdGhlbiBwZXJmb3JtcyBzYW5pdGl6YXRpb24gaW4tcGxhY2UgaW5zdGVhZFxuICAgKiBvZiBpbXBvcnRpbmcgaXQgaW50byBhIG5ldyBEb2N1bWVudCBhbmQgcmV0dXJuaW5nIGEgc2FuaXRpemVkIGNvcHkgKi9cbiAgbGV0IElOX1BMQUNFID0gZmFsc2U7XG4gIC8qIEFsbG93IHVzYWdlIG9mIHByb2ZpbGVzIGxpa2UgaHRtbCwgc3ZnIGFuZCBtYXRoTWwgKi9cbiAgbGV0IFVTRV9QUk9GSUxFUyA9IHt9O1xuICAvKiBUYWdzIHRvIGlnbm9yZSBjb250ZW50IG9mIHdoZW4gS0VFUF9DT05URU5UIGlzIHRydWUgKi9cbiAgbGV0IEZPUkJJRF9DT05URU5UUyA9IG51bGw7XG4gIGNvbnN0IERFRkFVTFRfRk9SQklEX0NPTlRFTlRTID0gYWRkVG9TZXQoe30sIFsnYW5ub3RhdGlvbi14bWwnLCAnYXVkaW8nLCAnY29sZ3JvdXAnLCAnZGVzYycsICdmb3JlaWdub2JqZWN0JywgJ2hlYWQnLCAnaWZyYW1lJywgJ21hdGgnLCAnbWknLCAnbW4nLCAnbW8nLCAnbXMnLCAnbXRleHQnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdwbGFpbnRleHQnLCAnc2NyaXB0JywgJ3N0eWxlJywgJ3N2ZycsICd0ZW1wbGF0ZScsICd0aGVhZCcsICd0aXRsZScsICd2aWRlbycsICd4bXAnXSk7XG4gIC8qIFRhZ3MgdGhhdCBhcmUgc2FmZSBmb3IgZGF0YTogVVJJcyAqL1xuICBsZXQgREFUQV9VUklfVEFHUyA9IG51bGw7XG4gIGNvbnN0IERFRkFVTFRfREFUQV9VUklfVEFHUyA9IGFkZFRvU2V0KHt9LCBbJ2F1ZGlvJywgJ3ZpZGVvJywgJ2ltZycsICdzb3VyY2UnLCAnaW1hZ2UnLCAndHJhY2snXSk7XG4gIC8qIEF0dHJpYnV0ZXMgc2FmZSBmb3IgdmFsdWVzIGxpa2UgXCJqYXZhc2NyaXB0OlwiICovXG4gIGxldCBVUklfU0FGRV9BVFRSSUJVVEVTID0gbnVsbDtcbiAgY29uc3QgREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTID0gYWRkVG9TZXQoe30sIFsnYWx0JywgJ2NsYXNzJywgJ2ZvcicsICdpZCcsICdsYWJlbCcsICduYW1lJywgJ3BhdHRlcm4nLCAncGxhY2Vob2xkZXInLCAncm9sZScsICdzdW1tYXJ5JywgJ3RpdGxlJywgJ3ZhbHVlJywgJ3N0eWxlJywgJ3htbG5zJ10pO1xuICBjb25zdCBNQVRITUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xuICBjb25zdCBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgY29uc3QgSFRNTF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG4gIC8qIERvY3VtZW50IG5hbWVzcGFjZSAqL1xuICBsZXQgTkFNRVNQQUNFID0gSFRNTF9OQU1FU1BBQ0U7XG4gIGxldCBJU19FTVBUWV9JTlBVVCA9IGZhbHNlO1xuICAvKiBBbGxvd2VkIFhIVE1MK1hNTCBuYW1lc3BhY2VzICovXG4gIGxldCBBTExPV0VEX05BTUVTUEFDRVMgPSBudWxsO1xuICBjb25zdCBERUZBVUxUX0FMTE9XRURfTkFNRVNQQUNFUyA9IGFkZFRvU2V0KHt9LCBbTUFUSE1MX05BTUVTUEFDRSwgU1ZHX05BTUVTUEFDRSwgSFRNTF9OQU1FU1BBQ0VdLCBzdHJpbmdUb1N0cmluZyk7XG4gIGxldCBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFMgPSBhZGRUb1NldCh7fSwgWydtaScsICdtbycsICdtbicsICdtcycsICdtdGV4dCddKTtcbiAgbGV0IEhUTUxfSU5URUdSQVRJT05fUE9JTlRTID0gYWRkVG9TZXQoe30sIFsnYW5ub3RhdGlvbi14bWwnXSk7XG4gIC8vIENlcnRhaW4gZWxlbWVudHMgYXJlIGFsbG93ZWQgaW4gYm90aCBTVkcgYW5kIEhUTUxcbiAgLy8gbmFtZXNwYWNlLiBXZSBuZWVkIHRvIHNwZWNpZnkgdGhlbSBleHBsaWNpdGx5XG4gIC8vIHNvIHRoYXQgdGhleSBkb24ndCBnZXQgZXJyb25lb3VzbHkgZGVsZXRlZCBmcm9tXG4gIC8vIEhUTUwgbmFtZXNwYWNlLlxuICBjb25zdCBDT01NT05fU1ZHX0FORF9IVE1MX0VMRU1FTlRTID0gYWRkVG9TZXQoe30sIFsndGl0bGUnLCAnc3R5bGUnLCAnZm9udCcsICdhJywgJ3NjcmlwdCddKTtcbiAgLyogUGFyc2luZyBvZiBzdHJpY3QgWEhUTUwgZG9jdW1lbnRzICovXG4gIGxldCBQQVJTRVJfTUVESUFfVFlQRSA9IG51bGw7XG4gIGNvbnN0IFNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMgPSBbJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcsICd0ZXh0L2h0bWwnXTtcbiAgY29uc3QgREVGQVVMVF9QQVJTRVJfTUVESUFfVFlQRSA9ICd0ZXh0L2h0bWwnO1xuICBsZXQgdHJhbnNmb3JtQ2FzZUZ1bmMgPSBudWxsO1xuICAvKiBLZWVwIGEgcmVmZXJlbmNlIHRvIGNvbmZpZyB0byBwYXNzIHRvIGhvb2tzICovXG4gIGxldCBDT05GSUcgPSBudWxsO1xuICAvKiBJZGVhbGx5LCBkbyBub3QgdG91Y2ggYW55dGhpbmcgYmVsb3cgdGhpcyBsaW5lICovXG4gIC8qIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18gKi9cbiAgY29uc3QgZm9ybUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gIGNvbnN0IGlzUmVnZXhPckZ1bmN0aW9uID0gZnVuY3Rpb24gaXNSZWdleE9yRnVuY3Rpb24odGVzdFZhbHVlKSB7XG4gICAgcmV0dXJuIHRlc3RWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCB0ZXN0VmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgfTtcbiAgLyoqXG4gICAqIF9wYXJzZUNvbmZpZ1xuICAgKlxuICAgKiBAcGFyYW0gY2ZnIG9wdGlvbmFsIGNvbmZpZyBsaXRlcmFsXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBjb25zdCBfcGFyc2VDb25maWcgPSBmdW5jdGlvbiBfcGFyc2VDb25maWcoKSB7XG4gICAgbGV0IGNmZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKENPTkZJRyAmJiBDT05GSUcgPT09IGNmZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiBTaGllbGQgY29uZmlndXJhdGlvbiBvYmplY3QgZnJvbSB0YW1wZXJpbmcgKi9cbiAgICBpZiAoIWNmZyB8fCB0eXBlb2YgY2ZnICE9PSAnb2JqZWN0Jykge1xuICAgICAgY2ZnID0ge307XG4gICAgfVxuICAgIC8qIFNoaWVsZCBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHByb3RvdHlwZSBwb2xsdXRpb24gKi9cbiAgICBjZmcgPSBjbG9uZShjZmcpO1xuICAgIFBBUlNFUl9NRURJQV9UWVBFID1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItaW5jbHVkZXNcbiAgICBTVVBQT1JURURfUEFSU0VSX01FRElBX1RZUEVTLmluZGV4T2YoY2ZnLlBBUlNFUl9NRURJQV9UWVBFKSA9PT0gLTEgPyBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFIDogY2ZnLlBBUlNFUl9NRURJQV9UWVBFO1xuICAgIC8vIEhUTUwgdGFncyBhbmQgYXR0cmlidXRlcyBhcmUgbm90IGNhc2Utc2Vuc2l0aXZlLCBjb252ZXJ0aW5nIHRvIGxvd2VyY2FzZS4gS2VlcGluZyBYSFRNTCBhcyBpcy5cbiAgICB0cmFuc2Zvcm1DYXNlRnVuYyA9IFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJyA/IHN0cmluZ1RvU3RyaW5nIDogc3RyaW5nVG9Mb3dlckNhc2U7XG4gICAgLyogU2V0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyAqL1xuICAgIEFMTE9XRURfVEFHUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0FMTE9XRURfVEFHUycpID8gYWRkVG9TZXQoe30sIGNmZy5BTExPV0VEX1RBR1MsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IERFRkFVTFRfQUxMT1dFRF9UQUdTO1xuICAgIEFMTE9XRURfQVRUUiA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0FMTE9XRURfQVRUUicpID8gYWRkVG9TZXQoe30sIGNmZy5BTExPV0VEX0FUVFIsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IERFRkFVTFRfQUxMT1dFRF9BVFRSO1xuICAgIEFMTE9XRURfTkFNRVNQQUNFUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0FMTE9XRURfTkFNRVNQQUNFUycpID8gYWRkVG9TZXQoe30sIGNmZy5BTExPV0VEX05BTUVTUEFDRVMsIHN0cmluZ1RvU3RyaW5nKSA6IERFRkFVTFRfQUxMT1dFRF9OQU1FU1BBQ0VTO1xuICAgIFVSSV9TQUZFX0FUVFJJQlVURVMgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShjZmcsICdBRERfVVJJX1NBRkVfQVRUUicpID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTKSwgY2ZnLkFERF9VUklfU0FGRV9BVFRSLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVM7XG4gICAgREFUQV9VUklfVEFHUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0FERF9EQVRBX1VSSV9UQUdTJykgPyBhZGRUb1NldChjbG9uZShERUZBVUxUX0RBVEFfVVJJX1RBR1MpLCBjZmcuQUREX0RBVEFfVVJJX1RBR1MsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IERFRkFVTFRfREFUQV9VUklfVEFHUztcbiAgICBGT1JCSURfQ09OVEVOVFMgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShjZmcsICdGT1JCSURfQ09OVEVOVFMnKSA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX0NPTlRFTlRTLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiBERUZBVUxUX0ZPUkJJRF9DT05URU5UUztcbiAgICBGT1JCSURfVEFHUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ0ZPUkJJRF9UQUdTJykgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9UQUdTLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiBjbG9uZSh7fSk7XG4gICAgRk9SQklEX0FUVFIgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShjZmcsICdGT1JCSURfQVRUUicpID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQVRUUiwgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogY2xvbmUoe30pO1xuICAgIFVTRV9QUk9GSUxFUyA9IG9iamVjdEhhc093blByb3BlcnR5KGNmZywgJ1VTRV9QUk9GSUxFUycpID8gY2ZnLlVTRV9QUk9GSUxFUyA6IGZhbHNlO1xuICAgIEFMTE9XX0FSSUFfQVRUUiA9IGNmZy5BTExPV19BUklBX0FUVFIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBBTExPV19EQVRBX0FUVFIgPSBjZmcuQUxMT1dfREFUQV9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgPSBjZmcuQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBBTExPV19TRUxGX0NMT1NFX0lOX0FUVFIgPSBjZmcuQUxMT1dfU0VMRl9DTE9TRV9JTl9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgU0FGRV9GT1JfVEVNUExBVEVTID0gY2ZnLlNBRkVfRk9SX1RFTVBMQVRFUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFNBRkVfRk9SX1hNTCA9IGNmZy5TQUZFX0ZPUl9YTUwgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBXSE9MRV9ET0NVTUVOVCA9IGNmZy5XSE9MRV9ET0NVTUVOVCB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9ET00gPSBjZmcuUkVUVVJOX0RPTSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9ET01fRlJBR01FTlQgPSBjZmcuUkVUVVJOX0RPTV9GUkFHTUVOVCB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBjZmcuUkVUVVJOX1RSVVNURURfVFlQRSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIEZPUkNFX0JPRFkgPSBjZmcuRk9SQ0VfQk9EWSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFNBTklUSVpFX0RPTSA9IGNmZy5TQU5JVElaRV9ET00gIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBTQU5JVElaRV9OQU1FRF9QUk9QUyA9IGNmZy5TQU5JVElaRV9OQU1FRF9QUk9QUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIEtFRVBfQ09OVEVOVCA9IGNmZy5LRUVQX0NPTlRFTlQgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBJTl9QTEFDRSA9IGNmZy5JTl9QTEFDRSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIElTX0FMTE9XRURfVVJJJDEgPSBjZmcuQUxMT1dFRF9VUklfUkVHRVhQIHx8IElTX0FMTE9XRURfVVJJO1xuICAgIE5BTUVTUEFDRSA9IGNmZy5OQU1FU1BBQ0UgfHwgSFRNTF9OQU1FU1BBQ0U7XG4gICAgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTID0gY2ZnLk1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UUyB8fCBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFM7XG4gICAgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMgPSBjZmcuSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMgfHwgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFM7XG4gICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgPSBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgfHwge307XG4gICAgaWYgKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiBpc1JlZ2V4T3JGdW5jdGlvbihjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrKSkge1xuICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaztcbiAgICB9XG4gICAgaWYgKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiBpc1JlZ2V4T3JGdW5jdGlvbihjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrKSkge1xuICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjaztcbiAgICB9XG4gICAgaWYgKGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORyAmJiB0eXBlb2YgY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMgPSBjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzO1xuICAgIH1cbiAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICBBTExPV19EQVRBX0FUVFIgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgIFJFVFVSTl9ET00gPSB0cnVlO1xuICAgIH1cbiAgICAvKiBQYXJzZSBwcm9maWxlIGluZm8gKi9cbiAgICBpZiAoVVNFX1BST0ZJTEVTKSB7XG4gICAgICBBTExPV0VEX1RBR1MgPSBhZGRUb1NldCh7fSwgdGV4dCk7XG4gICAgICBBTExPV0VEX0FUVFIgPSBbXTtcbiAgICAgIGlmIChVU0VfUFJPRklMRVMuaHRtbCA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGh0bWwkMSk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgaHRtbCk7XG4gICAgICB9XG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2ZyA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2ZyQxKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBzdmcpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2Z0ZpbHRlcnMgPT09IHRydWUpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBzdmcpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLm1hdGhNbCA9PT0gdHJ1ZSkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIG1hdGhNbCQxKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBtYXRoTWwpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIE1lcmdlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyAqL1xuICAgIGlmIChjZmcuQUREX1RBR1MpIHtcbiAgICAgIGlmIChBTExPV0VEX1RBR1MgPT09IERFRkFVTFRfQUxMT1dFRF9UQUdTKSB7XG4gICAgICAgIEFMTE9XRURfVEFHUyA9IGNsb25lKEFMTE9XRURfVEFHUyk7XG4gICAgICB9XG4gICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIGNmZy5BRERfVEFHUywgdHJhbnNmb3JtQ2FzZUZ1bmMpO1xuICAgIH1cbiAgICBpZiAoY2ZnLkFERF9BVFRSKSB7XG4gICAgICBpZiAoQUxMT1dFRF9BVFRSID09PSBERUZBVUxUX0FMTE9XRURfQVRUUikge1xuICAgICAgICBBTExPV0VEX0FUVFIgPSBjbG9uZShBTExPV0VEX0FUVFIpO1xuICAgICAgfVxuICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBjZmcuQUREX0FUVFIsIHRyYW5zZm9ybUNhc2VGdW5jKTtcbiAgICB9XG4gICAgaWYgKGNmZy5BRERfVVJJX1NBRkVfQVRUUikge1xuICAgICAgYWRkVG9TZXQoVVJJX1NBRkVfQVRUUklCVVRFUywgY2ZnLkFERF9VUklfU0FGRV9BVFRSLCB0cmFuc2Zvcm1DYXNlRnVuYyk7XG4gICAgfVxuICAgIGlmIChjZmcuRk9SQklEX0NPTlRFTlRTKSB7XG4gICAgICBpZiAoRk9SQklEX0NPTlRFTlRTID09PSBERUZBVUxUX0ZPUkJJRF9DT05URU5UUykge1xuICAgICAgICBGT1JCSURfQ09OVEVOVFMgPSBjbG9uZShGT1JCSURfQ09OVEVOVFMpO1xuICAgICAgfVxuICAgICAgYWRkVG9TZXQoRk9SQklEX0NPTlRFTlRTLCBjZmcuRk9SQklEX0NPTlRFTlRTLCB0cmFuc2Zvcm1DYXNlRnVuYyk7XG4gICAgfVxuICAgIC8qIEFkZCAjdGV4dCBpbiBjYXNlIEtFRVBfQ09OVEVOVCBpcyBzZXQgdG8gdHJ1ZSAqL1xuICAgIGlmIChLRUVQX0NPTlRFTlQpIHtcbiAgICAgIEFMTE9XRURfVEFHU1snI3RleHQnXSA9IHRydWU7XG4gICAgfVxuICAgIC8qIEFkZCBodG1sLCBoZWFkIGFuZCBib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIFdIT0xFX0RPQ1VNRU5UIGlzIHRydWUgKi9cbiAgICBpZiAoV0hPTEVfRE9DVU1FTlQpIHtcbiAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgWydodG1sJywgJ2hlYWQnLCAnYm9keSddKTtcbiAgICB9XG4gICAgLyogQWRkIHRib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIHRhYmxlcyBhcmUgcGVybWl0dGVkLCBzZWUgIzI4NiwgIzM2NSAqL1xuICAgIGlmIChBTExPV0VEX1RBR1MudGFibGUpIHtcbiAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgWyd0Ym9keSddKTtcbiAgICAgIGRlbGV0ZSBGT1JCSURfVEFHUy50Ym9keTtcbiAgICB9XG4gICAgaWYgKGNmZy5UUlVTVEVEX1RZUEVTX1BPTElDWSkge1xuICAgICAgaWYgKHR5cGVvZiBjZmcuVFJVU1RFRF9UWVBFU19QT0xJQ1kuY3JlYXRlSFRNTCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ1RSVVNURURfVFlQRVNfUE9MSUNZIGNvbmZpZ3VyYXRpb24gb3B0aW9uIG11c3QgcHJvdmlkZSBhIFwiY3JlYXRlSFRNTFwiIGhvb2suJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNmZy5UUlVTVEVEX1RZUEVTX1BPTElDWS5jcmVhdGVTY3JpcHRVUkwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCdUUlVTVEVEX1RZUEVTX1BPTElDWSBjb25maWd1cmF0aW9uIG9wdGlvbiBtdXN0IHByb3ZpZGUgYSBcImNyZWF0ZVNjcmlwdFVSTFwiIGhvb2suJyk7XG4gICAgICB9XG4gICAgICAvLyBPdmVyd3JpdGUgZXhpc3RpbmcgVHJ1c3RlZFR5cGVzIHBvbGljeS5cbiAgICAgIHRydXN0ZWRUeXBlc1BvbGljeSA9IGNmZy5UUlVTVEVEX1RZUEVTX1BPTElDWTtcbiAgICAgIC8vIFNpZ24gbG9jYWwgdmFyaWFibGVzIHJlcXVpcmVkIGJ5IGBzYW5pdGl6ZWAuXG4gICAgICBlbXB0eUhUTUwgPSB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTCgnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVuaW5pdGlhbGl6ZWQgcG9saWN5LCBhdHRlbXB0IHRvIGluaXRpYWxpemUgdGhlIGludGVybmFsIGRvbXB1cmlmeSBwb2xpY3kuXG4gICAgICBpZiAodHJ1c3RlZFR5cGVzUG9saWN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHJ1c3RlZFR5cGVzUG9saWN5ID0gX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSh0cnVzdGVkVHlwZXMsIGN1cnJlbnRTY3JpcHQpO1xuICAgICAgfVxuICAgICAgLy8gSWYgY3JlYXRpbmcgdGhlIGludGVybmFsIHBvbGljeSBzdWNjZWVkZWQgc2lnbiBpbnRlcm5hbCB2YXJpYWJsZXMuXG4gICAgICBpZiAodHJ1c3RlZFR5cGVzUG9saWN5ICE9PSBudWxsICYmIHR5cGVvZiBlbXB0eUhUTUwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVtcHR5SFRNTCA9IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUHJldmVudCBmdXJ0aGVyIG1hbmlwdWxhdGlvbiBvZiBjb25maWd1cmF0aW9uLlxuICAgIC8vIE5vdCBhdmFpbGFibGUgaW4gSUU4LCBTYWZhcmkgNSwgZXRjLlxuICAgIGlmIChmcmVlemUpIHtcbiAgICAgIGZyZWV6ZShjZmcpO1xuICAgIH1cbiAgICBDT05GSUcgPSBjZmc7XG4gIH07XG4gIC8qIEtlZXAgdHJhY2sgb2YgYWxsIHBvc3NpYmxlIFNWRyBhbmQgTWF0aE1MIHRhZ3NcbiAgICogc28gdGhhdCB3ZSBjYW4gcGVyZm9ybSB0aGUgbmFtZXNwYWNlIGNoZWNrc1xuICAgKiBjb3JyZWN0bHkuICovXG4gIGNvbnN0IEFMTF9TVkdfVEFHUyA9IGFkZFRvU2V0KHt9LCBbLi4uc3ZnJDEsIC4uLnN2Z0ZpbHRlcnMsIC4uLnN2Z0Rpc2FsbG93ZWRdKTtcbiAgY29uc3QgQUxMX01BVEhNTF9UQUdTID0gYWRkVG9TZXQoe30sIFsuLi5tYXRoTWwkMSwgLi4ubWF0aE1sRGlzYWxsb3dlZF0pO1xuICAvKipcbiAgICogQHBhcmFtIGVsZW1lbnQgYSBET00gZWxlbWVudCB3aG9zZSBuYW1lc3BhY2UgaXMgYmVpbmcgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBSZXR1cm4gZmFsc2UgaWYgdGhlIGVsZW1lbnQgaGFzIGFcbiAgICogIG5hbWVzcGFjZSB0aGF0IGEgc3BlYy1jb21wbGlhbnQgcGFyc2VyIHdvdWxkIG5ldmVyXG4gICAqICByZXR1cm4uIFJldHVybiB0cnVlIG90aGVyd2lzZS5cbiAgICovXG4gIGNvbnN0IF9jaGVja1ZhbGlkTmFtZXNwYWNlID0gZnVuY3Rpb24gX2NoZWNrVmFsaWROYW1lc3BhY2UoZWxlbWVudCkge1xuICAgIGxldCBwYXJlbnQgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICAgIC8vIEluIEpTRE9NLCBpZiB3ZSdyZSBpbnNpZGUgc2hhZG93IERPTSwgdGhlbiBwYXJlbnROb2RlXG4gICAgLy8gY2FuIGJlIG51bGwuIFdlIGp1c3Qgc2ltdWxhdGUgcGFyZW50IGluIHRoaXMgY2FzZS5cbiAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50LnRhZ05hbWUpIHtcbiAgICAgIHBhcmVudCA9IHtcbiAgICAgICAgbmFtZXNwYWNlVVJJOiBOQU1FU1BBQ0UsXG4gICAgICAgIHRhZ05hbWU6ICd0ZW1wbGF0ZSdcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHRhZ05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShlbGVtZW50LnRhZ05hbWUpO1xuICAgIGNvbnN0IHBhcmVudFRhZ05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShwYXJlbnQudGFnTmFtZSk7XG4gICAgaWYgKCFBTExPV0VEX05BTUVTUEFDRVNbZWxlbWVudC5uYW1lc3BhY2VVUkldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIEhUTUwgbmFtZXNwYWNlIHRvIFNWR1xuICAgICAgLy8gaXMgdmlhIDxzdmc+LiBJZiBpdCBoYXBwZW5zIHZpYSBhbnkgb3RoZXIgdGFnLCB0aGVuXG4gICAgICAvLyBpdCBzaG91bGQgYmUga2lsbGVkLlxuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJztcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBNYXRoTUwgdG8gU1ZHIGlzIHZpYWBcbiAgICAgIC8vIHN2ZyBpZiBwYXJlbnQgaXMgZWl0aGVyIDxhbm5vdGF0aW9uLXhtbD4gb3IgTWF0aE1MXG4gICAgICAvLyB0ZXh0IGludGVncmF0aW9uIHBvaW50cy5cbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJyAmJiAocGFyZW50VGFnTmFtZSA9PT0gJ2Fubm90YXRpb24teG1sJyB8fCBNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pO1xuICAgICAgfVxuICAgICAgLy8gV2Ugb25seSBhbGxvdyBlbGVtZW50cyB0aGF0IGFyZSBkZWZpbmVkIGluIFNWR1xuICAgICAgLy8gc3BlYy4gQWxsIG90aGVycyBhcmUgZGlzYWxsb3dlZCBpbiBTVkcgbmFtZXNwYWNlLlxuICAgICAgcmV0dXJuIEJvb2xlYW4oQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gSFRNTCBuYW1lc3BhY2UgdG8gTWF0aE1MXG4gICAgICAvLyBpcyB2aWEgPG1hdGg+LiBJZiBpdCBoYXBwZW5zIHZpYSBhbnkgb3RoZXIgdGFnLCB0aGVuXG4gICAgICAvLyBpdCBzaG91bGQgYmUga2lsbGVkLlxuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnbWF0aCc7XG4gICAgICB9XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gU1ZHIHRvIE1hdGhNTCBpcyB2aWFcbiAgICAgIC8vIDxtYXRoPiBhbmQgSFRNTCBpbnRlZ3JhdGlvbiBwb2ludHNcbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnbWF0aCcgJiYgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV07XG4gICAgICB9XG4gICAgICAvLyBXZSBvbmx5IGFsbG93IGVsZW1lbnRzIHRoYXQgYXJlIGRlZmluZWQgaW4gTWF0aE1MXG4gICAgICAvLyBzcGVjLiBBbGwgb3RoZXJzIGFyZSBkaXNhbGxvd2VkIGluIE1hdGhNTCBuYW1lc3BhY2UuXG4gICAgICByZXR1cm4gQm9vbGVhbihBTExfTUFUSE1MX1RBR1NbdGFnTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gU1ZHIHRvIEhUTUwgaXMgdmlhXG4gICAgICAvLyBIVE1MIGludGVncmF0aW9uIHBvaW50cywgYW5kIGZyb20gTWF0aE1MIHRvIEhUTUxcbiAgICAgIC8vIGlzIHZpYSBNYXRoTUwgdGV4dCBpbnRlZ3JhdGlvbiBwb2ludHNcbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFICYmICFIVE1MX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSAmJiAhTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGRpc2FsbG93IHRhZ3MgdGhhdCBhcmUgc3BlY2lmaWMgZm9yIE1hdGhNTFxuICAgICAgLy8gb3IgU1ZHIGFuZCBzaG91bGQgbmV2ZXIgYXBwZWFyIGluIEhUTUwgbmFtZXNwYWNlXG4gICAgICByZXR1cm4gIUFMTF9NQVRITUxfVEFHU1t0YWdOYW1lXSAmJiAoQ09NTU9OX1NWR19BTkRfSFRNTF9FTEVNRU5UU1t0YWdOYW1lXSB8fCAhQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICB9XG4gICAgLy8gRm9yIFhIVE1MIGFuZCBYTUwgZG9jdW1lbnRzIHRoYXQgc3VwcG9ydCBjdXN0b20gbmFtZXNwYWNlc1xuICAgIGlmIChQQVJTRVJfTUVESUFfVFlQRSA9PT0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcgJiYgQUxMT1dFRF9OQU1FU1BBQ0VTW2VsZW1lbnQubmFtZXNwYWNlVVJJXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFRoZSBjb2RlIHNob3VsZCBuZXZlciByZWFjaCB0aGlzIHBsYWNlICh0aGlzIG1lYW5zXG4gICAgLy8gdGhhdCB0aGUgZWxlbWVudCBzb21laG93IGdvdCBuYW1lc3BhY2UgdGhhdCBpcyBub3RcbiAgICAvLyBIVE1MLCBTVkcsIE1hdGhNTCBvciBhbGxvd2VkIHZpYSBBTExPV0VEX05BTUVTUEFDRVMpLlxuICAgIC8vIFJldHVybiBmYWxzZSBqdXN0IGluIGNhc2UuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICAvKipcbiAgICogX2ZvcmNlUmVtb3ZlXG4gICAqXG4gICAqIEBwYXJhbSBub2RlIGEgRE9NIG5vZGVcbiAgICovXG4gIGNvbnN0IF9mb3JjZVJlbW92ZSA9IGZ1bmN0aW9uIF9mb3JjZVJlbW92ZShub2RlKSB7XG4gICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICBlbGVtZW50OiBub2RlXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1yZW1vdmVcbiAgICAgIGdldFBhcmVudE5vZGUobm9kZSkucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmVtb3ZlKG5vZGUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIF9yZW1vdmVBdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgYW4gQXR0cmlidXRlIG5hbWVcbiAgICogQHBhcmFtIGVsZW1lbnQgYSBET00gbm9kZVxuICAgKi9cbiAgY29uc3QgX3JlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgZWxlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgYXR0cmlidXRlOiBlbGVtZW50LmdldEF0dHJpYnV0ZU5vZGUobmFtZSksXG4gICAgICAgIGZyb206IGVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICBhdHRyaWJ1dGU6IG51bGwsXG4gICAgICAgIGZyb206IGVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAvLyBXZSB2b2lkIGF0dHJpYnV0ZSB2YWx1ZXMgZm9yIHVucmVtb3ZhYmxlIFwiaXNcIiBhdHRyaWJ1dGVzXG4gICAgaWYgKG5hbWUgPT09ICdpcycpIHtcbiAgICAgIGlmIChSRVRVUk5fRE9NIHx8IFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfZm9yY2VSZW1vdmUoZWxlbWVudCk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBfaW5pdERvY3VtZW50XG4gICAqXG4gICAqIEBwYXJhbSBkaXJ0eSAtIGEgc3RyaW5nIG9mIGRpcnR5IG1hcmt1cFxuICAgKiBAcmV0dXJuIGEgRE9NLCBmaWxsZWQgd2l0aCB0aGUgZGlydHkgbWFya3VwXG4gICAqL1xuICBjb25zdCBfaW5pdERvY3VtZW50ID0gZnVuY3Rpb24gX2luaXREb2N1bWVudChkaXJ0eSkge1xuICAgIC8qIENyZWF0ZSBhIEhUTUwgZG9jdW1lbnQgKi9cbiAgICBsZXQgZG9jID0gbnVsbDtcbiAgICBsZXQgbGVhZGluZ1doaXRlc3BhY2UgPSBudWxsO1xuICAgIGlmIChGT1JDRV9CT0RZKSB7XG4gICAgICBkaXJ0eSA9ICc8cmVtb3ZlPjwvcmVtb3ZlPicgKyBkaXJ0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogSWYgRk9SQ0VfQk9EWSBpc24ndCB1c2VkLCBsZWFkaW5nIHdoaXRlc3BhY2UgbmVlZHMgdG8gYmUgcHJlc2VydmVkIG1hbnVhbGx5ICovXG4gICAgICBjb25zdCBtYXRjaGVzID0gc3RyaW5nTWF0Y2goZGlydHksIC9eW1xcclxcblxcdCBdKy8pO1xuICAgICAgbGVhZGluZ1doaXRlc3BhY2UgPSBtYXRjaGVzICYmIG1hdGNoZXNbMF07XG4gICAgfVxuICAgIGlmIChQQVJTRVJfTUVESUFfVFlQRSA9PT0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcgJiYgTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgLy8gUm9vdCBvZiBYSFRNTCBkb2MgbXVzdCBjb250YWluIHhtbG5zIGRlY2xhcmF0aW9uIChzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3hodG1sMS9ub3JtYXRpdmUuaHRtbCNzdHJpY3QpXG4gICAgICBkaXJ0eSA9ICc8aHRtbCB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj48aGVhZD48L2hlYWQ+PGJvZHk+JyArIGRpcnR5ICsgJzwvYm9keT48L2h0bWw+JztcbiAgICB9XG4gICAgY29uc3QgZGlydHlQYXlsb2FkID0gdHJ1c3RlZFR5cGVzUG9saWN5ID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgLypcbiAgICAgKiBVc2UgdGhlIERPTVBhcnNlciBBUEkgYnkgZGVmYXVsdCwgZmFsbGJhY2sgbGF0ZXIgaWYgbmVlZHMgYmVcbiAgICAgKiBET01QYXJzZXIgbm90IHdvcmsgZm9yIHN2ZyB3aGVuIGhhcyBtdWx0aXBsZSByb290IGVsZW1lbnQuXG4gICAgICovXG4gICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoZGlydHlQYXlsb2FkLCBQQVJTRVJfTUVESUFfVFlQRSk7XG4gICAgICB9IGNhdGNoIChfKSB7fVxuICAgIH1cbiAgICAvKiBVc2UgY3JlYXRlSFRNTERvY3VtZW50IGluIGNhc2UgRE9NUGFyc2VyIGlzIG5vdCBhdmFpbGFibGUgKi9cbiAgICBpZiAoIWRvYyB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgZG9jID0gaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoTkFNRVNQQUNFLCAndGVtcGxhdGUnLCBudWxsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvYy5kb2N1bWVudEVsZW1lbnQuaW5uZXJIVE1MID0gSVNfRU1QVFlfSU5QVVQgPyBlbXB0eUhUTUwgOiBkaXJ0eVBheWxvYWQ7XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIC8vIFN5bnRheCBlcnJvciBpZiBkaXJ0eVBheWxvYWQgaXMgaW52YWxpZCB4bWxcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGRvYy5ib2R5IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaWYgKGRpcnR5ICYmIGxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICBib2R5Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsZWFkaW5nV2hpdGVzcGFjZSksIGJvZHkuY2hpbGROb2Rlc1swXSB8fCBudWxsKTtcbiAgICB9XG4gICAgLyogV29yayBvbiB3aG9sZSBkb2N1bWVudCBvciBqdXN0IGl0cyBib2R5ICovXG4gICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIHJldHVybiBnZXRFbGVtZW50c0J5VGFnTmFtZS5jYWxsKGRvYywgV0hPTEVfRE9DVU1FTlQgPyAnaHRtbCcgOiAnYm9keScpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gV0hPTEVfRE9DVU1FTlQgPyBkb2MuZG9jdW1lbnRFbGVtZW50IDogYm9keTtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOb2RlSXRlcmF0b3Igb2JqZWN0IHRoYXQgeW91IGNhbiB1c2UgdG8gdHJhdmVyc2UgZmlsdGVyZWQgbGlzdHMgb2Ygbm9kZXMgb3IgZWxlbWVudHMgaW4gYSBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHJvb3QgVGhlIHJvb3QgZWxlbWVudCBvciBub2RlIHRvIHN0YXJ0IHRyYXZlcnNpbmcgb24uXG4gICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgTm9kZUl0ZXJhdG9yXG4gICAqL1xuICBjb25zdCBfY3JlYXRlTm9kZUl0ZXJhdG9yID0gZnVuY3Rpb24gX2NyZWF0ZU5vZGVJdGVyYXRvcihyb290KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGVJdGVyYXRvci5jYWxsKHJvb3Qub3duZXJEb2N1bWVudCB8fCByb290LCByb290LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfQ09NTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19URVhUIHwgTm9kZUZpbHRlci5TSE9XX1BST0NFU1NJTkdfSU5TVFJVQ1RJT04gfCBOb2RlRmlsdGVyLlNIT1dfQ0RBVEFfU0VDVElPTiwgbnVsbCk7XG4gIH07XG4gIC8qKlxuICAgKiBfaXNDbG9iYmVyZWRcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgZWxlbWVudCB0byBjaGVjayBmb3IgY2xvYmJlcmluZyBhdHRhY2tzXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBjbG9iYmVyZWQsIGZhbHNlIGlmIHNhZmVcbiAgICovXG4gIGNvbnN0IF9pc0Nsb2JiZXJlZCA9IGZ1bmN0aW9uIF9pc0Nsb2JiZXJlZChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQgJiYgKHR5cGVvZiBlbGVtZW50Lm5vZGVOYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudC50ZXh0Q29udGVudCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQucmVtb3ZlQ2hpbGQgIT09ICdmdW5jdGlvbicgfHwgIShlbGVtZW50LmF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBOYW1lZE5vZGVNYXApIHx8IHR5cGVvZiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC5zZXRBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsZW1lbnQubmFtZXNwYWNlVVJJICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudC5pbnNlcnRCZWZvcmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsZW1lbnQuaGFzQ2hpbGROb2RlcyAhPT0gJ2Z1bmN0aW9uJyk7XG4gIH07XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBvYmplY3QgdG8gY2hlY2sgd2hldGhlciBpdCdzIGEgRE9NIG5vZGVcbiAgICogQHJldHVybiB0cnVlIGlzIG9iamVjdCBpcyBhIERPTSBub2RlXG4gICAqL1xuICBjb25zdCBfaXNOb2RlID0gZnVuY3Rpb24gX2lzTm9kZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGU7XG4gIH07XG4gIGZ1bmN0aW9uIF9leGVjdXRlSG9va3MoaG9va3MsIGN1cnJlbnROb2RlLCBkYXRhKSB7XG4gICAgYXJyYXlGb3JFYWNoKGhvb2tzLCBob29rID0+IHtcbiAgICAgIGhvb2suY2FsbChET01QdXJpZnksIGN1cnJlbnROb2RlLCBkYXRhLCBDT05GSUcpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBfc2FuaXRpemVFbGVtZW50c1xuICAgKlxuICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgKiBAcHJvdGVjdCB0ZXh0Q29udGVudFxuICAgKiBAcHJvdGVjdCByZW1vdmVDaGlsZFxuICAgKiBAcGFyYW0gY3VycmVudE5vZGUgdG8gY2hlY2sgZm9yIHBlcm1pc3Npb24gdG8gZXhpc3RcbiAgICogQHJldHVybiB0cnVlIGlmIG5vZGUgd2FzIGtpbGxlZCwgZmFsc2UgaWYgbGVmdCBhbGl2ZVxuICAgKi9cbiAgY29uc3QgX3Nhbml0aXplRWxlbWVudHMgPSBmdW5jdGlvbiBfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkge1xuICAgIGxldCBjb250ZW50ID0gbnVsbDtcbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rcyhob29rcy5iZWZvcmVTYW5pdGl6ZUVsZW1lbnRzLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gICAgLyogQ2hlY2sgaWYgZWxlbWVudCBpcyBjbG9iYmVyZWQgb3IgY2FuIGNsb2JiZXIgKi9cbiAgICBpZiAoX2lzQ2xvYmJlcmVkKGN1cnJlbnROb2RlKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBOb3cgbGV0J3MgY2hlY2sgdGhlIGVsZW1lbnQncyB0eXBlIGFuZCBuYW1lICovXG4gICAgY29uc3QgdGFnTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rcyhob29rcy51cG9uU2FuaXRpemVFbGVtZW50LCBjdXJyZW50Tm9kZSwge1xuICAgICAgdGFnTmFtZSxcbiAgICAgIGFsbG93ZWRUYWdzOiBBTExPV0VEX1RBR1NcbiAgICB9KTtcbiAgICAvKiBEZXRlY3QgbVhTUyBhdHRlbXB0cyBhYnVzaW5nIG5hbWVzcGFjZSBjb25mdXNpb24gKi9cbiAgICBpZiAoU0FGRV9GT1JfWE1MICYmIGN1cnJlbnROb2RlLmhhc0NoaWxkTm9kZXMoKSAmJiAhX2lzTm9kZShjdXJyZW50Tm9kZS5maXJzdEVsZW1lbnRDaGlsZCkgJiYgcmVnRXhwVGVzdCgvPFsvXFx3IV0vZywgY3VycmVudE5vZGUuaW5uZXJIVE1MKSAmJiByZWdFeHBUZXN0KC88Wy9cXHchXS9nLCBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyogUmVtb3ZlIGFueSBvY2N1cnJlbmNlIG9mIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb25zICovXG4gICAgaWYgKGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSBOT0RFX1RZUEUucHJvZ3Jlc3NpbmdJbnN0cnVjdGlvbikge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBSZW1vdmUgYW55IGtpbmQgb2YgcG9zc2libHkgaGFybWZ1bCBjb21tZW50cyAqL1xuICAgIGlmIChTQUZFX0ZPUl9YTUwgJiYgY3VycmVudE5vZGUubm9kZVR5cGUgPT09IE5PREVfVFlQRS5jb21tZW50ICYmIHJlZ0V4cFRlc3QoLzxbL1xcd10vZywgY3VycmVudE5vZGUuZGF0YSkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyogUmVtb3ZlIGVsZW1lbnQgaWYgYW55dGhpbmcgZm9yYmlkcyBpdHMgcHJlc2VuY2UgKi9cbiAgICBpZiAoIUFMTE9XRURfVEFHU1t0YWdOYW1lXSB8fCBGT1JCSURfVEFHU1t0YWdOYW1lXSkge1xuICAgICAgLyogQ2hlY2sgaWYgd2UgaGF2ZSBhIGN1c3RvbSBlbGVtZW50IHRvIGhhbmRsZSAqL1xuICAgICAgaWYgKCFGT1JCSURfVEFHU1t0YWdOYW1lXSAmJiBfaXNCYXNpY0N1c3RvbUVsZW1lbnQodGFnTmFtZSkpIHtcbiAgICAgICAgaWYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiByZWdFeHBUZXN0KENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaywgdGFnTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayh0YWdOYW1lKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogS2VlcCBjb250ZW50IGV4Y2VwdCBmb3IgYmFkLWxpc3RlZCBlbGVtZW50cyAqL1xuICAgICAgaWYgKEtFRVBfQ09OVEVOVCAmJiAhRk9SQklEX0NPTlRFTlRTW3RhZ05hbWVdKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKSB8fCBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gZ2V0Q2hpbGROb2RlcyhjdXJyZW50Tm9kZSkgfHwgY3VycmVudE5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgaWYgKGNoaWxkTm9kZXMgJiYgcGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkQ291bnQgPSBjaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gY2hpbGRDb3VudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZENsb25lID0gY2xvbmVOb2RlKGNoaWxkTm9kZXNbaV0sIHRydWUpO1xuICAgICAgICAgICAgY2hpbGRDbG9uZS5fX3JlbW92YWxDb3VudCA9IChjdXJyZW50Tm9kZS5fX3JlbW92YWxDb3VudCB8fCAwKSArIDE7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZENsb25lLCBnZXROZXh0U2libGluZyhjdXJyZW50Tm9kZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBDaGVjayB3aGV0aGVyIGVsZW1lbnQgaGFzIGEgdmFsaWQgbmFtZXNwYWNlICovXG4gICAgaWYgKGN1cnJlbnROb2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiAhX2NoZWNrVmFsaWROYW1lc3BhY2UoY3VycmVudE5vZGUpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IG9sZGVyIGJyb3dzZXJzIGRvbid0IGdldCBmYWxsYmFjay10YWcgbVhTUyAqL1xuICAgIGlmICgodGFnTmFtZSA9PT0gJ25vc2NyaXB0JyB8fCB0YWdOYW1lID09PSAnbm9lbWJlZCcgfHwgdGFnTmFtZSA9PT0gJ25vZnJhbWVzJykgJiYgcmVnRXhwVGVzdCgvPFxcL25vKHNjcmlwdHxlbWJlZHxmcmFtZXMpL2ksIGN1cnJlbnROb2RlLmlubmVySFRNTCkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyogU2FuaXRpemUgZWxlbWVudCBjb250ZW50IHRvIGJlIHRlbXBsYXRlLXNhZmUgKi9cbiAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTICYmIGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSBOT0RFX1RZUEUudGV4dCkge1xuICAgICAgLyogR2V0IHRoZSBlbGVtZW50J3MgdGV4dCBjb250ZW50ICovXG4gICAgICBjb250ZW50ID0gY3VycmVudE5vZGUudGV4dENvbnRlbnQ7XG4gICAgICBhcnJheUZvckVhY2goW01VU1RBQ0hFX0VYUFIsIEVSQl9FWFBSLCBUTVBMSVRfRVhQUl0sIGV4cHIgPT4ge1xuICAgICAgICBjb250ZW50ID0gc3RyaW5nUmVwbGFjZShjb250ZW50LCBleHByLCAnICcpO1xuICAgICAgfSk7XG4gICAgICBpZiAoY3VycmVudE5vZGUudGV4dENvbnRlbnQgIT09IGNvbnRlbnQpIHtcbiAgICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICAgICAgZWxlbWVudDogY3VycmVudE5vZGUuY2xvbmVOb2RlKClcbiAgICAgICAgfSk7XG4gICAgICAgIGN1cnJlbnROb2RlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9va3MoaG9va3MuYWZ0ZXJTYW5pdGl6ZUVsZW1lbnRzLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICAvKipcbiAgICogX2lzVmFsaWRBdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtIGxjVGFnIExvd2VyY2FzZSB0YWcgbmFtZSBvZiBjb250YWluaW5nIGVsZW1lbnQuXG4gICAqIEBwYXJhbSBsY05hbWUgTG93ZXJjYXNlIGF0dHJpYnV0ZSBuYW1lLlxuICAgKiBAcGFyYW0gdmFsdWUgQXR0cmlidXRlIHZhbHVlLlxuICAgKiBAcmV0dXJuIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLCBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBjb25zdCBfaXNWYWxpZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSB7XG4gICAgLyogTWFrZSBzdXJlIGF0dHJpYnV0ZSBjYW5ub3QgY2xvYmJlciAqL1xuICAgIGlmIChTQU5JVElaRV9ET00gJiYgKGxjTmFtZSA9PT0gJ2lkJyB8fCBsY05hbWUgPT09ICduYW1lJykgJiYgKHZhbHVlIGluIGRvY3VtZW50IHx8IHZhbHVlIGluIGZvcm1FbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKiBBbGxvdyB2YWxpZCBkYXRhLSogYXR0cmlidXRlczogQXQgbGVhc3Qgb25lIGNoYXJhY3RlciBhZnRlciBcIi1cIlxuICAgICAgICAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjZW1iZWRkaW5nLWN1c3RvbS1ub24tdmlzaWJsZS1kYXRhLXdpdGgtdGhlLWRhdGEtKi1hdHRyaWJ1dGVzKVxuICAgICAgICBYTUwtY29tcGF0aWJsZSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCN4bWwtY29tcGF0aWJsZSBhbmQgaHR0cDovL3d3dy53My5vcmcvVFIveG1sLyNkMGU4MDQpXG4gICAgICAgIFdlIGRvbid0IG5lZWQgdG8gY2hlY2sgdGhlIHZhbHVlOyBpdCdzIGFsd2F5cyBVUkkgc2FmZS4gKi9cbiAgICBpZiAoQUxMT1dfREFUQV9BVFRSICYmICFGT1JCSURfQVRUUltsY05hbWVdICYmIHJlZ0V4cFRlc3QoREFUQV9BVFRSLCBsY05hbWUpKSA7IGVsc2UgaWYgKEFMTE9XX0FSSUFfQVRUUiAmJiByZWdFeHBUZXN0KEFSSUFfQVRUUiwgbGNOYW1lKSkgOyBlbHNlIGlmICghQUxMT1dFRF9BVFRSW2xjTmFtZV0gfHwgRk9SQklEX0FUVFJbbGNOYW1lXSkge1xuICAgICAgaWYgKFxuICAgICAgLy8gRmlyc3QgY29uZGl0aW9uIGRvZXMgYSB2ZXJ5IGJhc2ljIGNoZWNrIGlmIGEpIGl0J3MgYmFzaWNhbGx5IGEgdmFsaWQgY3VzdG9tIGVsZW1lbnQgdGFnbmFtZSBBTkRcbiAgICAgIC8vIGIpIGlmIHRoZSB0YWdOYW1lIHBhc3NlcyB3aGF0ZXZlciB0aGUgdXNlciBoYXMgY29uZmlndXJlZCBmb3IgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrXG4gICAgICAvLyBhbmQgYykgaWYgdGhlIGF0dHJpYnV0ZSBuYW1lIHBhc3NlcyB3aGF0ZXZlciB0aGUgdXNlciBoYXMgY29uZmlndXJlZCBmb3IgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrXG4gICAgICBfaXNCYXNpY0N1c3RvbUVsZW1lbnQobGNUYWcpICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIGxjVGFnKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sobGNUYWcpKSAmJiAoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrIGluc3RhbmNlb2YgUmVnRXhwICYmIHJlZ0V4cFRlc3QoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlTmFtZUNoZWNrLCBsY05hbWUpIHx8IENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayhsY05hbWUpKSB8fFxuICAgICAgLy8gQWx0ZXJuYXRpdmUsIHNlY29uZCBjb25kaXRpb24gY2hlY2tzIGlmIGl0J3MgYW4gYGlzYC1hdHRyaWJ1dGUsIEFORFxuICAgICAgLy8gdGhlIHZhbHVlIHBhc3NlcyB3aGF0ZXZlciB0aGUgdXNlciBoYXMgY29uZmlndXJlZCBmb3IgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrXG4gICAgICBsY05hbWUgPT09ICdpcycgJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzICYmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIHZhbHVlKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sodmFsdWUpKSkgOyBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLyogQ2hlY2sgdmFsdWUgaXMgc2FmZS4gRmlyc3QsIGlzIGF0dHIgaW5lcnQ/IElmIHNvLCBpcyBzYWZlICovXG4gICAgfSBlbHNlIGlmIChVUklfU0FGRV9BVFRSSUJVVEVTW2xjTmFtZV0pIDsgZWxzZSBpZiAocmVnRXhwVGVzdChJU19BTExPV0VEX1VSSSQxLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UsICcnKSkpIDsgZWxzZSBpZiAoKGxjTmFtZSA9PT0gJ3NyYycgfHwgbGNOYW1lID09PSAneGxpbms6aHJlZicgfHwgbGNOYW1lID09PSAnaHJlZicpICYmIGxjVGFnICE9PSAnc2NyaXB0JyAmJiBzdHJpbmdJbmRleE9mKHZhbHVlLCAnZGF0YTonKSA9PT0gMCAmJiBEQVRBX1VSSV9UQUdTW2xjVGFnXSkgOyBlbHNlIGlmIChBTExPV19VTktOT1dOX1BST1RPQ09MUyAmJiAhcmVnRXhwVGVzdChJU19TQ1JJUFRfT1JfREFUQSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFLCAnJykpKSA7IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIF9pc0Jhc2ljQ3VzdG9tRWxlbWVudFxuICAgKiBjaGVja3MgaWYgYXQgbGVhc3Qgb25lIGRhc2ggaXMgaW5jbHVkZWQgaW4gdGFnTmFtZSwgYW5kIGl0J3Mgbm90IHRoZSBmaXJzdCBjaGFyXG4gICAqIGZvciBtb3JlIHNvcGhpc3RpY2F0ZWQgY2hlY2tpbmcgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvdmFsaWRhdGUtZWxlbWVudC1uYW1lXG4gICAqXG4gICAqIEBwYXJhbSB0YWdOYW1lIG5hbWUgb2YgdGhlIHRhZyBvZiB0aGUgbm9kZSB0byBzYW5pdGl6ZVxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgdGhlIHRhZyBuYW1lIG1lZXRzIHRoZSBiYXNpYyBjcml0ZXJpYSBmb3IgYSBjdXN0b20gZWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgY29uc3QgX2lzQmFzaWNDdXN0b21FbGVtZW50ID0gZnVuY3Rpb24gX2lzQmFzaWNDdXN0b21FbGVtZW50KHRhZ05hbWUpIHtcbiAgICByZXR1cm4gdGFnTmFtZSAhPT0gJ2Fubm90YXRpb24teG1sJyAmJiBzdHJpbmdNYXRjaCh0YWdOYW1lLCBDVVNUT01fRUxFTUVOVCk7XG4gIH07XG4gIC8qKlxuICAgKiBfc2FuaXRpemVBdHRyaWJ1dGVzXG4gICAqXG4gICAqIEBwcm90ZWN0IGF0dHJpYnV0ZXNcbiAgICogQHByb3RlY3Qgbm9kZU5hbWVcbiAgICogQHByb3RlY3QgcmVtb3ZlQXR0cmlidXRlXG4gICAqIEBwcm90ZWN0IHNldEF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0gY3VycmVudE5vZGUgdG8gc2FuaXRpemVcbiAgICovXG4gIGNvbnN0IF9zYW5pdGl6ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBfc2FuaXRpemVBdHRyaWJ1dGVzKGN1cnJlbnROb2RlKSB7XG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9va3MoaG9va3MuYmVmb3JlU2FuaXRpemVBdHRyaWJ1dGVzLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gICAgY29uc3Qge1xuICAgICAgYXR0cmlidXRlc1xuICAgIH0gPSBjdXJyZW50Tm9kZTtcbiAgICAvKiBDaGVjayBpZiB3ZSBoYXZlIGF0dHJpYnV0ZXM7IGlmIG5vdCB3ZSBtaWdodCBoYXZlIGEgdGV4dCBub2RlICovXG4gICAgaWYgKCFhdHRyaWJ1dGVzIHx8IF9pc0Nsb2JiZXJlZChjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaG9va0V2ZW50ID0ge1xuICAgICAgYXR0ck5hbWU6ICcnLFxuICAgICAgYXR0clZhbHVlOiAnJyxcbiAgICAgIGtlZXBBdHRyOiB0cnVlLFxuICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IEFMTE9XRURfQVRUUixcbiAgICAgIGZvcmNlS2VlcEF0dHI6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgbGV0IGwgPSBhdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAvKiBHbyBiYWNrd2FyZHMgb3ZlciBhbGwgYXR0cmlidXRlczsgc2FmZWx5IHJlbW92ZSBiYWQgb25lcyAqL1xuICAgIHdoaWxlIChsLS0pIHtcbiAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2xdO1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBuYW1lc3BhY2VVUkksXG4gICAgICAgIHZhbHVlOiBhdHRyVmFsdWVcbiAgICAgIH0gPSBhdHRyO1xuICAgICAgY29uc3QgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMobmFtZSk7XG4gICAgICBjb25zdCBpbml0VmFsdWUgPSBhdHRyVmFsdWU7XG4gICAgICBsZXQgdmFsdWUgPSBuYW1lID09PSAndmFsdWUnID8gaW5pdFZhbHVlIDogc3RyaW5nVHJpbShpbml0VmFsdWUpO1xuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgaG9va0V2ZW50LmF0dHJOYW1lID0gbGNOYW1lO1xuICAgICAgaG9va0V2ZW50LmF0dHJWYWx1ZSA9IHZhbHVlO1xuICAgICAgaG9va0V2ZW50LmtlZXBBdHRyID0gdHJ1ZTtcbiAgICAgIGhvb2tFdmVudC5mb3JjZUtlZXBBdHRyID0gdW5kZWZpbmVkOyAvLyBBbGxvd3MgZGV2ZWxvcGVycyB0byBzZWUgdGhpcyBpcyBhIHByb3BlcnR5IHRoZXkgY2FuIHNldFxuICAgICAgX2V4ZWN1dGVIb29rcyhob29rcy51cG9uU2FuaXRpemVBdHRyaWJ1dGUsIGN1cnJlbnROb2RlLCBob29rRXZlbnQpO1xuICAgICAgdmFsdWUgPSBob29rRXZlbnQuYXR0clZhbHVlO1xuICAgICAgLyogRnVsbCBET00gQ2xvYmJlcmluZyBwcm90ZWN0aW9uIHZpYSBuYW1lc3BhY2UgaXNvbGF0aW9uLFxuICAgICAgICogUHJlZml4IGlkIGFuZCBuYW1lIGF0dHJpYnV0ZXMgd2l0aCBgdXNlci1jb250ZW50LWBcbiAgICAgICAqL1xuICAgICAgaWYgKFNBTklUSVpFX05BTUVEX1BST1BTICYmIChsY05hbWUgPT09ICdpZCcgfHwgbGNOYW1lID09PSAnbmFtZScpKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgYXR0cmlidXRlIHdpdGggdGhpcyB2YWx1ZVxuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgLy8gUHJlZml4IHRoZSB2YWx1ZSBhbmQgbGF0ZXIgcmUtY3JlYXRlIHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgc2FuaXRpemVkIHZhbHVlXG4gICAgICAgIHZhbHVlID0gU0FOSVRJWkVfTkFNRURfUFJPUFNfUFJFRklYICsgdmFsdWU7XG4gICAgICB9XG4gICAgICAvKiBXb3JrIGFyb3VuZCBhIHNlY3VyaXR5IGlzc3VlIHdpdGggY29tbWVudHMgaW5zaWRlIGF0dHJpYnV0ZXMgKi9cbiAgICAgIGlmIChTQUZFX0ZPUl9YTUwgJiYgcmVnRXhwVGVzdCgvKCgtLSE/fF0pPil8PFxcLyhzdHlsZXx0aXRsZSkvaSwgdmFsdWUpKSB7XG4gICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8qIERpZCB0aGUgaG9va3MgYXBwcm92ZSBvZiB0aGUgYXR0cmlidXRlPyAqL1xuICAgICAgaWYgKGhvb2tFdmVudC5mb3JjZUtlZXBBdHRyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogRGlkIHRoZSBob29rcyBhcHByb3ZlIG9mIHRoZSBhdHRyaWJ1dGU/ICovXG4gICAgICBpZiAoIWhvb2tFdmVudC5rZWVwQXR0cikge1xuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvKiBXb3JrIGFyb3VuZCBhIHNlY3VyaXR5IGlzc3VlIGluIGpRdWVyeSAzLjAgKi9cbiAgICAgIGlmICghQUxMT1dfU0VMRl9DTE9TRV9JTl9BVFRSICYmIHJlZ0V4cFRlc3QoL1xcLz4vaSwgdmFsdWUpKSB7XG4gICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8qIFNhbml0aXplIGF0dHJpYnV0ZSBjb250ZW50IHRvIGJlIHRlbXBsYXRlLXNhZmUgKi9cbiAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgICAgYXJyYXlGb3JFYWNoKFtNVVNUQUNIRV9FWFBSLCBFUkJfRVhQUiwgVE1QTElUX0VYUFJdLCBleHByID0+IHtcbiAgICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIGV4cHIsICcgJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyogSXMgYHZhbHVlYCB2YWxpZCBmb3IgdGhpcyBhdHRyaWJ1dGU/ICovXG4gICAgICBjb25zdCBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcbiAgICAgIGlmICghX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpKSB7XG4gICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8qIEhhbmRsZSBhdHRyaWJ1dGVzIHRoYXQgcmVxdWlyZSBUcnVzdGVkIFR5cGVzICovXG4gICAgICBpZiAodHJ1c3RlZFR5cGVzUG9saWN5ICYmIHR5cGVvZiB0cnVzdGVkVHlwZXMgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0cnVzdGVkVHlwZXMuZ2V0QXR0cmlidXRlVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAobmFtZXNwYWNlVVJJKSA7IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAodHJ1c3RlZFR5cGVzLmdldEF0dHJpYnV0ZVR5cGUobGNUYWcsIGxjTmFtZSkpIHtcbiAgICAgICAgICAgIGNhc2UgJ1RydXN0ZWRIVE1MJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdUcnVzdGVkU2NyaXB0VVJMJzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZVNjcmlwdFVSTCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIEhhbmRsZSBpbnZhbGlkIGRhdGEtKiBhdHRyaWJ1dGUgc2V0IGJ5IHRyeS1jYXRjaGluZyBpdCAqL1xuICAgICAgaWYgKHZhbHVlICE9PSBpbml0VmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAobmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogRmFsbGJhY2sgdG8gc2V0QXR0cmlidXRlKCkgZm9yIGJyb3dzZXItdW5yZWNvZ25pemVkIG5hbWVzcGFjZXMgZS5nLiBcIngtc2NoZW1hXCIuICovXG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX2lzQ2xvYmJlcmVkKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlQb3AoRE9NUHVyaWZ5LnJlbW92ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLmFmdGVyU2FuaXRpemVBdHRyaWJ1dGVzLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gIH07XG4gIC8qKlxuICAgKiBfc2FuaXRpemVTaGFkb3dET01cbiAgICpcbiAgICogQHBhcmFtIGZyYWdtZW50IHRvIGl0ZXJhdGUgb3ZlciByZWN1cnNpdmVseVxuICAgKi9cbiAgY29uc3QgX3Nhbml0aXplU2hhZG93RE9NID0gZnVuY3Rpb24gX3Nhbml0aXplU2hhZG93RE9NKGZyYWdtZW50KSB7XG4gICAgbGV0IHNoYWRvd05vZGUgPSBudWxsO1xuICAgIGNvbnN0IHNoYWRvd0l0ZXJhdG9yID0gX2NyZWF0ZU5vZGVJdGVyYXRvcihmcmFnbWVudCk7XG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9va3MoaG9va3MuYmVmb3JlU2FuaXRpemVTaGFkb3dET00sIGZyYWdtZW50LCBudWxsKTtcbiAgICB3aGlsZSAoc2hhZG93Tm9kZSA9IHNoYWRvd0l0ZXJhdG9yLm5leHROb2RlKCkpIHtcbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgIF9leGVjdXRlSG9va3MoaG9va3MudXBvblNhbml0aXplU2hhZG93Tm9kZSwgc2hhZG93Tm9kZSwgbnVsbCk7XG4gICAgICAvKiBTYW5pdGl6ZSB0YWdzIGFuZCBlbGVtZW50cyAqL1xuICAgICAgX3Nhbml0aXplRWxlbWVudHMoc2hhZG93Tm9kZSk7XG4gICAgICAvKiBDaGVjayBhdHRyaWJ1dGVzIG5leHQgKi9cbiAgICAgIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoc2hhZG93Tm9kZSk7XG4gICAgICAvKiBEZWVwIHNoYWRvdyBET00gZGV0ZWN0ZWQgKi9cbiAgICAgIGlmIChzaGFkb3dOb2RlLmNvbnRlbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIF9zYW5pdGl6ZVNoYWRvd0RPTShzaGFkb3dOb2RlLmNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rcyhob29rcy5hZnRlclNhbml0aXplU2hhZG93RE9NLCBmcmFnbWVudCwgbnVsbCk7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIERPTVB1cmlmeS5zYW5pdGl6ZSA9IGZ1bmN0aW9uIChkaXJ0eSkge1xuICAgIGxldCBjZmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGxldCBib2R5ID0gbnVsbDtcbiAgICBsZXQgaW1wb3J0ZWROb2RlID0gbnVsbDtcbiAgICBsZXQgY3VycmVudE5vZGUgPSBudWxsO1xuICAgIGxldCByZXR1cm5Ob2RlID0gbnVsbDtcbiAgICAvKiBNYWtlIHN1cmUgd2UgaGF2ZSBhIHN0cmluZyB0byBzYW5pdGl6ZS5cbiAgICAgIERPIE5PVCByZXR1cm4gZWFybHksIGFzIHRoaXMgd2lsbCByZXR1cm4gdGhlIHdyb25nIHR5cGUgaWZcbiAgICAgIHRoZSB1c2VyIGhhcyByZXF1ZXN0ZWQgYSBET00gb2JqZWN0IHJhdGhlciB0aGFuIGEgc3RyaW5nICovXG4gICAgSVNfRU1QVFlfSU5QVVQgPSAhZGlydHk7XG4gICAgaWYgKElTX0VNUFRZX0lOUFVUKSB7XG4gICAgICBkaXJ0eSA9ICc8IS0tPic7XG4gICAgfVxuICAgIC8qIFN0cmluZ2lmeSwgaW4gY2FzZSBkaXJ0eSBpcyBhbiBvYmplY3QgKi9cbiAgICBpZiAodHlwZW9mIGRpcnR5ICE9PSAnc3RyaW5nJyAmJiAhX2lzTm9kZShkaXJ0eSkpIHtcbiAgICAgIGlmICh0eXBlb2YgZGlydHkudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlydHkgPSBkaXJ0eS50b1N0cmluZygpO1xuICAgICAgICBpZiAodHlwZW9mIGRpcnR5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgnZGlydHkgaXMgbm90IGEgc3RyaW5nLCBhYm9ydGluZycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ3RvU3RyaW5nIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIFJldHVybiBkaXJ0eSBIVE1MIGlmIERPTVB1cmlmeSBjYW5ub3QgcnVuICovXG4gICAgaWYgKCFET01QdXJpZnkuaXNTdXBwb3J0ZWQpIHtcbiAgICAgIHJldHVybiBkaXJ0eTtcbiAgICB9XG4gICAgLyogQXNzaWduIGNvbmZpZyB2YXJzICovXG4gICAgaWYgKCFTRVRfQ09ORklHKSB7XG4gICAgICBfcGFyc2VDb25maWcoY2ZnKTtcbiAgICB9XG4gICAgLyogQ2xlYW4gdXAgcmVtb3ZlZCBlbGVtZW50cyAqL1xuICAgIERPTVB1cmlmeS5yZW1vdmVkID0gW107XG4gICAgLyogQ2hlY2sgaWYgZGlydHkgaXMgY29ycmVjdGx5IHR5cGVkIGZvciBJTl9QTEFDRSAqL1xuICAgIGlmICh0eXBlb2YgZGlydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBJTl9QTEFDRSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoSU5fUExBQ0UpIHtcbiAgICAgIC8qIERvIHNvbWUgZWFybHkgcHJlLXNhbml0aXphdGlvbiB0byBhdm9pZCB1bnNhZmUgcm9vdCBub2RlcyAqL1xuICAgICAgaWYgKGRpcnR5Lm5vZGVOYW1lKSB7XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhkaXJ0eS5ub2RlTmFtZSk7XG4gICAgICAgIGlmICghQUxMT1dFRF9UQUdTW3RhZ05hbWVdIHx8IEZPUkJJRF9UQUdTW3RhZ05hbWVdKSB7XG4gICAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCdyb290IG5vZGUgaXMgZm9yYmlkZGVuIGFuZCBjYW5ub3QgYmUgc2FuaXRpemVkIGluLXBsYWNlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRpcnR5IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgLyogSWYgZGlydHkgaXMgYSBET00gZWxlbWVudCwgYXBwZW5kIHRvIGFuIGVtcHR5IGRvY3VtZW50IHRvIGF2b2lkXG4gICAgICAgICBlbGVtZW50cyBiZWluZyBzdHJpcHBlZCBieSB0aGUgcGFyc2VyICovXG4gICAgICBib2R5ID0gX2luaXREb2N1bWVudCgnPCEtLS0tPicpO1xuICAgICAgaW1wb3J0ZWROb2RlID0gYm9keS5vd25lckRvY3VtZW50LmltcG9ydE5vZGUoZGlydHksIHRydWUpO1xuICAgICAgaWYgKGltcG9ydGVkTm9kZS5ub2RlVHlwZSA9PT0gTk9ERV9UWVBFLmVsZW1lbnQgJiYgaW1wb3J0ZWROb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgLyogTm9kZSBpcyBhbHJlYWR5IGEgYm9keSwgdXNlIGFzIGlzICovXG4gICAgICAgIGJvZHkgPSBpbXBvcnRlZE5vZGU7XG4gICAgICB9IGVsc2UgaWYgKGltcG9ydGVkTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICAgIGJvZHkgPSBpbXBvcnRlZE5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItZG9tLW5vZGUtYXBwZW5kXG4gICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoaW1wb3J0ZWROb2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogRXhpdCBkaXJlY3RseSBpZiB3ZSBoYXZlIG5vdGhpbmcgdG8gZG8gKi9cbiAgICAgIGlmICghUkVUVVJOX0RPTSAmJiAhU0FGRV9GT1JfVEVNUExBVEVTICYmICFXSE9MRV9ET0NVTUVOVCAmJlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWluY2x1ZGVzXG4gICAgICBkaXJ0eS5pbmRleE9mKCc8JykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKGRpcnR5KSA6IGRpcnR5O1xuICAgICAgfVxuICAgICAgLyogSW5pdGlhbGl6ZSB0aGUgZG9jdW1lbnQgdG8gd29yayBvbiAqL1xuICAgICAgYm9keSA9IF9pbml0RG9jdW1lbnQoZGlydHkpO1xuICAgICAgLyogQ2hlY2sgd2UgaGF2ZSBhIERPTSBub2RlIGZyb20gdGhlIGRhdGEgKi9cbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICByZXR1cm4gUkVUVVJOX0RPTSA/IG51bGwgOiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gZW1wdHlIVE1MIDogJyc7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIFJlbW92ZSBmaXJzdCBlbGVtZW50IG5vZGUgKG91cnMpIGlmIEZPUkNFX0JPRFkgaXMgc2V0ICovXG4gICAgaWYgKGJvZHkgJiYgRk9SQ0VfQk9EWSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIC8qIEdldCBub2RlIGl0ZXJhdG9yICovXG4gICAgY29uc3Qgbm9kZUl0ZXJhdG9yID0gX2NyZWF0ZU5vZGVJdGVyYXRvcihJTl9QTEFDRSA/IGRpcnR5IDogYm9keSk7XG4gICAgLyogTm93IHN0YXJ0IGl0ZXJhdGluZyBvdmVyIHRoZSBjcmVhdGVkIGRvY3VtZW50ICovXG4gICAgd2hpbGUgKGN1cnJlbnROb2RlID0gbm9kZUl0ZXJhdG9yLm5leHROb2RlKCkpIHtcbiAgICAgIC8qIFNhbml0aXplIHRhZ3MgYW5kIGVsZW1lbnRzICovXG4gICAgICBfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSk7XG4gICAgICAvKiBDaGVjayBhdHRyaWJ1dGVzIG5leHQgKi9cbiAgICAgIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoY3VycmVudE5vZGUpO1xuICAgICAgLyogU2hhZG93IERPTSBkZXRlY3RlZCwgc2FuaXRpemUgaXQgKi9cbiAgICAgIGlmIChjdXJyZW50Tm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICBfc2FuaXRpemVTaGFkb3dET00oY3VycmVudE5vZGUuY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHdlIHNhbml0aXplZCBgZGlydHlgIGluLXBsYWNlLCByZXR1cm4gaXQuICovXG4gICAgaWYgKElOX1BMQUNFKSB7XG4gICAgICByZXR1cm4gZGlydHk7XG4gICAgfVxuICAgIC8qIFJldHVybiBzYW5pdGl6ZWQgc3RyaW5nIG9yIERPTSAqL1xuICAgIGlmIChSRVRVUk5fRE9NKSB7XG4gICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICByZXR1cm5Ob2RlID0gY3JlYXRlRG9jdW1lbnRGcmFnbWVudC5jYWxsKGJvZHkub3duZXJEb2N1bWVudCk7XG4gICAgICAgIHdoaWxlIChib2R5LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItZG9tLW5vZGUtYXBwZW5kXG4gICAgICAgICAgcmV0dXJuTm9kZS5hcHBlbmRDaGlsZChib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm5Ob2RlID0gYm9keTtcbiAgICAgIH1cbiAgICAgIGlmIChBTExPV0VEX0FUVFIuc2hhZG93cm9vdCB8fCBBTExPV0VEX0FUVFIuc2hhZG93cm9vdG1vZGUpIHtcbiAgICAgICAgLypcbiAgICAgICAgICBBZG9wdE5vZGUoKSBpcyBub3QgdXNlZCBiZWNhdXNlIGludGVybmFsIHN0YXRlIGlzIG5vdCByZXNldFxuICAgICAgICAgIChlLmcuIHRoZSBwYXN0IG5hbWVzIG1hcCBvZiBhIEhUTUxGb3JtRWxlbWVudCksIHRoaXMgaXMgc2FmZVxuICAgICAgICAgIGluIHRoZW9yeSBidXQgd2Ugd291bGQgcmF0aGVyIG5vdCByaXNrIGFub3RoZXIgYXR0YWNrIHZlY3Rvci5cbiAgICAgICAgICBUaGUgc3RhdGUgdGhhdCBpcyBjbG9uZWQgYnkgaW1wb3J0Tm9kZSgpIGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuICAgICAgICAgIGJ5IHRoZSBzcGVjcy5cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuTm9kZSA9IGltcG9ydE5vZGUuY2FsbChvcmlnaW5hbERvY3VtZW50LCByZXR1cm5Ob2RlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5Ob2RlO1xuICAgIH1cbiAgICBsZXQgc2VyaWFsaXplZEhUTUwgPSBXSE9MRV9ET0NVTUVOVCA/IGJvZHkub3V0ZXJIVE1MIDogYm9keS5pbm5lckhUTUw7XG4gICAgLyogU2VyaWFsaXplIGRvY3R5cGUgaWYgYWxsb3dlZCAqL1xuICAgIGlmIChXSE9MRV9ET0NVTUVOVCAmJiBBTExPV0VEX1RBR1NbJyFkb2N0eXBlJ10gJiYgYm9keS5vd25lckRvY3VtZW50ICYmIGJvZHkub3duZXJEb2N1bWVudC5kb2N0eXBlICYmIGJvZHkub3duZXJEb2N1bWVudC5kb2N0eXBlLm5hbWUgJiYgcmVnRXhwVGVzdChET0NUWVBFX05BTUUsIGJvZHkub3duZXJEb2N1bWVudC5kb2N0eXBlLm5hbWUpKSB7XG4gICAgICBzZXJpYWxpemVkSFRNTCA9ICc8IURPQ1RZUEUgJyArIGJvZHkub3duZXJEb2N1bWVudC5kb2N0eXBlLm5hbWUgKyAnPlxcbicgKyBzZXJpYWxpemVkSFRNTDtcbiAgICB9XG4gICAgLyogU2FuaXRpemUgZmluYWwgc3RyaW5nIHRlbXBsYXRlLXNhZmUgKi9cbiAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICBhcnJheUZvckVhY2goW01VU1RBQ0hFX0VYUFIsIEVSQl9FWFBSLCBUTVBMSVRfRVhQUl0sIGV4cHIgPT4ge1xuICAgICAgICBzZXJpYWxpemVkSFRNTCA9IHN0cmluZ1JlcGxhY2Uoc2VyaWFsaXplZEhUTUwsIGV4cHIsICcgJyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoc2VyaWFsaXplZEhUTUwpIDogc2VyaWFsaXplZEhUTUw7XG4gIH07XG4gIERPTVB1cmlmeS5zZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGNmZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgX3BhcnNlQ29uZmlnKGNmZyk7XG4gICAgU0VUX0NPTkZJRyA9IHRydWU7XG4gIH07XG4gIERPTVB1cmlmeS5jbGVhckNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBDT05GSUcgPSBudWxsO1xuICAgIFNFVF9DT05GSUcgPSBmYWxzZTtcbiAgfTtcbiAgRE9NUHVyaWZ5LmlzVmFsaWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodGFnLCBhdHRyLCB2YWx1ZSkge1xuICAgIC8qIEluaXRpYWxpemUgc2hhcmVkIGNvbmZpZyB2YXJzIGlmIG5lY2Vzc2FyeS4gKi9cbiAgICBpZiAoIUNPTkZJRykge1xuICAgICAgX3BhcnNlQ29uZmlnKHt9KTtcbiAgICB9XG4gICAgY29uc3QgbGNUYWcgPSB0cmFuc2Zvcm1DYXNlRnVuYyh0YWcpO1xuICAgIGNvbnN0IGxjTmFtZSA9IHRyYW5zZm9ybUNhc2VGdW5jKGF0dHIpO1xuICAgIHJldHVybiBfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSk7XG4gIH07XG4gIERPTVB1cmlmeS5hZGRIb29rID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQsIGhvb2tGdW5jdGlvbikge1xuICAgIGlmICh0eXBlb2YgaG9va0Z1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFycmF5UHVzaChob29rc1tlbnRyeVBvaW50XSwgaG9va0Z1bmN0aW9uKTtcbiAgfTtcbiAgRE9NUHVyaWZ5LnJlbW92ZUhvb2sgPSBmdW5jdGlvbiAoZW50cnlQb2ludCwgaG9va0Z1bmN0aW9uKSB7XG4gICAgaWYgKGhvb2tGdW5jdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGFycmF5TGFzdEluZGV4T2YoaG9va3NbZW50cnlQb2ludF0sIGhvb2tGdW5jdGlvbik7XG4gICAgICByZXR1cm4gaW5kZXggPT09IC0xID8gdW5kZWZpbmVkIDogYXJyYXlTcGxpY2UoaG9va3NbZW50cnlQb2ludF0sIGluZGV4LCAxKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5UG9wKGhvb2tzW2VudHJ5UG9pbnRdKTtcbiAgfTtcbiAgRE9NUHVyaWZ5LnJlbW92ZUhvb2tzID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQpIHtcbiAgICBob29rc1tlbnRyeVBvaW50XSA9IFtdO1xuICB9O1xuICBET01QdXJpZnkucmVtb3ZlQWxsSG9va3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgaG9va3MgPSBfY3JlYXRlSG9va3NNYXAoKTtcbiAgfTtcbiAgcmV0dXJuIERPTVB1cmlmeTtcbn1cbnZhciBwdXJpZnkgPSBjcmVhdGVET01QdXJpZnkoKTtcblxuZXhwb3J0IHsgcHVyaWZ5IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1cmlmeS5lcy5tanMubWFwXG4iXSwibmFtZXMiOlsiZW50cmllcyIsInNldFByb3RvdHlwZU9mIiwiaXNGcm96ZW4iLCJnZXRQcm90b3R5cGVPZiIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIk9iamVjdCIsImZyZWV6ZSIsInNlYWwiLCJjcmVhdGUiLCJhcHBseSIsImNvbnN0cnVjdCIsIlJlZmxlY3QiLCJ4IiwiZnVuIiwidGhpc1ZhbHVlIiwiYXJncyIsIkZ1bmMiLCJhcnJheUZvckVhY2giLCJ1bmFwcGx5IiwiQXJyYXkiLCJwcm90b3R5cGUiLCJmb3JFYWNoIiwiYXJyYXlMYXN0SW5kZXhPZiIsImxhc3RJbmRleE9mIiwiYXJyYXlQb3AiLCJwb3AiLCJhcnJheVB1c2giLCJwdXNoIiwiYXJyYXlTcGxpY2UiLCJzcGxpY2UiLCJzdHJpbmdUb0xvd2VyQ2FzZSIsIlN0cmluZyIsInRvTG93ZXJDYXNlIiwic3RyaW5nVG9TdHJpbmciLCJ0b1N0cmluZyIsInN0cmluZ01hdGNoIiwibWF0Y2giLCJzdHJpbmdSZXBsYWNlIiwicmVwbGFjZSIsInN0cmluZ0luZGV4T2YiLCJpbmRleE9mIiwic3RyaW5nVHJpbSIsInRyaW0iLCJvYmplY3RIYXNPd25Qcm9wZXJ0eSIsImhhc093blByb3BlcnR5IiwicmVnRXhwVGVzdCIsIlJlZ0V4cCIsInRlc3QiLCJ0eXBlRXJyb3JDcmVhdGUiLCJ1bmNvbnN0cnVjdCIsIlR5cGVFcnJvciIsImZ1bmMiLCJ0aGlzQXJnIiwibGFzdEluZGV4IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsIl9rZXkiLCJfbGVuMiIsIl9rZXkyIiwiYWRkVG9TZXQiLCJzZXQiLCJhcnJheSIsInRyYW5zZm9ybUNhc2VGdW5jIiwidW5kZWZpbmVkIiwibCIsImVsZW1lbnQiLCJsY0VsZW1lbnQiLCJjbGVhbkFycmF5IiwiaW5kZXgiLCJpc1Byb3BlcnR5RXhpc3QiLCJjbG9uZSIsIm9iamVjdCIsIm5ld09iamVjdCIsInByb3BlcnR5IiwidmFsdWUiLCJpc0FycmF5IiwiY29uc3RydWN0b3IiLCJsb29rdXBHZXR0ZXIiLCJwcm9wIiwiZGVzYyIsImdldCIsImZhbGxiYWNrVmFsdWUiLCJodG1sJDEiLCJzdmckMSIsInN2Z0ZpbHRlcnMiLCJzdmdEaXNhbGxvd2VkIiwibWF0aE1sJDEiLCJtYXRoTWxEaXNhbGxvd2VkIiwidGV4dCIsImh0bWwiLCJzdmciLCJtYXRoTWwiLCJ4bWwiLCJNVVNUQUNIRV9FWFBSIiwiRVJCX0VYUFIiLCJUTVBMSVRfRVhQUiIsIkRBVEFfQVRUUiIsIkFSSUFfQVRUUiIsIklTX0FMTE9XRURfVVJJIiwiSVNfU0NSSVBUX09SX0RBVEEiLCJBVFRSX1dISVRFU1BBQ0UiLCJET0NUWVBFX05BTUUiLCJDVVNUT01fRUxFTUVOVCIsIkVYUFJFU1NJT05TIiwiX19wcm90b19fIiwiTk9ERV9UWVBFIiwiYXR0cmlidXRlIiwiY2RhdGFTZWN0aW9uIiwiZW50aXR5UmVmZXJlbmNlIiwiZW50aXR5Tm9kZSIsInByb2dyZXNzaW5nSW5zdHJ1Y3Rpb24iLCJjb21tZW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudFR5cGUiLCJkb2N1bWVudEZyYWdtZW50Iiwibm90YXRpb24iLCJnZXRHbG9iYWwiLCJ3aW5kb3ciLCJfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5IiwidHJ1c3RlZFR5cGVzIiwicHVyaWZ5SG9zdEVsZW1lbnQiLCJjcmVhdGVQb2xpY3kiLCJzdWZmaXgiLCJBVFRSX05BTUUiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJwb2xpY3lOYW1lIiwiY3JlYXRlSFRNTCIsImNyZWF0ZVNjcmlwdFVSTCIsInNjcmlwdFVybCIsIl8iLCJjb25zb2xlIiwid2FybiIsIl9jcmVhdGVIb29rc01hcCIsImFmdGVyU2FuaXRpemVBdHRyaWJ1dGVzIiwiYWZ0ZXJTYW5pdGl6ZUVsZW1lbnRzIiwiYWZ0ZXJTYW5pdGl6ZVNoYWRvd0RPTSIsImJlZm9yZVNhbml0aXplQXR0cmlidXRlcyIsImJlZm9yZVNhbml0aXplRWxlbWVudHMiLCJiZWZvcmVTYW5pdGl6ZVNoYWRvd0RPTSIsInVwb25TYW5pdGl6ZUF0dHJpYnV0ZSIsInVwb25TYW5pdGl6ZUVsZW1lbnQiLCJ1cG9uU2FuaXRpemVTaGFkb3dOb2RlIiwiY3JlYXRlRE9NUHVyaWZ5IiwiRE9NUHVyaWZ5Iiwicm9vdCIsInZlcnNpb24iLCJyZW1vdmVkIiwibm9kZVR5cGUiLCJFbGVtZW50IiwiaXNTdXBwb3J0ZWQiLCJvcmlnaW5hbERvY3VtZW50IiwiY3VycmVudFNjcmlwdCIsIkRvY3VtZW50RnJhZ21lbnQiLCJIVE1MVGVtcGxhdGVFbGVtZW50IiwiTm9kZSIsIk5vZGVGaWx0ZXIiLCJOYW1lZE5vZGVNYXAiLCJNb3pOYW1lZEF0dHJNYXAiLCJIVE1MRm9ybUVsZW1lbnQiLCJET01QYXJzZXIiLCJFbGVtZW50UHJvdG90eXBlIiwiY2xvbmVOb2RlIiwicmVtb3ZlIiwiZ2V0TmV4dFNpYmxpbmciLCJnZXRDaGlsZE5vZGVzIiwiZ2V0UGFyZW50Tm9kZSIsInRlbXBsYXRlIiwiY3JlYXRlRWxlbWVudCIsImNvbnRlbnQiLCJvd25lckRvY3VtZW50IiwidHJ1c3RlZFR5cGVzUG9saWN5IiwiZW1wdHlIVE1MIiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVOb2RlSXRlcmF0b3IiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbXBvcnROb2RlIiwiaG9va3MiLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJJU19BTExPV0VEX1VSSSQxIiwiQUxMT1dFRF9UQUdTIiwiREVGQVVMVF9BTExPV0VEX1RBR1MiLCJBTExPV0VEX0FUVFIiLCJERUZBVUxUX0FMTE9XRURfQVRUUiIsIkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HIiwidGFnTmFtZUNoZWNrIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiYXR0cmlidXRlTmFtZUNoZWNrIiwiYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzIiwiRk9SQklEX1RBR1MiLCJGT1JCSURfQVRUUiIsIkFMTE9XX0FSSUFfQVRUUiIsIkFMTE9XX0RBVEFfQVRUUiIsIkFMTE9XX1VOS05PV05fUFJPVE9DT0xTIiwiQUxMT1dfU0VMRl9DTE9TRV9JTl9BVFRSIiwiU0FGRV9GT1JfVEVNUExBVEVTIiwiU0FGRV9GT1JfWE1MIiwiV0hPTEVfRE9DVU1FTlQiLCJTRVRfQ09ORklHIiwiRk9SQ0VfQk9EWSIsIlJFVFVSTl9ET00iLCJSRVRVUk5fRE9NX0ZSQUdNRU5UIiwiUkVUVVJOX1RSVVNURURfVFlQRSIsIlNBTklUSVpFX0RPTSIsIlNBTklUSVpFX05BTUVEX1BST1BTIiwiU0FOSVRJWkVfTkFNRURfUFJPUFNfUFJFRklYIiwiS0VFUF9DT05URU5UIiwiSU5fUExBQ0UiLCJVU0VfUFJPRklMRVMiLCJGT1JCSURfQ09OVEVOVFMiLCJERUZBVUxUX0ZPUkJJRF9DT05URU5UUyIsIkRBVEFfVVJJX1RBR1MiLCJERUZBVUxUX0RBVEFfVVJJX1RBR1MiLCJVUklfU0FGRV9BVFRSSUJVVEVTIiwiREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTIiwiTUFUSE1MX05BTUVTUEFDRSIsIlNWR19OQU1FU1BBQ0UiLCJIVE1MX05BTUVTUEFDRSIsIk5BTUVTUEFDRSIsIklTX0VNUFRZX0lOUFVUIiwiQUxMT1dFRF9OQU1FU1BBQ0VTIiwiREVGQVVMVF9BTExPV0VEX05BTUVTUEFDRVMiLCJNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFMiLCJIVE1MX0lOVEVHUkFUSU9OX1BPSU5UUyIsIkNPTU1PTl9TVkdfQU5EX0hUTUxfRUxFTUVOVFMiLCJQQVJTRVJfTUVESUFfVFlQRSIsIlNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMiLCJERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFIiwiQ09ORklHIiwiZm9ybUVsZW1lbnQiLCJpc1JlZ2V4T3JGdW5jdGlvbiIsInRlc3RWYWx1ZSIsIkZ1bmN0aW9uIiwiX3BhcnNlQ29uZmlnIiwiY2ZnIiwiQUREX1VSSV9TQUZFX0FUVFIiLCJBRERfREFUQV9VUklfVEFHUyIsIkFMTE9XRURfVVJJX1JFR0VYUCIsIkFERF9UQUdTIiwiQUREX0FUVFIiLCJ0YWJsZSIsInRib2R5IiwiVFJVU1RFRF9UWVBFU19QT0xJQ1kiLCJBTExfU1ZHX1RBR1MiLCJBTExfTUFUSE1MX1RBR1MiLCJfY2hlY2tWYWxpZE5hbWVzcGFjZSIsInBhcmVudCIsInRhZ05hbWUiLCJuYW1lc3BhY2VVUkkiLCJwYXJlbnRUYWdOYW1lIiwiQm9vbGVhbiIsIl9mb3JjZVJlbW92ZSIsIm5vZGUiLCJyZW1vdmVDaGlsZCIsIl9yZW1vdmVBdHRyaWJ1dGUiLCJuYW1lIiwiZ2V0QXR0cmlidXRlTm9kZSIsImZyb20iLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJfaW5pdERvY3VtZW50IiwiZGlydHkiLCJkb2MiLCJsZWFkaW5nV2hpdGVzcGFjZSIsIm1hdGNoZXMiLCJkaXJ0eVBheWxvYWQiLCJwYXJzZUZyb21TdHJpbmciLCJkb2N1bWVudEVsZW1lbnQiLCJjcmVhdGVEb2N1bWVudCIsImlubmVySFRNTCIsImJvZHkiLCJpbnNlcnRCZWZvcmUiLCJjcmVhdGVUZXh0Tm9kZSIsImNoaWxkTm9kZXMiLCJjYWxsIiwiX2NyZWF0ZU5vZGVJdGVyYXRvciIsIlNIT1dfRUxFTUVOVCIsIlNIT1dfQ09NTUVOVCIsIlNIT1dfVEVYVCIsIlNIT1dfUFJPQ0VTU0lOR19JTlNUUlVDVElPTiIsIlNIT1dfQ0RBVEFfU0VDVElPTiIsIl9pc0Nsb2JiZXJlZCIsIm5vZGVOYW1lIiwidGV4dENvbnRlbnQiLCJhdHRyaWJ1dGVzIiwiaGFzQ2hpbGROb2RlcyIsIl9pc05vZGUiLCJfZXhlY3V0ZUhvb2tzIiwiY3VycmVudE5vZGUiLCJkYXRhIiwiaG9vayIsIl9zYW5pdGl6ZUVsZW1lbnRzIiwiYWxsb3dlZFRhZ3MiLCJmaXJzdEVsZW1lbnRDaGlsZCIsIl9pc0Jhc2ljQ3VzdG9tRWxlbWVudCIsInBhcmVudE5vZGUiLCJjaGlsZENvdW50IiwiaSIsImNoaWxkQ2xvbmUiLCJfX3JlbW92YWxDb3VudCIsImV4cHIiLCJfaXNWYWxpZEF0dHJpYnV0ZSIsImxjVGFnIiwibGNOYW1lIiwiX3Nhbml0aXplQXR0cmlidXRlcyIsImhvb2tFdmVudCIsImF0dHJOYW1lIiwiYXR0clZhbHVlIiwia2VlcEF0dHIiLCJhbGxvd2VkQXR0cmlidXRlcyIsImZvcmNlS2VlcEF0dHIiLCJhdHRyIiwiaW5pdFZhbHVlIiwiZ2V0QXR0cmlidXRlVHlwZSIsInNldEF0dHJpYnV0ZU5TIiwiX3Nhbml0aXplU2hhZG93RE9NIiwiZnJhZ21lbnQiLCJzaGFkb3dOb2RlIiwic2hhZG93SXRlcmF0b3IiLCJuZXh0Tm9kZSIsInNhbml0aXplIiwiaW1wb3J0ZWROb2RlIiwicmV0dXJuTm9kZSIsImFwcGVuZENoaWxkIiwiZmlyc3RDaGlsZCIsIm5vZGVJdGVyYXRvciIsInNoYWRvd3Jvb3QiLCJzaGFkb3dyb290bW9kZSIsInNlcmlhbGl6ZWRIVE1MIiwib3V0ZXJIVE1MIiwiZG9jdHlwZSIsInNldENvbmZpZyIsImNsZWFyQ29uZmlnIiwiaXNWYWxpZEF0dHJpYnV0ZSIsInRhZyIsImFkZEhvb2siLCJlbnRyeVBvaW50IiwiaG9va0Z1bmN0aW9uIiwicmVtb3ZlSG9vayIsInJlbW92ZUhvb2tzIiwicmVtb3ZlQWxsSG9va3MiLCJwdXJpZnkiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/dompurify/dist/purify.es.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/marked/lib/marked.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/marked/lib/marked.esm.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hooks: function() { return /* binding */ _Hooks; },\n/* harmony export */   Lexer: function() { return /* binding */ _Lexer; },\n/* harmony export */   Marked: function() { return /* binding */ Marked; },\n/* harmony export */   Parser: function() { return /* binding */ _Parser; },\n/* harmony export */   Renderer: function() { return /* binding */ _Renderer; },\n/* harmony export */   TextRenderer: function() { return /* binding */ _TextRenderer; },\n/* harmony export */   Tokenizer: function() { return /* binding */ _Tokenizer; },\n/* harmony export */   defaults: function() { return /* binding */ _defaults; },\n/* harmony export */   getDefaults: function() { return /* binding */ _getDefaults; },\n/* harmony export */   lexer: function() { return /* binding */ lexer; },\n/* harmony export */   marked: function() { return /* binding */ marked; },\n/* harmony export */   options: function() { return /* binding */ options; },\n/* harmony export */   parse: function() { return /* binding */ parse; },\n/* harmony export */   parseInline: function() { return /* binding */ parseInline; },\n/* harmony export */   parser: function() { return /* binding */ parser; },\n/* harmony export */   setOptions: function() { return /* binding */ setOptions; },\n/* harmony export */   use: function() { return /* binding */ use; },\n/* harmony export */   walkTokens: function() { return /* binding */ walkTokens; }\n/* harmony export */ });\n/**\n * marked v15.0.12 - a markdown parser\n * Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ // src/defaults.ts\nvar _class;\nfunction _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null\n    };\n}\nvar _defaults = _getDefaults();\nfunction changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\n// src/rules.ts\nvar noopTest = {\n    exec: ()=>null\n};\nfunction edit(regex) {\n    let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n    let source = typeof regex === \"string\" ? regex : regex.source;\n    const obj = {\n        replace: (name, val)=>{\n            let valSource = typeof val === \"string\" ? val : val.source;\n            valSource = valSource.replace(other.caret, \"$1\");\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: ()=>{\n            return new RegExp(source, opt);\n        }\n    };\n    return obj;\n}\nvar other = {\n    codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n    outputLinkReplace: /\\\\([\\[\\]])/g,\n    indentCodeCompensation: /^(\\s+)(?:```)/,\n    beginningSpace: /^\\s+/,\n    endingHash: /#$/,\n    startingSpaceChar: /^ /,\n    endingSpaceChar: / $/,\n    nonSpaceChar: /[^ ]/,\n    newLineCharGlobal: /\\n/g,\n    tabCharGlobal: /\\t/g,\n    multipleSpaceGlobal: /\\s+/g,\n    blankLine: /^[ \\t]*$/,\n    doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n    blockquoteStart: /^ {0,3}>/,\n    blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n    blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n    listReplaceTabs: /^\\t+/,\n    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n    listIsTask: /^\\[[ xX]\\] /,\n    listReplaceTask: /^\\[[ xX]\\] +/,\n    anyLine: /\\n.*\\n/,\n    hrefBrackets: /^<(.*)>$/,\n    tableDelimiter: /[:|]/,\n    tableAlignChars: /^\\||\\| *$/g,\n    tableRowBlankLine: /\\n[ \\t]*$/,\n    tableAlignRight: /^ *-+: *$/,\n    tableAlignCenter: /^ *:-+: *$/,\n    tableAlignLeft: /^ *:-+ *$/,\n    startATag: /^<a /i,\n    endATag: /^<\\/a>/i,\n    startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n    endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n    startAngleBracket: /^</,\n    endAngleBracket: />$/,\n    pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n    unicodeAlphaNumeric: RegExp(\"[\\\\p{L}\\\\p{N}]\", \"u\"),\n    escapeTest: /[&<>\"']/,\n    escapeReplace: /[&<>\"']/g,\n    escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n    escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n    unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n    caret: /(^|[^\\[])\\^/g,\n    percentDecode: /%25/g,\n    findPipe: /\\|/g,\n    splitPipe: / \\|/,\n    slashPipe: /\\\\\\|/g,\n    carriageReturn: /\\r\\n|\\r/g,\n    spaceLine: /^ +$/gm,\n    notSpaceStart: /^\\S*/,\n    endingNewline: /\\n$/,\n    listItemRegex: (bull)=>new RegExp(\"^( {0,3}\".concat(bull, \")((?:[\t ][^\\\\n]*)?(?:\\\\n|$))\")),\n    nextBulletRegex: (indent)=>new RegExp(\"^ {0,\".concat(Math.min(3, indent - 1), \"}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \t][^\\\\n]*)?(?:\\\\n|$))\")),\n    hrRegex: (indent)=>new RegExp(\"^ {0,\".concat(Math.min(3, indent - 1), \"}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)\")),\n    fencesBeginRegex: (indent)=>new RegExp(\"^ {0,\".concat(Math.min(3, indent - 1), \"}(?:```|~~~)\")),\n    headingBeginRegex: (indent)=>new RegExp(\"^ {0,\".concat(Math.min(3, indent - 1), \"}#\")),\n    htmlBeginRegex: (indent)=>new RegExp(\"^ {0,\".concat(Math.min(3, indent - 1), \"}<(?:[a-z].*>|!--)\"), \"i\")\n};\nvar newline = /^(?:[ \\t]*(?:\\n|$))+/;\nvar blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nvar fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nvar hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nvar heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nvar bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nvar lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/;\nvar lheading = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\\n>]+>\\n/).replace(/\\|table/g, \"\").getRegex();\nvar lheadingGfm = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\\n>]+>\\n/).replace(/table/g, / {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/).getRegex();\nvar _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nvar blockText = /^[^\\n]+/;\nvar _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nvar def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/).replace(\"label\", _blockLabel).replace(\"title\", /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/).getRegex();\nvar list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/).replace(/bull/g, bullet).getRegex();\nvar _tag = \"address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul\";\nvar _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nvar html = edit(\"^ {0,3}(?:<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)|comment[^\\\\n]*(\\\\n+|$)|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$))\", \"i\").replace(\"comment\", _comment).replace(\"tag\", _tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\nvar paragraph = edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\").replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \").replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag).getRegex();\nvar blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/).replace(\"paragraph\", paragraph).getRegex();\nvar blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText\n};\nvar gfmTable = edit(\"^ *([^\\\\n ].*)\\\\n {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\").replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \"(?: {4}| {0,3}\t)[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \").replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag).getRegex();\nvar blockGfm = {\n    ...blockNormal,\n    lheading: lheadingGfm,\n    table: gfmTable,\n    paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\").replace(\"table\", gfmTable).replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \").replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag).getRegex()\n};\nvar blockPedantic = {\n    ...blockNormal,\n    html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace(\"comment\", _comment).replace(/tag/g, \"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", lheading).replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").replace(\"|tag\", \"\").getRegex()\n};\nvar escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nvar inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nvar br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nvar inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\nvar _punctuation = RegExp(\"[\\\\p{P}\\\\p{S}]\", \"u\");\nvar _punctuationOrSpace = RegExp(\"[\\\\s\\\\p{P}\\\\p{S}]\", \"u\");\nvar _notPunctuationOrSpace = RegExp(\"[^\\\\s\\\\p{P}\\\\p{S}]\", \"u\");\nvar punctuation = edit(/^((?![*_])punctSpace)/, \"u\").replace(/punctSpace/g, _punctuationOrSpace).getRegex();\nvar _punctuationGfmStrongEm = RegExp(\"(?!~)[\\\\p{P}\\\\p{S}]\", \"u\");\nvar _punctuationOrSpaceGfmStrongEm = RegExp(\"(?!~)[\\\\s\\\\p{P}\\\\p{S}]\", \"u\");\nvar _notPunctuationOrSpaceGfmStrongEm = RegExp(\"(?:[^\\\\s\\\\p{P}\\\\p{S}]|~)\", \"u\");\nvar blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\nvar emStrongLDelimCore = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/;\nvar emStrongLDelim = edit(emStrongLDelimCore, \"u\").replace(/punct/g, _punctuation).getRegex();\nvar emStrongLDelimGfm = edit(emStrongLDelimCore, \"u\").replace(/punct/g, _punctuationGfmStrongEm).getRegex();\nvar emStrongRDelimAstCore = \"^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)|notPunctSpace(\\\\*+)(?=notPunctSpace)\";\nvar emStrongRDelimAst = edit(emStrongRDelimAstCore, \"gu\").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();\nvar emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, \"gu\").replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm).replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm).replace(/punct/g, _punctuationGfmStrongEm).getRegex();\nvar emStrongRDelimUnd = edit(\"^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)\", \"gu\").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();\nvar anyPunctuation = edit(/\\\\(punct)/, \"gu\").replace(/punct/g, _punctuation).getRegex();\nvar autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/).replace(\"scheme\", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace(\"email\", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();\nvar _inlineComment = edit(_comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\nvar tag = edit(\"^comment|^</[a-zA-Z][\\\\w:-]*\\\\s*>|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>|^<\\\\?[\\\\s\\\\S]*?\\\\?>|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\").replace(\"comment\", _inlineComment).replace(\"attribute\", /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/).getRegex();\nvar _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nvar link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:(?:[ \\t]*(?:\\n[ \\t]*)?)(title))?\\s*\\)/).replace(\"label\", _inlineLabel).replace(\"href\", /<(?:\\\\.|[^\\n<>\\\\])+>|[^ \\t\\n\\x00-\\x1f]*/).replace(\"title\", /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/).getRegex();\nvar reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/).replace(\"label\", _inlineLabel).replace(\"ref\", _blockLabel).getRegex();\nvar nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/).replace(\"ref\", _blockLabel).getRegex();\nvar reflinkSearch = edit(\"reflink|nolink(?!\\\\()\", \"g\").replace(\"reflink\", reflink).replace(\"nolink\", nolink).getRegex();\nvar inlineNormal = {\n    _backpedal: noopTest,\n    // only used for GFM url\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest\n};\nvar inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", _inlineLabel).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", _inlineLabel).getRegex()\n};\nvar inlineGfm = {\n    ...inlineNormal,\n    emStrongRDelimAst: emStrongRDelimAstGfm,\n    emStrongLDelim: emStrongLDelimGfm,\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, \"i\").replace(\"email\", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n};\nvar inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace(\"{2,}\", \"*\").getRegex(),\n    text: edit(inlineGfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n};\nvar block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic\n};\nvar inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic\n};\n// src/helpers.ts\nvar escapeReplacements = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nvar getEscapeReplacement = (ch)=>escapeReplacements[ch];\nfunction escape2(html2, encode) {\n    if (encode) {\n        if (other.escapeTest.test(html2)) {\n            return html2.replace(other.escapeReplace, getEscapeReplacement);\n        }\n    } else {\n        if (other.escapeTestNoEncode.test(html2)) {\n            return html2.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html2;\n}\nfunction cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(other.percentDecode, \"%\");\n    } catch (e) {\n        return null;\n    }\n    return href;\n}\nfunction splitCells(tableRow, count) {\n    var _cells_at;\n    const row = tableRow.replace(other.findPipe, (match, offset, str)=>{\n        let escaped = false;\n        let curr = offset;\n        while(--curr >= 0 && str[curr] === \"\\\\\")escaped = !escaped;\n        if (escaped) {\n            return \"|\";\n        } else {\n            return \" |\";\n        }\n    }), cells = row.split(other.splitPipe);\n    let i = 0;\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !((_cells_at = cells.at(-1)) === null || _cells_at === void 0 ? void 0 : _cells_at.trim())) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        } else {\n            while(cells.length < count)cells.push(\"\");\n        }\n    }\n    for(; i < cells.length; i++){\n        cells[i] = cells[i].trim().replace(other.slashPipe, \"|\");\n    }\n    return cells;\n}\nfunction rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return \"\";\n    }\n    let suffLen = 0;\n    while(suffLen < l){\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        } else if (currChar !== c && invert) {\n            suffLen++;\n        } else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for(let i = 0; i < str.length; i++){\n        if (str[i] === \"\\\\\") {\n            i++;\n        } else if (str[i] === b[0]) {\n            level++;\n        } else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    if (level > 0) {\n        return -2;\n    }\n    return -1;\n}\n// src/Tokenizer.ts\nfunction outputLink(cap, link2, raw, lexer2, rules) {\n    const href = link2.href;\n    const title = link2.title || null;\n    const text = cap[1].replace(rules.other.outputLinkReplace, \"$1\");\n    lexer2.state.inLink = true;\n    const token = {\n        type: cap[0].charAt(0) === \"!\" ? \"image\" : \"link\",\n        raw,\n        href,\n        title,\n        text,\n        tokens: lexer2.inlineTokens(text)\n    };\n    lexer2.state.inLink = false;\n    return token;\n}\nfunction indentCodeCompensation(raw, text, rules) {\n    const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text.split(\"\\n\").map((node)=>{\n        const matchIndentInNode = node.match(rules.other.beginningSpace);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    }).join(\"\\n\");\n}\nvar _Tokenizer = class {\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: \"space\",\n                raw: cap[0]\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(this.rules.other.codeRemoveIndent, \"\");\n            return {\n                type: \"code\",\n                raw: cap[0],\n                codeBlockStyle: \"indented\",\n                text: !this.options.pedantic ? rtrim(text, \"\\n\") : text\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || \"\", this.rules);\n            return {\n                type: \"code\",\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, \"$1\") : cap[2],\n                text\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            if (this.rules.other.endingHash.test(text)) {\n                const trimmed = rtrim(text, \"#\");\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: \"hr\",\n                raw: rtrim(cap[0], \"\\n\")\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            let lines = rtrim(cap[0], \"\\n\").split(\"\\n\");\n            let raw = \"\";\n            let text = \"\";\n            const tokens = [];\n            while(lines.length > 0){\n                let inBlockquote = false;\n                const currentLines = [];\n                let i;\n                for(i = 0; i < lines.length; i++){\n                    if (this.rules.other.blockquoteStart.test(lines[i])) {\n                        currentLines.push(lines[i]);\n                        inBlockquote = true;\n                    } else if (!inBlockquote) {\n                        currentLines.push(lines[i]);\n                    } else {\n                        break;\n                    }\n                }\n                lines = lines.slice(i);\n                const currentRaw = currentLines.join(\"\\n\");\n                const currentText = currentRaw.replace(this.rules.other.blockquoteSetextReplace, \"\\n    $1\").replace(this.rules.other.blockquoteSetextReplace2, \"\");\n                raw = raw ? \"\".concat(raw, \"\\n\").concat(currentRaw) : currentRaw;\n                text = text ? \"\".concat(text, \"\\n\").concat(currentText) : currentText;\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                this.lexer.blockTokens(currentText, tokens, true);\n                this.lexer.state.top = top;\n                if (lines.length === 0) {\n                    break;\n                }\n                const lastToken = tokens.at(-1);\n                if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === \"code\") {\n                    break;\n                } else if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === \"blockquote\") {\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + \"\\n\" + lines.join(\"\\n\");\n                    const newToken = this.blockquote(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                    break;\n                } else if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === \"list\") {\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + \"\\n\" + lines.join(\"\\n\");\n                    const newToken = this.list(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                    lines = newText.substring(tokens.at(-1).raw.length).split(\"\\n\");\n                    continue;\n                }\n            }\n            return {\n                type: \"blockquote\",\n                raw,\n                tokens,\n                text\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list2 = {\n                type: \"list\",\n                raw: \"\",\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : \"\",\n                loose: false,\n                items: []\n            };\n            bull = isordered ? \"\\\\d{1,9}\\\\\".concat(bull.slice(-1)) : \"\\\\\".concat(bull);\n            if (this.options.pedantic) {\n                bull = isordered ? bull : \"[*+-]\";\n            }\n            const itemRegex = this.rules.other.listItemRegex(bull);\n            let endsWithBlankLine = false;\n            while(src){\n                let endEarly = false;\n                let raw = \"\";\n                let itemContents = \"\";\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) {\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split(\"\\n\", 1)[0].replace(this.rules.other.listReplaceTabs, (t)=>\" \".repeat(3 * t.length));\n                let nextLine = src.split(\"\\n\", 1)[0];\n                let blankLine = !line.trim();\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                } else if (blankLine) {\n                    indent = cap[1].length + 1;\n                } else {\n                    indent = cap[2].search(this.rules.other.nonSpaceChar);\n                    indent = indent > 4 ? 1 : indent;\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                if (blankLine && this.rules.other.blankLine.test(nextLine)) {\n                    raw += nextLine + \"\\n\";\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n                    const hrRegex = this.rules.other.hrRegex(indent);\n                    const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n                    const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n                    const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n                    while(src){\n                        const rawLine = src.split(\"\\n\", 1)[0];\n                        let nextLineWithoutTabs;\n                        nextLine = rawLine;\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(this.rules.other.listReplaceNesting, \"  \");\n                            nextLineWithoutTabs = nextLine;\n                        } else {\n                            nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, \"    \");\n                        }\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        if (htmlBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        if (hrRegex.test(nextLine)) {\n                            break;\n                        }\n                        if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) {\n                            itemContents += \"\\n\" + nextLineWithoutTabs.slice(indent);\n                        } else {\n                            if (blankLine) {\n                                break;\n                            }\n                            if (line.replace(this.rules.other.tabCharGlobal, \"    \").search(this.rules.other.nonSpaceChar) >= 4) {\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += \"\\n\" + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) {\n                            blankLine = true;\n                        }\n                        raw += rawLine + \"\\n\";\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLineWithoutTabs.slice(indent);\n                    }\n                }\n                if (!list2.loose) {\n                    if (endsWithBlankLine) {\n                        list2.loose = true;\n                    } else if (this.rules.other.doubleBlankLine.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                if (this.options.gfm) {\n                    istask = this.rules.other.listIsTask.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== \"[ ] \";\n                        itemContents = itemContents.replace(this.rules.other.listReplaceTask, \"\");\n                    }\n                }\n                list2.items.push({\n                    type: \"list_item\",\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: []\n                });\n                list2.raw += raw;\n            }\n            const lastItem = list2.items.at(-1);\n            if (lastItem) {\n                lastItem.raw = lastItem.raw.trimEnd();\n                lastItem.text = lastItem.text.trimEnd();\n            } else {\n                return;\n            }\n            list2.raw = list2.raw.trimEnd();\n            for(let i = 0; i < list2.items.length; i++){\n                this.lexer.state.top = false;\n                list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);\n                if (!list2.loose) {\n                    const spacers = list2.items[i].tokens.filter((t)=>t.type === \"space\");\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t)=>this.rules.other.anyLine.test(t.raw));\n                    list2.loose = hasMultipleLineBreaks;\n                }\n            }\n            if (list2.loose) {\n                for(let i = 0; i < list2.items.length; i++){\n                    list2.items[i].loose = true;\n                }\n            }\n            return list2;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: \"html\",\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\",\n                text: cap[0]\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag2 = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, \" \");\n            const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, \"$1\").replace(this.rules.inline.anyPunctuation, \"$1\") : \"\";\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, \"$1\") : cap[3];\n            return {\n                type: \"def\",\n                tag: tag2,\n                raw: cap[0],\n                href,\n                title\n            };\n        }\n    }\n    table(src) {\n        var _cap_;\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!this.rules.other.tableDelimiter.test(cap[2])) {\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(this.rules.other.tableAlignChars, \"\").split(\"|\");\n        const rows = ((_cap_ = cap[3]) === null || _cap_ === void 0 ? void 0 : _cap_.trim()) ? cap[3].replace(this.rules.other.tableRowBlankLine, \"\").split(\"\\n\") : [];\n        const item = {\n            type: \"table\",\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: []\n        };\n        if (headers.length !== aligns.length) {\n            return;\n        }\n        for (const align of aligns){\n            if (this.rules.other.tableAlignRight.test(align)) {\n                item.align.push(\"right\");\n            } else if (this.rules.other.tableAlignCenter.test(align)) {\n                item.align.push(\"center\");\n            } else if (this.rules.other.tableAlignLeft.test(align)) {\n                item.align.push(\"left\");\n            } else {\n                item.align.push(null);\n            }\n        }\n        for(let i = 0; i < headers.length; i++){\n            item.header.push({\n                text: headers[i],\n                tokens: this.lexer.inline(headers[i]),\n                header: true,\n                align: item.align[i]\n            });\n        }\n        for (const row of rows){\n            item.rows.push(splitCells(row, item.header.length).map((cell, i)=>{\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                    header: false,\n                    align: item.align[i]\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n            return {\n                type: \"paragraph\",\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: \"escape\",\n                raw: cap[0],\n                text: cap[1]\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: \"html\",\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0]\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {\n                if (!this.rules.other.endAngleBracket.test(trimmedUrl)) {\n                    return;\n                }\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            } else {\n                const lastParenIndex = findClosingBracket(cap[2], \"()\");\n                if (lastParenIndex === -2) {\n                    return;\n                }\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = \"\";\n                }\n            }\n            let href = cap[2];\n            let title = \"\";\n            if (this.options.pedantic) {\n                const link2 = this.rules.other.pedanticHrefTitle.exec(href);\n                if (link2) {\n                    href = link2[1];\n                    title = link2[3];\n                }\n            } else {\n                title = cap[3] ? cap[3].slice(1, -1) : \"\";\n            }\n            href = href.trim();\n            if (this.rules.other.startAngleBracket.test(href)) {\n                if (this.options.pedantic && !this.rules.other.endAngleBracket.test(trimmedUrl)) {\n                    href = href.slice(1);\n                } else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, \"$1\") : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, \"$1\") : title\n            }, cap[0], this.lexer, this.rules);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, \" \");\n            const link2 = links[linkString.toLowerCase()];\n            if (!link2) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: \"text\",\n                    raw: text,\n                    text\n                };\n            }\n            return outputLink(cap, link2, cap[0], this.lexer, this.rules);\n        }\n    }\n    emStrong(src, maskedSrc) {\n        let prevChar = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\";\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match) return;\n        if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric)) return;\n        const nextChar = match[1] || match[2] || \"\";\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            const lLength = [\n                ...match[0]\n            ].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === \"*\" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while((match = endReg.exec(maskedSrc)) != null){\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim) continue;\n                rLength = [\n                    ...rDelim\n                ].length;\n                if (match[3] || match[4]) {\n                    delimTotal += rLength;\n                    continue;\n                } else if (match[5] || match[6]) {\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue;\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0) continue;\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                const lastCharLength = [\n                    ...match[0]\n                ][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                if (Math.min(lLength, rLength) % 2) {\n                    const text2 = raw.slice(1, -1);\n                    return {\n                        type: \"em\",\n                        raw,\n                        text: text2,\n                        tokens: this.lexer.inlineTokens(text2)\n                    };\n                }\n                const text = raw.slice(2, -2);\n                return {\n                    type: \"strong\",\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text)\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(this.rules.other.newLineCharGlobal, \" \");\n            const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n            const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            return {\n                type: \"codespan\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: \"br\",\n                raw: cap[0]\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: \"del\",\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = cap[1];\n                href = \"mailto:\" + text;\n            } else {\n                text = cap[1];\n                href = text;\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = cap[0];\n                href = \"mailto:\" + text;\n            } else {\n                let prevCapZero;\n                do {\n                    var _this_rules_inline__backpedal_exec;\n                    prevCapZero = cap[0];\n                    var _this_rules_inline__backpedal_exec_;\n                    cap[0] = (_this_rules_inline__backpedal_exec_ = (_this_rules_inline__backpedal_exec = this.rules.inline._backpedal.exec(cap[0])) === null || _this_rules_inline__backpedal_exec === void 0 ? void 0 : _this_rules_inline__backpedal_exec[0]) !== null && _this_rules_inline__backpedal_exec_ !== void 0 ? _this_rules_inline__backpedal_exec_ : \"\";\n                }while (prevCapZero !== cap[0]);\n                text = cap[0];\n                if (cap[1] === \"www.\") {\n                    href = \"http://\" + cap[0];\n                } else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            const escaped = this.lexer.state.inRawBlock;\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                escaped\n            };\n        }\n    }\n    // set by the lexer\n    constructor(options2){\n        this.options = options2 || _defaults;\n    }\n};\n// src/Lexer.ts\nvar _Lexer = class __Lexer {\n    /**\n   * Expose Rules\n   */ static get rules() {\n        return {\n            block,\n            inline\n        };\n    }\n    /**\n   * Static Lex Method\n   */ static lex(src, options2) {\n        const lexer2 = new __Lexer(options2);\n        return lexer2.lex(src);\n    }\n    /**\n   * Static Lex Inline Method\n   */ static lexInline(src, options2) {\n        const lexer2 = new __Lexer(options2);\n        return lexer2.inlineTokens(src);\n    }\n    /**\n   * Preprocessing\n   */ lex(src) {\n        src = src.replace(other.carriageReturn, \"\\n\");\n        this.blockTokens(src, this.tokens);\n        for(let i = 0; i < this.inlineQueue.length; i++){\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n    }\n    blockTokens(src) {\n        let tokens = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], lastParagraphClipped = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        if (this.options.pedantic) {\n            src = src.replace(other.tabCharGlobal, \"    \").replace(other.spaceLine, \"\");\n        }\n        while(src){\n            var _this_options_extensions_block, _this_options_extensions, _this_options_extensions1;\n            let token;\n            if ((_this_options_extensions = this.options.extensions) === null || _this_options_extensions === void 0 ? void 0 : (_this_options_extensions_block = _this_options_extensions.block) === null || _this_options_extensions_block === void 0 ? void 0 : _this_options_extensions_block.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (token.raw.length === 1 && lastToken !== void 0) {\n                    lastToken.raw += \"\\n\";\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === \"paragraph\" || (lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === \"paragraph\" || (lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.raw;\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                } else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                }\n                continue;\n            }\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            let cutSrc = src;\n            if ((_this_options_extensions1 = this.options.extensions) === null || _this_options_extensions1 === void 0 ? void 0 : _this_options_extensions1.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                const lastToken = tokens.at(-1);\n                if (lastParagraphClipped && (lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === \"paragraph\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src) {\n        let tokens = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        this.inlineQueue.push({\n            src,\n            tokens\n        });\n        return tokens;\n    }\n    /**\n   * Lexing/Compiling\n   */ inlineTokens(src) {\n        let tokens = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        let maskedSrc = src;\n        let match = null;\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null){\n                    if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        while((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        let keepPrevChar = false;\n        let prevChar = \"\";\n        while(src){\n            var _this_options_extensions_inline, _this_options_extensions, _this_options_extensions1;\n            if (!keepPrevChar) {\n                prevChar = \"\";\n            }\n            keepPrevChar = false;\n            let token;\n            if ((_this_options_extensions = this.options.extensions) === null || _this_options_extensions === void 0 ? void 0 : (_this_options_extensions_inline = _this_options_extensions.inline) === null || _this_options_extensions_inline === void 0 ? void 0 : _this_options_extensions_inline.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (token.type === \"text\" && (lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            let cutSrc = src;\n            if ((_this_options_extensions1 = this.options.extensions) === null || _this_options_extensions1 === void 0 ? void 0 : _this_options_extensions1.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== \"_\") {\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                const lastToken = tokens.at(-1);\n                if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.type) === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n    constructor(options2){\n        this.tokens = [];\n        this.tokens.links = /* @__PURE__ */ Object.create(null);\n        this.options = options2 || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n        };\n        const rules = {\n            other,\n            block: block.normal,\n            inline: inline.normal\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        } else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            } else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n};\n// src/Renderer.ts\nvar _Renderer = class {\n    space(token) {\n        return \"\";\n    }\n    code(param) {\n        let { text, lang, escaped } = param;\n        var _match;\n        const langString = (_match = (lang || \"\").match(other.notSpaceStart)) === null || _match === void 0 ? void 0 : _match[0];\n        const code = text.replace(other.endingNewline, \"\") + \"\\n\";\n        if (!langString) {\n            return \"<pre><code>\" + (escaped ? code : escape2(code, true)) + \"</code></pre>\\n\";\n        }\n        return '<pre><code class=\"language-' + escape2(langString) + '\">' + (escaped ? code : escape2(code, true)) + \"</code></pre>\\n\";\n    }\n    blockquote(param) {\n        let { tokens } = param;\n        const body = this.parser.parse(tokens);\n        return \"<blockquote>\\n\".concat(body, \"</blockquote>\\n\");\n    }\n    html(param) {\n        let { text } = param;\n        return text;\n    }\n    heading(param) {\n        let { tokens, depth } = param;\n        return \"<h\".concat(depth, \">\").concat(this.parser.parseInline(tokens), \"</h\").concat(depth, \">\\n\");\n    }\n    hr(token) {\n        return \"<hr>\\n\";\n    }\n    list(token) {\n        const ordered = token.ordered;\n        const start = token.start;\n        let body = \"\";\n        for(let j = 0; j < token.items.length; j++){\n            const item = token.items[j];\n            body += this.listitem(item);\n        }\n        const type = ordered ? \"ol\" : \"ul\";\n        const startAttr = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n        return \"<\" + type + startAttr + \">\\n\" + body + \"</\" + type + \">\\n\";\n    }\n    listitem(item) {\n        let itemBody = \"\";\n        if (item.task) {\n            const checkbox = this.checkbox({\n                checked: !!item.checked\n            });\n            if (item.loose) {\n                var _item_tokens_;\n                if (((_item_tokens_ = item.tokens[0]) === null || _item_tokens_ === void 0 ? void 0 : _item_tokens_.type) === \"paragraph\") {\n                    item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") {\n                        item.tokens[0].tokens[0].text = checkbox + \" \" + escape2(item.tokens[0].tokens[0].text);\n                        item.tokens[0].tokens[0].escaped = true;\n                    }\n                } else {\n                    item.tokens.unshift({\n                        type: \"text\",\n                        raw: checkbox + \" \",\n                        text: checkbox + \" \",\n                        escaped: true\n                    });\n                }\n            } else {\n                itemBody += checkbox + \" \";\n            }\n        }\n        itemBody += this.parser.parse(item.tokens, !!item.loose);\n        return \"<li>\".concat(itemBody, \"</li>\\n\");\n    }\n    checkbox(param) {\n        let { checked } = param;\n        return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph(param) {\n        let { tokens } = param;\n        return \"<p>\".concat(this.parser.parseInline(tokens), \"</p>\\n\");\n    }\n    table(token) {\n        let header = \"\";\n        let cell = \"\";\n        for(let j = 0; j < token.header.length; j++){\n            cell += this.tablecell(token.header[j]);\n        }\n        header += this.tablerow({\n            text: cell\n        });\n        let body = \"\";\n        for(let j = 0; j < token.rows.length; j++){\n            const row = token.rows[j];\n            cell = \"\";\n            for(let k = 0; k < row.length; k++){\n                cell += this.tablecell(row[k]);\n            }\n            body += this.tablerow({\n                text: cell\n            });\n        }\n        if (body) body = \"<tbody>\".concat(body, \"</tbody>\");\n        return \"<table>\\n<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n    }\n    tablerow(param) {\n        let { text } = param;\n        return \"<tr>\\n\".concat(text, \"</tr>\\n\");\n    }\n    tablecell(token) {\n        const content = this.parser.parseInline(token.tokens);\n        const type = token.header ? \"th\" : \"td\";\n        const tag2 = token.align ? \"<\".concat(type, ' align=\"').concat(token.align, '\">') : \"<\".concat(type, \">\");\n        return tag2 + content + \"</\".concat(type, \">\\n\");\n    }\n    /**\n   * span level renderer\n   */ strong(param) {\n        let { tokens } = param;\n        return \"<strong>\".concat(this.parser.parseInline(tokens), \"</strong>\");\n    }\n    em(param) {\n        let { tokens } = param;\n        return \"<em>\".concat(this.parser.parseInline(tokens), \"</em>\");\n    }\n    codespan(param) {\n        let { text } = param;\n        return \"<code>\".concat(escape2(text, true), \"</code>\");\n    }\n    br(token) {\n        return \"<br>\";\n    }\n    del(param) {\n        let { tokens } = param;\n        return \"<del>\".concat(this.parser.parseInline(tokens), \"</del>\");\n    }\n    link(param) {\n        let { href, title, tokens } = param;\n        const text = this.parser.parseInline(tokens);\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + escape2(title) + '\"';\n        }\n        out += \">\" + text + \"</a>\";\n        return out;\n    }\n    image(param) {\n        let { href, title, text, tokens } = param;\n        if (tokens) {\n            text = this.parser.parseInline(tokens, this.parser.textRenderer);\n        }\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return escape2(text);\n        }\n        href = cleanHref;\n        let out = '<img src=\"'.concat(href, '\" alt=\"').concat(text, '\"');\n        if (title) {\n            out += ' title=\"'.concat(escape2(title), '\"');\n        }\n        out += \">\";\n        return out;\n    }\n    text(token) {\n        return \"tokens\" in token && token.tokens ? this.parser.parseInline(token.tokens) : \"escaped\" in token && token.escaped ? token.text : escape2(token.text);\n    }\n    // set by the parser\n    constructor(options2){\n        this.options = options2 || _defaults;\n    }\n};\n// src/TextRenderer.ts\nvar _TextRenderer = class {\n    // no need for block level renderers\n    strong(param) {\n        let { text } = param;\n        return text;\n    }\n    em(param) {\n        let { text } = param;\n        return text;\n    }\n    codespan(param) {\n        let { text } = param;\n        return text;\n    }\n    del(param) {\n        let { text } = param;\n        return text;\n    }\n    html(param) {\n        let { text } = param;\n        return text;\n    }\n    text(param) {\n        let { text } = param;\n        return text;\n    }\n    link(param) {\n        let { text } = param;\n        return \"\" + text;\n    }\n    image(param) {\n        let { text } = param;\n        return \"\" + text;\n    }\n    br() {\n        return \"\";\n    }\n};\n// src/Parser.ts\nvar _Parser = class __Parser {\n    /**\n   * Static Parse Method\n   */ static parse(tokens, options2) {\n        const parser2 = new __Parser(options2);\n        return parser2.parse(tokens);\n    }\n    /**\n   * Static Parse Inline Method\n   */ static parseInline(tokens, options2) {\n        const parser2 = new __Parser(options2);\n        return parser2.parseInline(tokens);\n    }\n    /**\n   * Parse Loop\n   */ parse(tokens) {\n        let top = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            var _this_options_extensions_renderers, _this_options_extensions;\n            const anyToken = tokens[i];\n            if ((_this_options_extensions = this.options.extensions) === null || _this_options_extensions === void 0 ? void 0 : (_this_options_extensions_renderers = _this_options_extensions.renderers) === null || _this_options_extensions_renderers === void 0 ? void 0 : _this_options_extensions_renderers[anyToken.type]) {\n                const genericToken = anyToken;\n                const ret = this.options.extensions.renderers[genericToken.type].call({\n                    parser: this\n                }, genericToken);\n                if (ret !== false || ![\n                    \"space\",\n                    \"hr\",\n                    \"heading\",\n                    \"code\",\n                    \"table\",\n                    \"blockquote\",\n                    \"list\",\n                    \"html\",\n                    \"paragraph\",\n                    \"text\"\n                ].includes(genericToken.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch(token.type){\n                case \"space\":\n                    {\n                        out += this.renderer.space(token);\n                        continue;\n                    }\n                case \"hr\":\n                    {\n                        out += this.renderer.hr(token);\n                        continue;\n                    }\n                case \"heading\":\n                    {\n                        out += this.renderer.heading(token);\n                        continue;\n                    }\n                case \"code\":\n                    {\n                        out += this.renderer.code(token);\n                        continue;\n                    }\n                case \"table\":\n                    {\n                        out += this.renderer.table(token);\n                        continue;\n                    }\n                case \"blockquote\":\n                    {\n                        out += this.renderer.blockquote(token);\n                        continue;\n                    }\n                case \"list\":\n                    {\n                        out += this.renderer.list(token);\n                        continue;\n                    }\n                case \"html\":\n                    {\n                        out += this.renderer.html(token);\n                        continue;\n                    }\n                case \"paragraph\":\n                    {\n                        out += this.renderer.paragraph(token);\n                        continue;\n                    }\n                case \"text\":\n                    {\n                        let textToken = token;\n                        let body = this.renderer.text(textToken);\n                        while(i + 1 < tokens.length && tokens[i + 1].type === \"text\"){\n                            textToken = tokens[++i];\n                            body += \"\\n\" + this.renderer.text(textToken);\n                        }\n                        if (top) {\n                            out += this.renderer.paragraph({\n                                type: \"paragraph\",\n                                raw: body,\n                                text: body,\n                                tokens: [\n                                    {\n                                        type: \"text\",\n                                        raw: body,\n                                        text: body,\n                                        escaped: true\n                                    }\n                                ]\n                            });\n                        } else {\n                            out += body;\n                        }\n                        continue;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n    /**\n   * Parse Inline Tokens\n   */ parseInline(tokens) {\n        let renderer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.renderer;\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            var _this_options_extensions_renderers, _this_options_extensions;\n            const anyToken = tokens[i];\n            if ((_this_options_extensions = this.options.extensions) === null || _this_options_extensions === void 0 ? void 0 : (_this_options_extensions_renderers = _this_options_extensions.renderers) === null || _this_options_extensions_renderers === void 0 ? void 0 : _this_options_extensions_renderers[anyToken.type]) {\n                const ret = this.options.extensions.renderers[anyToken.type].call({\n                    parser: this\n                }, anyToken);\n                if (ret !== false || ![\n                    \"escape\",\n                    \"html\",\n                    \"link\",\n                    \"image\",\n                    \"strong\",\n                    \"em\",\n                    \"codespan\",\n                    \"br\",\n                    \"del\",\n                    \"text\"\n                ].includes(anyToken.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch(token.type){\n                case \"escape\":\n                    {\n                        out += renderer.text(token);\n                        break;\n                    }\n                case \"html\":\n                    {\n                        out += renderer.html(token);\n                        break;\n                    }\n                case \"link\":\n                    {\n                        out += renderer.link(token);\n                        break;\n                    }\n                case \"image\":\n                    {\n                        out += renderer.image(token);\n                        break;\n                    }\n                case \"strong\":\n                    {\n                        out += renderer.strong(token);\n                        break;\n                    }\n                case \"em\":\n                    {\n                        out += renderer.em(token);\n                        break;\n                    }\n                case \"codespan\":\n                    {\n                        out += renderer.codespan(token);\n                        break;\n                    }\n                case \"br\":\n                    {\n                        out += renderer.br(token);\n                        break;\n                    }\n                case \"del\":\n                    {\n                        out += renderer.del(token);\n                        break;\n                    }\n                case \"text\":\n                    {\n                        out += renderer.text(token);\n                        break;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n    constructor(options2){\n        this.options = options2 || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.renderer.parser = this;\n        this.textRenderer = new _TextRenderer();\n    }\n};\n// src/Hooks.ts\nvar _Hooks = (_class = class {\n    /**\n   * Process markdown before marked\n   */ preprocess(markdown) {\n        return markdown;\n    }\n    /**\n   * Process HTML after marked is finished\n   */ postprocess(html2) {\n        return html2;\n    }\n    /**\n   * Process all tokens before walk tokens\n   */ processAllTokens(tokens) {\n        return tokens;\n    }\n    /**\n   * Provide function to tokenize markdown\n   */ provideLexer() {\n        return this.block ? _Lexer.lex : _Lexer.lexInline;\n    }\n    /**\n   * Provide function to parse tokens\n   */ provideParser() {\n        return this.block ? _Parser.parse : _Parser.parseInline;\n    }\n    constructor(options2){\n        this.options = options2 || _defaults;\n    }\n}, _class.passThroughHooks = /* @__PURE__ */ new Set([\n    \"preprocess\",\n    \"postprocess\",\n    \"processAllTokens\"\n]), _class);\n// src/Instance.ts\nvar Marked = class {\n    /**\n   * Run callback for every token\n   */ walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens){\n            values = values.concat(callback.call(this, token));\n            switch(token.type){\n                case \"table\":\n                    {\n                        const tableToken = token;\n                        for (const cell of tableToken.header){\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                        for (const row of tableToken.rows){\n                            for (const cell of row){\n                                values = values.concat(this.walkTokens(cell.tokens, callback));\n                            }\n                        }\n                        break;\n                    }\n                case \"list\":\n                    {\n                        const listToken = token;\n                        values = values.concat(this.walkTokens(listToken.items, callback));\n                        break;\n                    }\n                default:\n                    {\n                        var _this_defaults_extensions_childTokens, _this_defaults_extensions;\n                        const genericToken = token;\n                        if ((_this_defaults_extensions = this.defaults.extensions) === null || _this_defaults_extensions === void 0 ? void 0 : (_this_defaults_extensions_childTokens = _this_defaults_extensions.childTokens) === null || _this_defaults_extensions_childTokens === void 0 ? void 0 : _this_defaults_extensions_childTokens[genericToken.type]) {\n                            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens)=>{\n                                const tokens2 = genericToken[childTokens].flat(Infinity);\n                                values = values.concat(this.walkTokens(tokens2, callback));\n                            });\n                        } else if (genericToken.tokens) {\n                            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                    }\n            }\n        }\n        return values;\n    }\n    use() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const extensions = this.defaults.extensions || {\n            renderers: {},\n            childTokens: {}\n        };\n        args.forEach((pack)=>{\n            const opts = {\n                ...pack\n            };\n            opts.async = this.defaults.async || opts.async || false;\n            if (pack.extensions) {\n                pack.extensions.forEach((ext)=>{\n                    if (!ext.name) {\n                        throw new Error(\"extension name required\");\n                    }\n                    if (\"renderer\" in ext) {\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            extensions.renderers[ext.name] = function() {\n                                for(var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++){\n                                    args2[_key] = arguments[_key];\n                                }\n                                let ret = ext.renderer.apply(this, args2);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args2);\n                                }\n                                return ret;\n                            };\n                        } else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if (\"tokenizer\" in ext) {\n                        if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        } else {\n                            extensions[ext.level] = [\n                                ext.tokenizer\n                            ];\n                        }\n                        if (ext.start) {\n                            if (ext.level === \"block\") {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                } else {\n                                    extensions.startBlock = [\n                                        ext.start\n                                    ];\n                                }\n                            } else if (ext.level === \"inline\") {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                } else {\n                                    extensions.startInline = [\n                                        ext.start\n                                    ];\n                                }\n                            }\n                        }\n                    }\n                    if (\"childTokens\" in ext && ext.childTokens) {\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for(const prop in pack.renderer){\n                    if (!(prop in renderer)) {\n                        throw new Error(\"renderer '\".concat(prop, \"' does not exist\"));\n                    }\n                    if ([\n                        \"options\",\n                        \"parser\"\n                    ].includes(prop)) {\n                        continue;\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    renderer[rendererProp] = function() {\n                        for(var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++){\n                            args2[_key] = arguments[_key];\n                        }\n                        let ret = rendererFunc.apply(renderer, args2);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args2);\n                        }\n                        return ret || \"\";\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for(const prop in pack.tokenizer){\n                    if (!(prop in tokenizer)) {\n                        throw new Error(\"tokenizer '\".concat(prop, \"' does not exist\"));\n                    }\n                    if ([\n                        \"options\",\n                        \"rules\",\n                        \"lexer\"\n                    ].includes(prop)) {\n                        continue;\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    tokenizer[tokenizerProp] = function() {\n                        for(var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++){\n                            args2[_key] = arguments[_key];\n                        }\n                        let ret = tokenizerFunc.apply(tokenizer, args2);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args2);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for(const prop in pack.hooks){\n                    if (!(prop in hooks)) {\n                        throw new Error(\"hook '\".concat(prop, \"' does not exist\"));\n                    }\n                    if ([\n                        \"options\",\n                        \"block\"\n                    ].includes(prop)) {\n                        continue;\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        hooks[hooksProp] = (arg)=>{\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2)=>{\n                                    return prevHook.call(hooks, ret2);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    } else {\n                        hooks[hooksProp] = function() {\n                            for(var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++){\n                                args2[_key] = arguments[_key];\n                            }\n                            let ret = hooksFunc.apply(hooks, args2);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args2);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            if (pack.walkTokens) {\n                const walkTokens2 = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function(token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens2) {\n                        values = values.concat(walkTokens2.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = {\n                ...this.defaults,\n                ...opts\n            };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = {\n            ...this.defaults,\n            ...opt\n        };\n        return this;\n    }\n    lexer(src, options2) {\n        return _Lexer.lex(src, options2 !== null && options2 !== void 0 ? options2 : this.defaults);\n    }\n    parser(tokens, options2) {\n        return _Parser.parse(tokens, options2 !== null && options2 !== void 0 ? options2 : this.defaults);\n    }\n    parseMarkdown(blockType) {\n        const parse2 = (src, options2)=>{\n            const origOpt = {\n                ...options2\n            };\n            const opt = {\n                ...this.defaults,\n                ...origOpt\n            };\n            const throwError = this.onError(!!opt.silent, !!opt.async);\n            if (this.defaults.async === true && origOpt.async === false) {\n                return throwError(new Error(\"marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.\"));\n            }\n            if (typeof src === \"undefined\" || src === null) {\n                return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n            }\n            if (typeof src !== \"string\") {\n                return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n                opt.hooks.block = blockType;\n            }\n            const lexer2 = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;\n            const parser2 = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2)=>lexer2(src2, opt)).then((tokens)=>opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens)=>opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(()=>tokens) : tokens).then((tokens)=>parser2(tokens, opt)).then((html2)=>opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                let tokens = lexer2(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens);\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html2 = parser2(tokens, opt);\n                if (opt.hooks) {\n                    html2 = opt.hooks.postprocess(html2);\n                }\n                return html2;\n            } catch (e) {\n                return throwError(e);\n            }\n        };\n        return parse2;\n    }\n    onError(silent, async) {\n        return (e)=>{\n            e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n            if (silent) {\n                const msg = \"<p>An error occurred:</p><pre>\" + escape2(e.message + \"\", true) + \"</pre>\";\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n    constructor(...args){\n        this.defaults = _getDefaults();\n        this.options = this.setOptions;\n        this.parse = this.parseMarkdown(true);\n        this.parseInline = this.parseMarkdown(false);\n        this.Parser = _Parser;\n        this.Renderer = _Renderer;\n        this.TextRenderer = _TextRenderer;\n        this.Lexer = _Lexer;\n        this.Tokenizer = _Tokenizer;\n        this.Hooks = _Hooks;\n        this.use(...args);\n    }\n};\n// src/marked.ts\nvar markedInstance = new Marked();\nfunction marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\nmarked.options = marked.setOptions = function(options2) {\n    markedInstance.setOptions(options2);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\nmarked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\nmarked.use = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\nmarked.walkTokens = function(tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\nmarked.parseInline = markedInstance.parseInline;\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nvar options = marked.options;\nvar setOptions = marked.setOptions;\nvar use = marked.use;\nvar walkTokens = marked.walkTokens;\nvar parseInline = marked.parseInline;\nvar parse = marked;\nvar parser = _Parser.parse;\nvar lexer = _Lexer.lex;\n //# sourceMappingURL=marked.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUVEOzs7Q0FHQyxHQUdELGtCQUFrQjs7QUFDbEIsU0FBU0E7SUFDUCxPQUFPO1FBQ0xDLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxZQUFZO1FBQ1pDLEtBQUs7UUFDTEMsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLFVBQVU7UUFDVkMsUUFBUTtRQUNSQyxXQUFXO1FBQ1hDLFlBQVk7SUFDZDtBQUNGO0FBQ0EsSUFBSUMsWUFBWVg7QUFDaEIsU0FBU1ksZUFBZUMsV0FBVztJQUNqQ0YsWUFBWUU7QUFDZDtBQUVBLGVBQWU7QUFDZixJQUFJQyxXQUFXO0lBQUVDLE1BQU0sSUFBTTtBQUFLO0FBQ2xDLFNBQVNDLEtBQUtDLEtBQUs7UUFBRUMsTUFBQUEsaUVBQU07SUFDekIsSUFBSUMsU0FBUyxPQUFPRixVQUFVLFdBQVdBLFFBQVFBLE1BQU1FLE1BQU07SUFDN0QsTUFBTUMsTUFBTTtRQUNWQyxTQUFTLENBQUNDLE1BQU1DO1lBQ2QsSUFBSUMsWUFBWSxPQUFPRCxRQUFRLFdBQVdBLE1BQU1BLElBQUlKLE1BQU07WUFDMURLLFlBQVlBLFVBQVVILE9BQU8sQ0FBQ0ksTUFBTUMsS0FBSyxFQUFFO1lBQzNDUCxTQUFTQSxPQUFPRSxPQUFPLENBQUNDLE1BQU1FO1lBQzlCLE9BQU9KO1FBQ1Q7UUFDQU8sVUFBVTtZQUNSLE9BQU8sSUFBSUMsT0FBT1QsUUFBUUQ7UUFDNUI7SUFDRjtJQUNBLE9BQU9FO0FBQ1Q7QUFDQSxJQUFJSyxRQUFRO0lBQ1ZJLGtCQUFrQjtJQUNsQkMsbUJBQW1CO0lBQ25CQyx3QkFBd0I7SUFDeEJDLGdCQUFnQjtJQUNoQkMsWUFBWTtJQUNaQyxtQkFBbUI7SUFDbkJDLGlCQUFpQjtJQUNqQkMsY0FBYztJQUNkQyxtQkFBbUI7SUFDbkJDLGVBQWU7SUFDZkMs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QUFJbE4sVUFBVWtOLE9BQU9sTixPQUFPO0FBQzVCLElBQUkyTCxhQUFhdUIsT0FBT3ZCLFVBQVU7QUFDbEMsSUFBSTFCLE1BQU1pRCxPQUFPakQsR0FBRztBQUNwQixJQUFJaFgsYUFBYWlhLE9BQU9qYSxVQUFVO0FBQ2xDLElBQUltVSxjQUFjOEYsT0FBTzlGLFdBQVc7QUFDcEMsSUFBSUQsUUFBUStGO0FBQ1osSUFBSWhHLFNBQVNvQixRQUFRbkIsS0FBSztBQUMxQixJQUFJL0csUUFBUThFLE9BQU9FLEdBQUc7QUFvQnBCLENBQ0Ysc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5lc20uanM/YzczOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG1hcmtlZCB2MTUuMC4xMiAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAyNSwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWRcbiAqL1xuXG4vKipcbiAqIERPIE5PVCBFRElUIFRISVMgRklMRVxuICogVGhlIGNvZGUgaW4gdGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIGZpbGVzIGluIC4vc3JjL1xuICovXG5cblxuLy8gc3JjL2RlZmF1bHRzLnRzXG5mdW5jdGlvbiBfZ2V0RGVmYXVsdHMoKSB7XG4gIHJldHVybiB7XG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGJyZWFrczogZmFsc2UsXG4gICAgZXh0ZW5zaW9uczogbnVsbCxcbiAgICBnZm06IHRydWUsXG4gICAgaG9va3M6IG51bGwsXG4gICAgcGVkYW50aWM6IGZhbHNlLFxuICAgIHJlbmRlcmVyOiBudWxsLFxuICAgIHNpbGVudDogZmFsc2UsXG4gICAgdG9rZW5pemVyOiBudWxsLFxuICAgIHdhbGtUb2tlbnM6IG51bGxcbiAgfTtcbn1cbnZhciBfZGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHMoKTtcbmZ1bmN0aW9uIGNoYW5nZURlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gIF9kZWZhdWx0cyA9IG5ld0RlZmF1bHRzO1xufVxuXG4vLyBzcmMvcnVsZXMudHNcbnZhciBub29wVGVzdCA9IHsgZXhlYzogKCkgPT4gbnVsbCB9O1xuZnVuY3Rpb24gZWRpdChyZWdleCwgb3B0ID0gXCJcIikge1xuICBsZXQgc291cmNlID0gdHlwZW9mIHJlZ2V4ID09PSBcInN0cmluZ1wiID8gcmVnZXggOiByZWdleC5zb3VyY2U7XG4gIGNvbnN0IG9iaiA9IHtcbiAgICByZXBsYWNlOiAobmFtZSwgdmFsKSA9PiB7XG4gICAgICBsZXQgdmFsU291cmNlID0gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IHZhbCA6IHZhbC5zb3VyY2U7XG4gICAgICB2YWxTb3VyY2UgPSB2YWxTb3VyY2UucmVwbGFjZShvdGhlci5jYXJldCwgXCIkMVwiKTtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKG5hbWUsIHZhbFNvdXJjZSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZ2V0UmVnZXg6ICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgb3B0KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBvYmo7XG59XG52YXIgb3RoZXIgPSB7XG4gIGNvZGVSZW1vdmVJbmRlbnQ6IC9eKD86IHsxLDR9fCB7MCwzfVxcdCkvZ20sXG4gIG91dHB1dExpbmtSZXBsYWNlOiAvXFxcXChbXFxbXFxdXSkvZyxcbiAgaW5kZW50Q29kZUNvbXBlbnNhdGlvbjogL14oXFxzKykoPzpgYGApLyxcbiAgYmVnaW5uaW5nU3BhY2U6IC9eXFxzKy8sXG4gIGVuZGluZ0hhc2g6IC8jJC8sXG4gIHN0YXJ0aW5nU3BhY2VDaGFyOiAvXiAvLFxuICBlbmRpbmdTcGFjZUNoYXI6IC8gJC8sXG4gIG5vblNwYWNlQ2hhcjogL1teIF0vLFxuICBuZXdMaW5lQ2hhckdsb2JhbDogL1xcbi9nLFxuICB0YWJDaGFyR2xvYmFsOiAvXFx0L2csXG4gIG11bHRpcGxlU3BhY2VHbG9iYWw6IC9cXHMrL2csXG4gIGJsYW5rTGluZTogL15bIFxcdF0qJC8sXG4gIGRvdWJsZUJsYW5rTGluZTogL1xcblsgXFx0XSpcXG5bIFxcdF0qJC8sXG4gIGJsb2NrcXVvdGVTdGFydDogL14gezAsM30+LyxcbiAgYmxvY2txdW90ZVNldGV4dFJlcGxhY2U6IC9cXG4gezAsM30oKD86PSt8LSspICopKD89XFxufCQpL2csXG4gIGJsb2NrcXVvdGVTZXRleHRSZXBsYWNlMjogL14gezAsM30+WyBcXHRdPy9nbSxcbiAgbGlzdFJlcGxhY2VUYWJzOiAvXlxcdCsvLFxuICBsaXN0UmVwbGFjZU5lc3Rpbmc6IC9eIHsxLDR9KD89KCB7NH0pKlteIF0pL2csXG4gIGxpc3RJc1Rhc2s6IC9eXFxbWyB4WF1cXF0gLyxcbiAgbGlzdFJlcGxhY2VUYXNrOiAvXlxcW1sgeFhdXFxdICsvLFxuICBhbnlMaW5lOiAvXFxuLipcXG4vLFxuICBocmVmQnJhY2tldHM6IC9ePCguKik+JC8sXG4gIHRhYmxlRGVsaW1pdGVyOiAvWzp8XS8sXG4gIHRhYmxlQWxpZ25DaGFyczogL15cXHx8XFx8ICokL2csXG4gIHRhYmxlUm93QmxhbmtMaW5lOiAvXFxuWyBcXHRdKiQvLFxuICB0YWJsZUFsaWduUmlnaHQ6IC9eICotKzogKiQvLFxuICB0YWJsZUFsaWduQ2VudGVyOiAvXiAqOi0rOiAqJC8sXG4gIHRhYmxlQWxpZ25MZWZ0OiAvXiAqOi0rICokLyxcbiAgc3RhcnRBVGFnOiAvXjxhIC9pLFxuICBlbmRBVGFnOiAvXjxcXC9hPi9pLFxuICBzdGFydFByZVNjcmlwdFRhZzogL148KHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLFxuICBlbmRQcmVTY3JpcHRUYWc6IC9ePFxcLyhwcmV8Y29kZXxrYmR8c2NyaXB0KShcXHN8PikvaSxcbiAgc3RhcnRBbmdsZUJyYWNrZXQ6IC9ePC8sXG4gIGVuZEFuZ2xlQnJhY2tldDogLz4kLyxcbiAgcGVkYW50aWNIcmVmVGl0bGU6IC9eKFteJ1wiXSpbXlxcc10pXFxzKyhbJ1wiXSkoLiopXFwyLyxcbiAgdW5pY29kZUFscGhhTnVtZXJpYzogL1tcXHB7TH1cXHB7Tn1dL3UsXG4gIGVzY2FwZVRlc3Q6IC9bJjw+XCInXS8sXG4gIGVzY2FwZVJlcGxhY2U6IC9bJjw+XCInXS9nLFxuICBlc2NhcGVUZXN0Tm9FbmNvZGU6IC9bPD5cIiddfCYoPyEoI1xcZHsxLDd9fCNbWHhdW2EtZkEtRjAtOV17MSw2fXxcXHcrKTspLyxcbiAgZXNjYXBlUmVwbGFjZU5vRW5jb2RlOiAvWzw+XCInXXwmKD8hKCNcXGR7MSw3fXwjW1h4XVthLWZBLUYwLTldezEsNn18XFx3Kyk7KS9nLFxuICB1bmVzY2FwZVRlc3Q6IC8mKCMoPzpcXGQrKXwoPzojeFswLTlBLUZhLWZdKyl8KD86XFx3KykpOz8vaWcsXG4gIGNhcmV0OiAvKF58W15cXFtdKVxcXi9nLFxuICBwZXJjZW50RGVjb2RlOiAvJTI1L2csXG4gIGZpbmRQaXBlOiAvXFx8L2csXG4gIHNwbGl0UGlwZTogLyBcXHwvLFxuICBzbGFzaFBpcGU6IC9cXFxcXFx8L2csXG4gIGNhcnJpYWdlUmV0dXJuOiAvXFxyXFxufFxcci9nLFxuICBzcGFjZUxpbmU6IC9eICskL2dtLFxuICBub3RTcGFjZVN0YXJ0OiAvXlxcUyovLFxuICBlbmRpbmdOZXdsaW5lOiAvXFxuJC8sXG4gIGxpc3RJdGVtUmVnZXg6IChidWxsKSA9PiBuZXcgUmVnRXhwKGBeKCB7MCwzfSR7YnVsbH0pKCg/OltcdCBdW15cXFxcbl0qKT8oPzpcXFxcbnwkKSlgKSxcbiAgbmV4dEJ1bGxldFJlZ2V4OiAoaW5kZW50KSA9PiBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSg/OlsqKy1dfFxcXFxkezEsOX1bLildKSgoPzpbIFx0XVteXFxcXG5dKik/KD86XFxcXG58JCkpYCksXG4gIGhyUmVnZXg6IChpbmRlbnQpID0+IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19KCg/Oi0gKil7Myx9fCg/Ol8gKil7Myx9fCg/OlxcXFwqICopezMsfSkoPzpcXFxcbit8JClgKSxcbiAgZmVuY2VzQmVnaW5SZWdleDogKGluZGVudCkgPT4gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0oPzpcXGBcXGBcXGB8fn5+KWApLFxuICBoZWFkaW5nQmVnaW5SZWdleDogKGluZGVudCkgPT4gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0jYCksXG4gIGh0bWxCZWdpblJlZ2V4OiAoaW5kZW50KSA9PiBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fTwoPzpbYS16XS4qPnwhLS0pYCwgXCJpXCIpXG59O1xudmFyIG5ld2xpbmUgPSAvXig/OlsgXFx0XSooPzpcXG58JCkpKy87XG52YXIgYmxvY2tDb2RlID0gL14oKD86IHs0fXwgezAsM31cXHQpW15cXG5dKyg/Olxcbig/OlsgXFx0XSooPzpcXG58JCkpKik/KSsvO1xudmFyIGZlbmNlcyA9IC9eIHswLDN9KGB7Myx9KD89W15gXFxuXSooPzpcXG58JCkpfH57Myx9KShbXlxcbl0qKSg/OlxcbnwkKSg/OnwoW1xcc1xcU10qPykoPzpcXG58JCkpKD86IHswLDN9XFwxW35gXSogKig/PVxcbnwkKXwkKS87XG52YXIgaHIgPSAvXiB7MCwzfSgoPzotW1xcdCBdKil7Myx9fCg/Ol9bIFxcdF0qKXszLH18KD86XFwqWyBcXHRdKil7Myx9KSg/Olxcbit8JCkvO1xudmFyIGhlYWRpbmcgPSAvXiB7MCwzfSgjezEsNn0pKD89XFxzfCQpKC4qKSg/Olxcbit8JCkvO1xudmFyIGJ1bGxldCA9IC8oPzpbKistXXxcXGR7MSw5fVsuKV0pLztcbnZhciBsaGVhZGluZ0NvcmUgPSAvXig/IWJ1bGwgfGJsb2NrQ29kZXxmZW5jZXN8YmxvY2txdW90ZXxoZWFkaW5nfGh0bWx8dGFibGUpKCg/Oi58XFxuKD8hXFxzKj9cXG58YnVsbCB8YmxvY2tDb2RlfGZlbmNlc3xibG9ja3F1b3RlfGhlYWRpbmd8aHRtbHx0YWJsZSkpKz8pXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS87XG52YXIgbGhlYWRpbmcgPSBlZGl0KGxoZWFkaW5nQ29yZSkucmVwbGFjZSgvYnVsbC9nLCBidWxsZXQpLnJlcGxhY2UoL2Jsb2NrQ29kZS9nLCAvKD86IHs0fXwgezAsM31cXHQpLykucmVwbGFjZSgvZmVuY2VzL2csIC8gezAsM30oPzpgezMsfXx+ezMsfSkvKS5yZXBsYWNlKC9ibG9ja3F1b3RlL2csIC8gezAsM30+LykucmVwbGFjZSgvaGVhZGluZy9nLCAvIHswLDN9I3sxLDZ9LykucmVwbGFjZSgvaHRtbC9nLCAvIHswLDN9PFteXFxuPl0rPlxcbi8pLnJlcGxhY2UoL1xcfHRhYmxlL2csIFwiXCIpLmdldFJlZ2V4KCk7XG52YXIgbGhlYWRpbmdHZm0gPSBlZGl0KGxoZWFkaW5nQ29yZSkucmVwbGFjZSgvYnVsbC9nLCBidWxsZXQpLnJlcGxhY2UoL2Jsb2NrQ29kZS9nLCAvKD86IHs0fXwgezAsM31cXHQpLykucmVwbGFjZSgvZmVuY2VzL2csIC8gezAsM30oPzpgezMsfXx+ezMsfSkvKS5yZXBsYWNlKC9ibG9ja3F1b3RlL2csIC8gezAsM30+LykucmVwbGFjZSgvaGVhZGluZy9nLCAvIHswLDN9I3sxLDZ9LykucmVwbGFjZSgvaHRtbC9nLCAvIHswLDN9PFteXFxuPl0rPlxcbi8pLnJlcGxhY2UoL3RhYmxlL2csIC8gezAsM31cXHw/KD86WzpcXC0gXSpcXHwpK1tcXDpcXC0gXSpcXG4vKS5nZXRSZWdleCgpO1xudmFyIF9wYXJhZ3JhcGggPSAvXihbXlxcbl0rKD86XFxuKD8haHJ8aGVhZGluZ3xsaGVhZGluZ3xibG9ja3F1b3RlfGZlbmNlc3xsaXN0fGh0bWx8dGFibGV8ICtcXG4pW15cXG5dKykqKS87XG52YXIgYmxvY2tUZXh0ID0gL15bXlxcbl0rLztcbnZhciBfYmxvY2tMYWJlbCA9IC8oPyFcXHMqXFxdKSg/OlxcXFwufFteXFxbXFxdXFxcXF0pKy87XG52YXIgZGVmID0gZWRpdCgvXiB7MCwzfVxcWyhsYWJlbClcXF06ICooPzpcXG5bIFxcdF0qKT8oW148XFxzXVteXFxzXSp8PC4qPz4pKD86KD86ICsoPzpcXG5bIFxcdF0qKT98ICpcXG5bIFxcdF0qKSh0aXRsZSkpPyAqKD86XFxuK3wkKS8pLnJlcGxhY2UoXCJsYWJlbFwiLCBfYmxvY2tMYWJlbCkucmVwbGFjZShcInRpdGxlXCIsIC8oPzpcIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnW14nXFxuXSooPzpcXG5bXidcXG5dKykqXFxuPyd8XFwoW14oKV0qXFwpKS8pLmdldFJlZ2V4KCk7XG52YXIgbGlzdCA9IGVkaXQoL14oIHswLDN9YnVsbCkoWyBcXHRdW15cXG5dKz8pPyg/OlxcbnwkKS8pLnJlcGxhY2UoL2J1bGwvZywgYnVsbGV0KS5nZXRSZWdleCgpO1xudmFyIF90YWcgPSBcImFkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9ufGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9ufGZpZ3VyZXxmb290ZXJ8Zm9ybXxmcmFtZXxmcmFtZXNldHxoWzEtNl18aGVhZHxoZWFkZXJ8aHJ8aHRtbHxpZnJhbWV8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG1ldGF8bmF2fG5vZnJhbWVzfG9sfG9wdGdyb3VwfG9wdGlvbnxwfHBhcmFtfHNlYXJjaHxzZWN0aW9ufHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGV8dHJ8dHJhY2t8dWxcIjtcbnZhciBfY29tbWVudCA9IC88IS0tKD86LT8+fFtcXHNcXFNdKj8oPzotLT58JCkpLztcbnZhciBodG1sID0gZWRpdChcbiAgXCJeIHswLDN9KD86PChzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKXxjb21tZW50W15cXFxcbl0qKFxcXFxuK3wkKXw8XFxcXD9bXFxcXHNcXFxcU10qPyg/OlxcXFw/PlxcXFxuKnwkKXw8IVtBLVpdW1xcXFxzXFxcXFNdKj8oPzo+XFxcXG4qfCQpfDwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj8oPzpcXFxcXVxcXFxdPlxcXFxuKnwkKXw8Lz8odGFnKSg/OiArfFxcXFxufC8/PilbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuWyBcdF0qKStcXFxcbnwkKXw8KD8hc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSkoW2Etel1bXFxcXHctXSopKD86YXR0cmlidXRlKSo/ICovPz4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuWyBcdF0qKStcXFxcbnwkKXw8Lyg/IXNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpW2Etel1bXFxcXHctXSpcXFxccyo+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcblsgXHRdKikrXFxcXG58JCkpXCIsXG4gIFwiaVwiXG4pLnJlcGxhY2UoXCJjb21tZW50XCIsIF9jb21tZW50KS5yZXBsYWNlKFwidGFnXCIsIF90YWcpLnJlcGxhY2UoXCJhdHRyaWJ1dGVcIiwgLyArW2EtekEtWjpfXVtcXHcuOi1dKig/OiAqPSAqXCJbXlwiXFxuXSpcInwgKj0gKidbXidcXG5dKid8ICo9ICpbXlxcc1wiJz08PmBdKyk/LykuZ2V0UmVnZXgoKTtcbnZhciBwYXJhZ3JhcGggPSBlZGl0KF9wYXJhZ3JhcGgpLnJlcGxhY2UoXCJoclwiLCBocikucmVwbGFjZShcImhlYWRpbmdcIiwgXCIgezAsM30jezEsNn0oPzpcXFxcc3wkKVwiKS5yZXBsYWNlKFwifGxoZWFkaW5nXCIsIFwiXCIpLnJlcGxhY2UoXCJ8dGFibGVcIiwgXCJcIikucmVwbGFjZShcImJsb2NrcXVvdGVcIiwgXCIgezAsM30+XCIpLnJlcGxhY2UoXCJmZW5jZXNcIiwgXCIgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG5cIikucmVwbGFjZShcImxpc3RcIiwgXCIgezAsM30oPzpbKistXXwxWy4pXSkgXCIpLnJlcGxhY2UoXCJodG1sXCIsIFwiPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKVwiKS5yZXBsYWNlKFwidGFnXCIsIF90YWcpLmdldFJlZ2V4KCk7XG52YXIgYmxvY2txdW90ZSA9IGVkaXQoL14oIHswLDN9PiA/KHBhcmFncmFwaHxbXlxcbl0qKSg/OlxcbnwkKSkrLykucmVwbGFjZShcInBhcmFncmFwaFwiLCBwYXJhZ3JhcGgpLmdldFJlZ2V4KCk7XG52YXIgYmxvY2tOb3JtYWwgPSB7XG4gIGJsb2NrcXVvdGUsXG4gIGNvZGU6IGJsb2NrQ29kZSxcbiAgZGVmLFxuICBmZW5jZXMsXG4gIGhlYWRpbmcsXG4gIGhyLFxuICBodG1sLFxuICBsaGVhZGluZyxcbiAgbGlzdCxcbiAgbmV3bGluZSxcbiAgcGFyYWdyYXBoLFxuICB0YWJsZTogbm9vcFRlc3QsXG4gIHRleHQ6IGJsb2NrVGV4dFxufTtcbnZhciBnZm1UYWJsZSA9IGVkaXQoXG4gIFwiXiAqKFteXFxcXG4gXS4qKVxcXFxuIHswLDN9KCg/OlxcXFx8ICopPzo/LSs6PyAqKD86XFxcXHwgKjo/LSs6PyAqKSooPzpcXFxcfCAqKT8pKD86XFxcXG4oKD86KD8hICpcXFxcbnxocnxoZWFkaW5nfGJsb2NrcXVvdGV8Y29kZXxmZW5jZXN8bGlzdHxodG1sKS4qKD86XFxcXG58JCkpKilcXFxcbip8JClcIlxuKS5yZXBsYWNlKFwiaHJcIiwgaHIpLnJlcGxhY2UoXCJoZWFkaW5nXCIsIFwiIHswLDN9I3sxLDZ9KD86XFxcXHN8JClcIikucmVwbGFjZShcImJsb2NrcXVvdGVcIiwgXCIgezAsM30+XCIpLnJlcGxhY2UoXCJjb2RlXCIsIFwiKD86IHs0fXwgezAsM31cdClbXlxcXFxuXVwiKS5yZXBsYWNlKFwiZmVuY2VzXCIsIFwiIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuXCIpLnJlcGxhY2UoXCJsaXN0XCIsIFwiIHswLDN9KD86WyorLV18MVsuKV0pIFwiKS5yZXBsYWNlKFwiaHRtbFwiLCBcIjwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSlcIikucmVwbGFjZShcInRhZ1wiLCBfdGFnKS5nZXRSZWdleCgpO1xudmFyIGJsb2NrR2ZtID0ge1xuICAuLi5ibG9ja05vcm1hbCxcbiAgbGhlYWRpbmc6IGxoZWFkaW5nR2ZtLFxuICB0YWJsZTogZ2ZtVGFibGUsXG4gIHBhcmFncmFwaDogZWRpdChfcGFyYWdyYXBoKS5yZXBsYWNlKFwiaHJcIiwgaHIpLnJlcGxhY2UoXCJoZWFkaW5nXCIsIFwiIHswLDN9I3sxLDZ9KD86XFxcXHN8JClcIikucmVwbGFjZShcInxsaGVhZGluZ1wiLCBcIlwiKS5yZXBsYWNlKFwidGFibGVcIiwgZ2ZtVGFibGUpLnJlcGxhY2UoXCJibG9ja3F1b3RlXCIsIFwiIHswLDN9PlwiKS5yZXBsYWNlKFwiZmVuY2VzXCIsIFwiIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuXCIpLnJlcGxhY2UoXCJsaXN0XCIsIFwiIHswLDN9KD86WyorLV18MVsuKV0pIFwiKS5yZXBsYWNlKFwiaHRtbFwiLCBcIjwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSlcIikucmVwbGFjZShcInRhZ1wiLCBfdGFnKS5nZXRSZWdleCgpXG59O1xudmFyIGJsb2NrUGVkYW50aWMgPSB7XG4gIC4uLmJsb2NrTm9ybWFsLFxuICBodG1sOiBlZGl0KFxuICAgIGBeICooPzpjb21tZW50ICooPzpcXFxcbnxcXFxccyokKXw8KHRhZylbXFxcXHNcXFxcU10rPzwvXFxcXDE+ICooPzpcXFxcbnsyLH18XFxcXHMqJCl8PHRhZyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xcXFxcc1teJ1wiLz5cXFxcc10qKSo/Lz8+ICooPzpcXFxcbnsyLH18XFxcXHMqJCkpYFxuICApLnJlcGxhY2UoXCJjb21tZW50XCIsIF9jb21tZW50KS5yZXBsYWNlKC90YWcvZywgXCIoPyEoPzphfGVtfHN0cm9uZ3xzbWFsbHxzfGNpdGV8cXxkZm58YWJicnxkYXRhfHRpbWV8Y29kZXx2YXJ8c2FtcHxrYmR8c3VifHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkb3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZylcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGJcIikuZ2V0UmVnZXgoKSxcbiAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogKyhbXCIoXVteXFxuXStbXCIpXSkpPyAqKD86XFxuK3wkKS8sXG4gIGhlYWRpbmc6IC9eKCN7MSw2fSkoLiopKD86XFxuK3wkKS8sXG4gIGZlbmNlczogbm9vcFRlc3QsXG4gIC8vIGZlbmNlcyBub3Qgc3VwcG9ydGVkXG4gIGxoZWFkaW5nOiAvXiguKz8pXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gIHBhcmFncmFwaDogZWRpdChfcGFyYWdyYXBoKS5yZXBsYWNlKFwiaHJcIiwgaHIpLnJlcGxhY2UoXCJoZWFkaW5nXCIsIFwiICojezEsNn0gKlteXFxuXVwiKS5yZXBsYWNlKFwibGhlYWRpbmdcIiwgbGhlYWRpbmcpLnJlcGxhY2UoXCJ8dGFibGVcIiwgXCJcIikucmVwbGFjZShcImJsb2NrcXVvdGVcIiwgXCIgezAsM30+XCIpLnJlcGxhY2UoXCJ8ZmVuY2VzXCIsIFwiXCIpLnJlcGxhY2UoXCJ8bGlzdFwiLCBcIlwiKS5yZXBsYWNlKFwifGh0bWxcIiwgXCJcIikucmVwbGFjZShcInx0YWdcIiwgXCJcIikuZ2V0UmVnZXgoKVxufTtcbnZhciBlc2NhcGUgPSAvXlxcXFwoWyFcIiMkJSYnKCkqKyxcXC0uLzo7PD0+P0BcXFtcXF1cXFxcXl9ge3x9fl0pLztcbnZhciBpbmxpbmVDb2RlID0gL14oYCspKFteYF18W15gXVtcXHNcXFNdKj9bXmBdKVxcMSg/IWApLztcbnZhciBiciA9IC9eKCB7Mix9fFxcXFwpXFxuKD8hXFxzKiQpLztcbnZhciBpbmxpbmVUZXh0ID0gL14oYCt8W15gXSkoPzooPz0gezIsfVxcbil8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKl9dfFxcYl98JCl8W14gXSg/PSB7Mix9XFxuKSkpLztcbnZhciBfcHVuY3R1YXRpb24gPSAvW1xccHtQfVxccHtTfV0vdTtcbnZhciBfcHVuY3R1YXRpb25PclNwYWNlID0gL1tcXHNcXHB7UH1cXHB7U31dL3U7XG52YXIgX25vdFB1bmN0dWF0aW9uT3JTcGFjZSA9IC9bXlxcc1xccHtQfVxccHtTfV0vdTtcbnZhciBwdW5jdHVhdGlvbiA9IGVkaXQoL14oKD8hWypfXSlwdW5jdFNwYWNlKS8sIFwidVwiKS5yZXBsYWNlKC9wdW5jdFNwYWNlL2csIF9wdW5jdHVhdGlvbk9yU3BhY2UpLmdldFJlZ2V4KCk7XG52YXIgX3B1bmN0dWF0aW9uR2ZtU3Ryb25nRW0gPSAvKD8hfilbXFxwe1B9XFxwe1N9XS91O1xudmFyIF9wdW5jdHVhdGlvbk9yU3BhY2VHZm1TdHJvbmdFbSA9IC8oPyF+KVtcXHNcXHB7UH1cXHB7U31dL3U7XG52YXIgX25vdFB1bmN0dWF0aW9uT3JTcGFjZUdmbVN0cm9uZ0VtID0gLyg/OlteXFxzXFxwe1B9XFxwe1N9XXx+KS91O1xudmFyIGJsb2NrU2tpcCA9IC9cXFtbXltcXF1dKj9cXF1cXCgoPzpcXFxcLnxbXlxcXFxcXChcXCldfFxcKCg/OlxcXFwufFteXFxcXFxcKFxcKV0pKlxcKSkqXFwpfGBbXmBdKj9gfDxbXjw+XSo/Pi9nO1xudmFyIGVtU3Ryb25nTERlbGltQ29yZSA9IC9eKD86XFwqKyg/OigoPyFcXCopcHVuY3QpfFteXFxzKl0pKXxeXysoPzooKD8hXylwdW5jdCl8KFteXFxzX10pKS87XG52YXIgZW1TdHJvbmdMRGVsaW0gPSBlZGl0KGVtU3Ryb25nTERlbGltQ29yZSwgXCJ1XCIpLnJlcGxhY2UoL3B1bmN0L2csIF9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbnZhciBlbVN0cm9uZ0xEZWxpbUdmbSA9IGVkaXQoZW1TdHJvbmdMRGVsaW1Db3JlLCBcInVcIikucmVwbGFjZSgvcHVuY3QvZywgX3B1bmN0dWF0aW9uR2ZtU3Ryb25nRW0pLmdldFJlZ2V4KCk7XG52YXIgZW1TdHJvbmdSRGVsaW1Bc3RDb3JlID0gXCJeW15fKl0qP19fW15fKl0qP1xcXFwqW15fKl0qPyg/PV9fKXxbXipdKyg/PVteKl0pfCg/IVxcXFwqKXB1bmN0KFxcXFwqKykoPz1bXFxcXHNdfCQpfG5vdFB1bmN0U3BhY2UoXFxcXCorKSg/IVxcXFwqKSg/PXB1bmN0U3BhY2V8JCl8KD8hXFxcXCopcHVuY3RTcGFjZShcXFxcKispKD89bm90UHVuY3RTcGFjZSl8W1xcXFxzXShcXFxcKispKD8hXFxcXCopKD89cHVuY3QpfCg/IVxcXFwqKXB1bmN0KFxcXFwqKykoPyFcXFxcKikoPz1wdW5jdCl8bm90UHVuY3RTcGFjZShcXFxcKispKD89bm90UHVuY3RTcGFjZSlcIjtcbnZhciBlbVN0cm9uZ1JEZWxpbUFzdCA9IGVkaXQoZW1TdHJvbmdSRGVsaW1Bc3RDb3JlLCBcImd1XCIpLnJlcGxhY2UoL25vdFB1bmN0U3BhY2UvZywgX25vdFB1bmN0dWF0aW9uT3JTcGFjZSkucmVwbGFjZSgvcHVuY3RTcGFjZS9nLCBfcHVuY3R1YXRpb25PclNwYWNlKS5yZXBsYWNlKC9wdW5jdC9nLCBfcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG52YXIgZW1TdHJvbmdSRGVsaW1Bc3RHZm0gPSBlZGl0KGVtU3Ryb25nUkRlbGltQXN0Q29yZSwgXCJndVwiKS5yZXBsYWNlKC9ub3RQdW5jdFNwYWNlL2csIF9ub3RQdW5jdHVhdGlvbk9yU3BhY2VHZm1TdHJvbmdFbSkucmVwbGFjZSgvcHVuY3RTcGFjZS9nLCBfcHVuY3R1YXRpb25PclNwYWNlR2ZtU3Ryb25nRW0pLnJlcGxhY2UoL3B1bmN0L2csIF9wdW5jdHVhdGlvbkdmbVN0cm9uZ0VtKS5nZXRSZWdleCgpO1xudmFyIGVtU3Ryb25nUkRlbGltVW5kID0gZWRpdChcbiAgXCJeW15fKl0qP1xcXFwqXFxcXCpbXl8qXSo/X1teXypdKj8oPz1cXFxcKlxcXFwqKXxbXl9dKyg/PVteX10pfCg/IV8pcHVuY3QoXyspKD89W1xcXFxzXXwkKXxub3RQdW5jdFNwYWNlKF8rKSg/IV8pKD89cHVuY3RTcGFjZXwkKXwoPyFfKXB1bmN0U3BhY2UoXyspKD89bm90UHVuY3RTcGFjZSl8W1xcXFxzXShfKykoPyFfKSg/PXB1bmN0KXwoPyFfKXB1bmN0KF8rKSg/IV8pKD89cHVuY3QpXCIsXG4gIFwiZ3VcIlxuKS5yZXBsYWNlKC9ub3RQdW5jdFNwYWNlL2csIF9ub3RQdW5jdHVhdGlvbk9yU3BhY2UpLnJlcGxhY2UoL3B1bmN0U3BhY2UvZywgX3B1bmN0dWF0aW9uT3JTcGFjZSkucmVwbGFjZSgvcHVuY3QvZywgX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xudmFyIGFueVB1bmN0dWF0aW9uID0gZWRpdCgvXFxcXChwdW5jdCkvLCBcImd1XCIpLnJlcGxhY2UoL3B1bmN0L2csIF9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbnZhciBhdXRvbGluayA9IGVkaXQoL148KHNjaGVtZTpbXlxcc1xceDAwLVxceDFmPD5dKnxlbWFpbCk+LykucmVwbGFjZShcInNjaGVtZVwiLCAvW2EtekEtWl1bYS16QS1aMC05Ky4tXXsxLDMxfS8pLnJlcGxhY2UoXCJlbWFpbFwiLCAvW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXSsoQClbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyg/IVstX10pLykuZ2V0UmVnZXgoKTtcbnZhciBfaW5saW5lQ29tbWVudCA9IGVkaXQoX2NvbW1lbnQpLnJlcGxhY2UoXCIoPzotLT58JClcIiwgXCItLT5cIikuZ2V0UmVnZXgoKTtcbnZhciB0YWcgPSBlZGl0KFxuICBcIl5jb21tZW50fF48L1thLXpBLVpdW1xcXFx3Oi1dKlxcXFxzKj58XjxbYS16QS1aXVtcXFxcdy1dKig/OmF0dHJpYnV0ZSkqP1xcXFxzKi8/PnxePFxcXFw/W1xcXFxzXFxcXFNdKj9cXFxcPz58XjwhW2EtekEtWl0rXFxcXHNbXFxcXHNcXFxcU10qPz58XjwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPlwiXG4pLnJlcGxhY2UoXCJjb21tZW50XCIsIF9pbmxpbmVDb21tZW50KS5yZXBsYWNlKFwiYXR0cmlidXRlXCIsIC9cXHMrW2EtekEtWjpfXVtcXHcuOi1dKig/Olxccyo9XFxzKlwiW15cIl0qXCJ8XFxzKj1cXHMqJ1teJ10qJ3xcXHMqPVxccypbXlxcc1wiJz08PmBdKyk/LykuZ2V0UmVnZXgoKTtcbnZhciBfaW5saW5lTGFiZWwgPSAvKD86XFxbKD86XFxcXC58W15cXFtcXF1cXFxcXSkqXFxdfFxcXFwufGBbXmBdKmB8W15cXFtcXF1cXFxcYF0pKj8vO1xudmFyIGxpbmsgPSBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFwoXFxzKihocmVmKSg/Oig/OlsgXFx0XSooPzpcXG5bIFxcdF0qKT8pKHRpdGxlKSk/XFxzKlxcKS8pLnJlcGxhY2UoXCJsYWJlbFwiLCBfaW5saW5lTGFiZWwpLnJlcGxhY2UoXCJocmVmXCIsIC88KD86XFxcXC58W15cXG48PlxcXFxdKSs+fFteIFxcdFxcblxceDAwLVxceDFmXSovKS5yZXBsYWNlKFwidGl0bGVcIiwgL1wiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCcoPzpcXFxcJz98W14nXFxcXF0pKid8XFwoKD86XFxcXFxcKT98W14pXFxcXF0pKlxcKS8pLmdldFJlZ2V4KCk7XG52YXIgcmVmbGluayA9IGVkaXQoL14hP1xcWyhsYWJlbClcXF1cXFsocmVmKVxcXS8pLnJlcGxhY2UoXCJsYWJlbFwiLCBfaW5saW5lTGFiZWwpLnJlcGxhY2UoXCJyZWZcIiwgX2Jsb2NrTGFiZWwpLmdldFJlZ2V4KCk7XG52YXIgbm9saW5rID0gZWRpdCgvXiE/XFxbKHJlZilcXF0oPzpcXFtcXF0pPy8pLnJlcGxhY2UoXCJyZWZcIiwgX2Jsb2NrTGFiZWwpLmdldFJlZ2V4KCk7XG52YXIgcmVmbGlua1NlYXJjaCA9IGVkaXQoXCJyZWZsaW5rfG5vbGluayg/IVxcXFwoKVwiLCBcImdcIikucmVwbGFjZShcInJlZmxpbmtcIiwgcmVmbGluaykucmVwbGFjZShcIm5vbGlua1wiLCBub2xpbmspLmdldFJlZ2V4KCk7XG52YXIgaW5saW5lTm9ybWFsID0ge1xuICBfYmFja3BlZGFsOiBub29wVGVzdCxcbiAgLy8gb25seSB1c2VkIGZvciBHRk0gdXJsXG4gIGFueVB1bmN0dWF0aW9uLFxuICBhdXRvbGluayxcbiAgYmxvY2tTa2lwLFxuICBicixcbiAgY29kZTogaW5saW5lQ29kZSxcbiAgZGVsOiBub29wVGVzdCxcbiAgZW1TdHJvbmdMRGVsaW0sXG4gIGVtU3Ryb25nUkRlbGltQXN0LFxuICBlbVN0cm9uZ1JEZWxpbVVuZCxcbiAgZXNjYXBlLFxuICBsaW5rLFxuICBub2xpbmssXG4gIHB1bmN0dWF0aW9uLFxuICByZWZsaW5rLFxuICByZWZsaW5rU2VhcmNoLFxuICB0YWcsXG4gIHRleHQ6IGlubGluZVRleHQsXG4gIHVybDogbm9vcFRlc3Rcbn07XG52YXIgaW5saW5lUGVkYW50aWMgPSB7XG4gIC4uLmlubGluZU5vcm1hbCxcbiAgbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLykucmVwbGFjZShcImxhYmVsXCIsIF9pbmxpbmVMYWJlbCkuZ2V0UmVnZXgoKSxcbiAgcmVmbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxccypcXFsoW15cXF1dKilcXF0vKS5yZXBsYWNlKFwibGFiZWxcIiwgX2lubGluZUxhYmVsKS5nZXRSZWdleCgpXG59O1xudmFyIGlubGluZUdmbSA9IHtcbiAgLi4uaW5saW5lTm9ybWFsLFxuICBlbVN0cm9uZ1JEZWxpbUFzdDogZW1TdHJvbmdSRGVsaW1Bc3RHZm0sXG4gIGVtU3Ryb25nTERlbGltOiBlbVN0cm9uZ0xEZWxpbUdmbSxcbiAgdXJsOiBlZGl0KC9eKCg/OmZ0cHxodHRwcz8pOlxcL1xcL3x3d3dcXC4pKD86W2EtekEtWjAtOVxcLV0rXFwuPykrW15cXHM8XSp8XmVtYWlsLywgXCJpXCIpLnJlcGxhY2UoXCJlbWFpbFwiLCAvW0EtWmEtejAtOS5fKy1dKyhAKVthLXpBLVowLTktX10rKD86XFwuW2EtekEtWjAtOS1fXSpbYS16QS1aMC05XSkrKD8hWy1fXSkvKS5nZXRSZWdleCgpLFxuICBfYmFja3BlZGFsOiAvKD86W14/IS4sOjsqXydcIn4oKSZdK3xcXChbXildKlxcKXwmKD8hW2EtekEtWjAtOV0rOyQpfFs/IS4sOjsqXydcIn4pXSsoPyEkKSkrLyxcbiAgZGVsOiAvXih+fj8pKD89W15cXHN+XSkoKD86XFxcXC58W15cXFxcXSkqPyg/OlxcXFwufFteXFxzflxcXFxdKSlcXDEoPz1bXn5dfCQpLyxcbiAgdGV4dDogL14oW2B+XSt8W15gfl0pKD86KD89IHsyLH1cXG4pfCg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCl8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKn5fXXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpKS9cbn07XG52YXIgaW5saW5lQnJlYWtzID0ge1xuICAuLi5pbmxpbmVHZm0sXG4gIGJyOiBlZGl0KGJyKS5yZXBsYWNlKFwiezIsfVwiLCBcIipcIikuZ2V0UmVnZXgoKSxcbiAgdGV4dDogZWRpdChpbmxpbmVHZm0udGV4dCkucmVwbGFjZShcIlxcXFxiX1wiLCBcIlxcXFxiX3wgezIsfVxcXFxuXCIpLnJlcGxhY2UoL1xcezIsXFx9L2csIFwiKlwiKS5nZXRSZWdleCgpXG59O1xudmFyIGJsb2NrID0ge1xuICBub3JtYWw6IGJsb2NrTm9ybWFsLFxuICBnZm06IGJsb2NrR2ZtLFxuICBwZWRhbnRpYzogYmxvY2tQZWRhbnRpY1xufTtcbnZhciBpbmxpbmUgPSB7XG4gIG5vcm1hbDogaW5saW5lTm9ybWFsLFxuICBnZm06IGlubGluZUdmbSxcbiAgYnJlYWtzOiBpbmxpbmVCcmVha3MsXG4gIHBlZGFudGljOiBpbmxpbmVQZWRhbnRpY1xufTtcblxuLy8gc3JjL2hlbHBlcnMudHNcbnZhciBlc2NhcGVSZXBsYWNlbWVudHMgPSB7XG4gIFwiJlwiOiBcIiZhbXA7XCIsXG4gIFwiPFwiOiBcIiZsdDtcIixcbiAgXCI+XCI6IFwiJmd0O1wiLFxuICAnXCInOiBcIiZxdW90O1wiLFxuICBcIidcIjogXCImIzM5O1wiXG59O1xudmFyIGdldEVzY2FwZVJlcGxhY2VtZW50ID0gKGNoKSA9PiBlc2NhcGVSZXBsYWNlbWVudHNbY2hdO1xuZnVuY3Rpb24gZXNjYXBlMihodG1sMiwgZW5jb2RlKSB7XG4gIGlmIChlbmNvZGUpIHtcbiAgICBpZiAob3RoZXIuZXNjYXBlVGVzdC50ZXN0KGh0bWwyKSkge1xuICAgICAgcmV0dXJuIGh0bWwyLnJlcGxhY2Uob3RoZXIuZXNjYXBlUmVwbGFjZSwgZ2V0RXNjYXBlUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAob3RoZXIuZXNjYXBlVGVzdE5vRW5jb2RlLnRlc3QoaHRtbDIpKSB7XG4gICAgICByZXR1cm4gaHRtbDIucmVwbGFjZShvdGhlci5lc2NhcGVSZXBsYWNlTm9FbmNvZGUsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGh0bWwyO1xufVxuZnVuY3Rpb24gY2xlYW5VcmwoaHJlZikge1xuICB0cnkge1xuICAgIGhyZWYgPSBlbmNvZGVVUkkoaHJlZikucmVwbGFjZShvdGhlci5wZXJjZW50RGVjb2RlLCBcIiVcIik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBocmVmO1xufVxuZnVuY3Rpb24gc3BsaXRDZWxscyh0YWJsZVJvdywgY291bnQpIHtcbiAgY29uc3Qgcm93ID0gdGFibGVSb3cucmVwbGFjZShvdGhlci5maW5kUGlwZSwgKG1hdGNoLCBvZmZzZXQsIHN0cikgPT4ge1xuICAgIGxldCBlc2NhcGVkID0gZmFsc2U7XG4gICAgbGV0IGN1cnIgPSBvZmZzZXQ7XG4gICAgd2hpbGUgKC0tY3VyciA+PSAwICYmIHN0cltjdXJyXSA9PT0gXCJcXFxcXCIpIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcmV0dXJuIFwifFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCIgfFwiO1xuICAgIH1cbiAgfSksIGNlbGxzID0gcm93LnNwbGl0KG90aGVyLnNwbGl0UGlwZSk7XG4gIGxldCBpID0gMDtcbiAgaWYgKCFjZWxsc1swXS50cmltKCkpIHtcbiAgICBjZWxscy5zaGlmdCgpO1xuICB9XG4gIGlmIChjZWxscy5sZW5ndGggPiAwICYmICFjZWxscy5hdCgtMSk/LnRyaW0oKSkge1xuICAgIGNlbGxzLnBvcCgpO1xuICB9XG4gIGlmIChjb3VudCkge1xuICAgIGlmIChjZWxscy5sZW5ndGggPiBjb3VudCkge1xuICAgICAgY2VsbHMuc3BsaWNlKGNvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGNlbGxzLmxlbmd0aCA8IGNvdW50KSBjZWxscy5wdXNoKFwiXCIpO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2VsbHNbaV0gPSBjZWxsc1tpXS50cmltKCkucmVwbGFjZShvdGhlci5zbGFzaFBpcGUsIFwifFwiKTtcbiAgfVxuICByZXR1cm4gY2VsbHM7XG59XG5mdW5jdGlvbiBydHJpbShzdHIsIGMsIGludmVydCkge1xuICBjb25zdCBsID0gc3RyLmxlbmd0aDtcbiAgaWYgKGwgPT09IDApIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBsZXQgc3VmZkxlbiA9IDA7XG4gIHdoaWxlIChzdWZmTGVuIDwgbCkge1xuICAgIGNvbnN0IGN1cnJDaGFyID0gc3RyLmNoYXJBdChsIC0gc3VmZkxlbiAtIDEpO1xuICAgIGlmIChjdXJyQ2hhciA9PT0gYyAmJiAhaW52ZXJ0KSB7XG4gICAgICBzdWZmTGVuKys7XG4gICAgfSBlbHNlIGlmIChjdXJyQ2hhciAhPT0gYyAmJiBpbnZlcnQpIHtcbiAgICAgIHN1ZmZMZW4rKztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHIuc2xpY2UoMCwgbCAtIHN1ZmZMZW4pO1xufVxuZnVuY3Rpb24gZmluZENsb3NpbmdCcmFja2V0KHN0ciwgYikge1xuICBpZiAoc3RyLmluZGV4T2YoYlsxXSkgPT09IC0xKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGxldCBsZXZlbCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0cltpXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlswXSkge1xuICAgICAgbGV2ZWwrKztcbiAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlsxXSkge1xuICAgICAgbGV2ZWwtLTtcbiAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChsZXZlbCA+IDApIHtcbiAgICByZXR1cm4gLTI7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vLyBzcmMvVG9rZW5pemVyLnRzXG5mdW5jdGlvbiBvdXRwdXRMaW5rKGNhcCwgbGluazIsIHJhdywgbGV4ZXIyLCBydWxlcykge1xuICBjb25zdCBocmVmID0gbGluazIuaHJlZjtcbiAgY29uc3QgdGl0bGUgPSBsaW5rMi50aXRsZSB8fCBudWxsO1xuICBjb25zdCB0ZXh0ID0gY2FwWzFdLnJlcGxhY2UocnVsZXMub3RoZXIub3V0cHV0TGlua1JlcGxhY2UsIFwiJDFcIik7XG4gIGxleGVyMi5zdGF0ZS5pbkxpbmsgPSB0cnVlO1xuICBjb25zdCB0b2tlbiA9IHtcbiAgICB0eXBlOiBjYXBbMF0uY2hhckF0KDApID09PSBcIiFcIiA/IFwiaW1hZ2VcIiA6IFwibGlua1wiLFxuICAgIHJhdyxcbiAgICBocmVmLFxuICAgIHRpdGxlLFxuICAgIHRleHQsXG4gICAgdG9rZW5zOiBsZXhlcjIuaW5saW5lVG9rZW5zKHRleHQpXG4gIH07XG4gIGxleGVyMi5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgcmV0dXJuIHRva2VuO1xufVxuZnVuY3Rpb24gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIHRleHQsIHJ1bGVzKSB7XG4gIGNvbnN0IG1hdGNoSW5kZW50VG9Db2RlID0gcmF3Lm1hdGNoKHJ1bGVzLm90aGVyLmluZGVudENvZGVDb21wZW5zYXRpb24pO1xuICBpZiAobWF0Y2hJbmRlbnRUb0NvZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICBjb25zdCBpbmRlbnRUb0NvZGUgPSBtYXRjaEluZGVudFRvQ29kZVsxXTtcbiAgcmV0dXJuIHRleHQuc3BsaXQoXCJcXG5cIikubWFwKChub2RlKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hJbmRlbnRJbk5vZGUgPSBub2RlLm1hdGNoKHJ1bGVzLm90aGVyLmJlZ2lubmluZ1NwYWNlKTtcbiAgICBpZiAobWF0Y2hJbmRlbnRJbk5vZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBjb25zdCBbaW5kZW50SW5Ob2RlXSA9IG1hdGNoSW5kZW50SW5Ob2RlO1xuICAgIGlmIChpbmRlbnRJbk5vZGUubGVuZ3RoID49IGluZGVudFRvQ29kZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBub2RlLnNsaWNlKGluZGVudFRvQ29kZS5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSkuam9pbihcIlxcblwiKTtcbn1cbnZhciBfVG9rZW5pemVyID0gY2xhc3Mge1xuICBvcHRpb25zO1xuICBydWxlcztcbiAgLy8gc2V0IGJ5IHRoZSBsZXhlclxuICBsZXhlcjtcbiAgLy8gc2V0IGJ5IHRoZSBsZXhlclxuICBjb25zdHJ1Y3RvcihvcHRpb25zMikge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMyIHx8IF9kZWZhdWx0cztcbiAgfVxuICBzcGFjZShzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLm5ld2xpbmUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXAgJiYgY2FwWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3BhY2VcIixcbiAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGNvZGUoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5jb2RlLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UodGhpcy5ydWxlcy5vdGhlci5jb2RlUmVtb3ZlSW5kZW50LCBcIlwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY29kZVwiLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgY29kZUJsb2NrU3R5bGU6IFwiaW5kZW50ZWRcIixcbiAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpYyA/IHJ0cmltKHRleHQsIFwiXFxuXCIpIDogdGV4dFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZmVuY2VzKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZmVuY2VzLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCByYXcgPSBjYXBbMF07XG4gICAgICBjb25zdCB0ZXh0ID0gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIGNhcFszXSB8fCBcIlwiLCB0aGlzLnJ1bGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY29kZVwiLFxuICAgICAgICByYXcsXG4gICAgICAgIGxhbmc6IGNhcFsyXSA/IGNhcFsyXS50cmltKCkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgXCIkMVwiKSA6IGNhcFsyXSxcbiAgICAgICAgdGV4dFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaGVhZGluZyhzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhlYWRpbmcuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGxldCB0ZXh0ID0gY2FwWzJdLnRyaW0oKTtcbiAgICAgIGlmICh0aGlzLnJ1bGVzLm90aGVyLmVuZGluZ0hhc2gudGVzdCh0ZXh0KSkge1xuICAgICAgICBjb25zdCB0cmltbWVkID0gcnRyaW0odGV4dCwgXCIjXCIpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgdGV4dCA9IHRyaW1tZWQudHJpbSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0cmltbWVkIHx8IHRoaXMucnVsZXMub3RoZXIuZW5kaW5nU3BhY2VDaGFyLnRlc3QodHJpbW1lZCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgIHRleHQsXG4gICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUodGV4dClcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGhyKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHIuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiaHJcIixcbiAgICAgICAgcmF3OiBydHJpbShjYXBbMF0sIFwiXFxuXCIpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBibG9ja3F1b3RlKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suYmxvY2txdW90ZS5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgbGV0IGxpbmVzID0gcnRyaW0oY2FwWzBdLCBcIlxcblwiKS5zcGxpdChcIlxcblwiKTtcbiAgICAgIGxldCByYXcgPSBcIlwiO1xuICAgICAgbGV0IHRleHQgPSBcIlwiO1xuICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICB3aGlsZSAobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgaW5CbG9ja3F1b3RlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRMaW5lcyA9IFtdO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMucnVsZXMub3RoZXIuYmxvY2txdW90ZVN0YXJ0LnRlc3QobGluZXNbaV0pKSB7XG4gICAgICAgICAgICBjdXJyZW50TGluZXMucHVzaChsaW5lc1tpXSk7XG4gICAgICAgICAgICBpbkJsb2NrcXVvdGUgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWluQmxvY2txdW90ZSkge1xuICAgICAgICAgICAgY3VycmVudExpbmVzLnB1c2gobGluZXNbaV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGluZXMgPSBsaW5lcy5zbGljZShpKTtcbiAgICAgICAgY29uc3QgY3VycmVudFJhdyA9IGN1cnJlbnRMaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICBjb25zdCBjdXJyZW50VGV4dCA9IGN1cnJlbnRSYXcucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLmJsb2NrcXVvdGVTZXRleHRSZXBsYWNlLCBcIlxcbiAgICAkMVwiKS5yZXBsYWNlKHRoaXMucnVsZXMub3RoZXIuYmxvY2txdW90ZVNldGV4dFJlcGxhY2UyLCBcIlwiKTtcbiAgICAgICAgcmF3ID0gcmF3ID8gYCR7cmF3fVxuJHtjdXJyZW50UmF3fWAgOiBjdXJyZW50UmF3O1xuICAgICAgICB0ZXh0ID0gdGV4dCA/IGAke3RleHR9XG4ke2N1cnJlbnRUZXh0fWAgOiBjdXJyZW50VGV4dDtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5sZXhlci5zdGF0ZS50b3A7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sZXhlci5ibG9ja1Rva2VucyhjdXJyZW50VGV4dCwgdG9rZW5zLCB0cnVlKTtcbiAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSB0b3A7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0VG9rZW4gPSB0b2tlbnMuYXQoLTEpO1xuICAgICAgICBpZiAobGFzdFRva2VuPy50eXBlID09PSBcImNvZGVcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RUb2tlbj8udHlwZSA9PT0gXCJibG9ja3F1b3RlXCIpIHtcbiAgICAgICAgICBjb25zdCBvbGRUb2tlbiA9IGxhc3RUb2tlbjtcbiAgICAgICAgICBjb25zdCBuZXdUZXh0ID0gb2xkVG9rZW4ucmF3ICsgXCJcXG5cIiArIGxpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgY29uc3QgbmV3VG9rZW4gPSB0aGlzLmJsb2NrcXVvdGUobmV3VGV4dCk7XG4gICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSA9IG5ld1Rva2VuO1xuICAgICAgICAgIHJhdyA9IHJhdy5zdWJzdHJpbmcoMCwgcmF3Lmxlbmd0aCAtIG9sZFRva2VuLnJhdy5sZW5ndGgpICsgbmV3VG9rZW4ucmF3O1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCB0ZXh0Lmxlbmd0aCAtIG9sZFRva2VuLnRleHQubGVuZ3RoKSArIG5ld1Rva2VuLnRleHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFRva2VuPy50eXBlID09PSBcImxpc3RcIikge1xuICAgICAgICAgIGNvbnN0IG9sZFRva2VuID0gbGFzdFRva2VuO1xuICAgICAgICAgIGNvbnN0IG5ld1RleHQgPSBvbGRUb2tlbi5yYXcgKyBcIlxcblwiICsgbGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgICBjb25zdCBuZXdUb2tlbiA9IHRoaXMubGlzdChuZXdUZXh0KTtcbiAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdID0gbmV3VG9rZW47XG4gICAgICAgICAgcmF3ID0gcmF3LnN1YnN0cmluZygwLCByYXcubGVuZ3RoIC0gbGFzdFRva2VuLnJhdy5sZW5ndGgpICsgbmV3VG9rZW4ucmF3O1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCB0ZXh0Lmxlbmd0aCAtIG9sZFRva2VuLnJhdy5sZW5ndGgpICsgbmV3VG9rZW4ucmF3O1xuICAgICAgICAgIGxpbmVzID0gbmV3VGV4dC5zdWJzdHJpbmcodG9rZW5zLmF0KC0xKS5yYXcubGVuZ3RoKS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJibG9ja3F1b3RlXCIsXG4gICAgICAgIHJhdyxcbiAgICAgICAgdG9rZW5zLFxuICAgICAgICB0ZXh0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBsaXN0KHNyYykge1xuICAgIGxldCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxpc3QuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGxldCBidWxsID0gY2FwWzFdLnRyaW0oKTtcbiAgICAgIGNvbnN0IGlzb3JkZXJlZCA9IGJ1bGwubGVuZ3RoID4gMTtcbiAgICAgIGNvbnN0IGxpc3QyID0ge1xuICAgICAgICB0eXBlOiBcImxpc3RcIixcbiAgICAgICAgcmF3OiBcIlwiLFxuICAgICAgICBvcmRlcmVkOiBpc29yZGVyZWQsXG4gICAgICAgIHN0YXJ0OiBpc29yZGVyZWQgPyArYnVsbC5zbGljZSgwLCAtMSkgOiBcIlwiLFxuICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgIGl0ZW1zOiBbXVxuICAgICAgfTtcbiAgICAgIGJ1bGwgPSBpc29yZGVyZWQgPyBgXFxcXGR7MSw5fVxcXFwke2J1bGwuc2xpY2UoLTEpfWAgOiBgXFxcXCR7YnVsbH1gO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICBidWxsID0gaXNvcmRlcmVkID8gYnVsbCA6IFwiWyorLV1cIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1SZWdleCA9IHRoaXMucnVsZXMub3RoZXIubGlzdEl0ZW1SZWdleChidWxsKTtcbiAgICAgIGxldCBlbmRzV2l0aEJsYW5rTGluZSA9IGZhbHNlO1xuICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICBsZXQgZW5kRWFybHkgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJhdyA9IFwiXCI7XG4gICAgICAgIGxldCBpdGVtQ29udGVudHMgPSBcIlwiO1xuICAgICAgICBpZiAoIShjYXAgPSBpdGVtUmVnZXguZXhlYyhzcmMpKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJ1bGVzLmJsb2NrLmhyLnRlc3Qoc3JjKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJhdyA9IGNhcFswXTtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhyYXcubGVuZ3RoKTtcbiAgICAgICAgbGV0IGxpbmUgPSBjYXBbMl0uc3BsaXQoXCJcXG5cIiwgMSlbMF0ucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLmxpc3RSZXBsYWNlVGFicywgKHQpID0+IFwiIFwiLnJlcGVhdCgzICogdC5sZW5ndGgpKTtcbiAgICAgICAgbGV0IG5leHRMaW5lID0gc3JjLnNwbGl0KFwiXFxuXCIsIDEpWzBdO1xuICAgICAgICBsZXQgYmxhbmtMaW5lID0gIWxpbmUudHJpbSgpO1xuICAgICAgICBsZXQgaW5kZW50ID0gMDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgIGluZGVudCA9IDI7XG4gICAgICAgICAgaXRlbUNvbnRlbnRzID0gbGluZS50cmltU3RhcnQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChibGFua0xpbmUpIHtcbiAgICAgICAgICBpbmRlbnQgPSBjYXBbMV0ubGVuZ3RoICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRlbnQgPSBjYXBbMl0uc2VhcmNoKHRoaXMucnVsZXMub3RoZXIubm9uU3BhY2VDaGFyKTtcbiAgICAgICAgICBpbmRlbnQgPSBpbmRlbnQgPiA0ID8gMSA6IGluZGVudDtcbiAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgaW5kZW50ICs9IGNhcFsxXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsYW5rTGluZSAmJiB0aGlzLnJ1bGVzLm90aGVyLmJsYW5rTGluZS50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgIHJhdyArPSBuZXh0TGluZSArIFwiXFxuXCI7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhuZXh0TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICBlbmRFYXJseSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbmRFYXJseSkge1xuICAgICAgICAgIGNvbnN0IG5leHRCdWxsZXRSZWdleCA9IHRoaXMucnVsZXMub3RoZXIubmV4dEJ1bGxldFJlZ2V4KGluZGVudCk7XG4gICAgICAgICAgY29uc3QgaHJSZWdleCA9IHRoaXMucnVsZXMub3RoZXIuaHJSZWdleChpbmRlbnQpO1xuICAgICAgICAgIGNvbnN0IGZlbmNlc0JlZ2luUmVnZXggPSB0aGlzLnJ1bGVzLm90aGVyLmZlbmNlc0JlZ2luUmVnZXgoaW5kZW50KTtcbiAgICAgICAgICBjb25zdCBoZWFkaW5nQmVnaW5SZWdleCA9IHRoaXMucnVsZXMub3RoZXIuaGVhZGluZ0JlZ2luUmVnZXgoaW5kZW50KTtcbiAgICAgICAgICBjb25zdCBodG1sQmVnaW5SZWdleCA9IHRoaXMucnVsZXMub3RoZXIuaHRtbEJlZ2luUmVnZXgoaW5kZW50KTtcbiAgICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICBjb25zdCByYXdMaW5lID0gc3JjLnNwbGl0KFwiXFxuXCIsIDEpWzBdO1xuICAgICAgICAgICAgbGV0IG5leHRMaW5lV2l0aG91dFRhYnM7XG4gICAgICAgICAgICBuZXh0TGluZSA9IHJhd0xpbmU7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgIG5leHRMaW5lID0gbmV4dExpbmUucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLmxpc3RSZXBsYWNlTmVzdGluZywgXCIgIFwiKTtcbiAgICAgICAgICAgICAgbmV4dExpbmVXaXRob3V0VGFicyA9IG5leHRMaW5lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV4dExpbmVXaXRob3V0VGFicyA9IG5leHRMaW5lLnJlcGxhY2UodGhpcy5ydWxlcy5vdGhlci50YWJDaGFyR2xvYmFsLCBcIiAgICBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmVuY2VzQmVnaW5SZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWFkaW5nQmVnaW5SZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChodG1sQmVnaW5SZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0QnVsbGV0UmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaHJSZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0TGluZVdpdGhvdXRUYWJzLnNlYXJjaCh0aGlzLnJ1bGVzLm90aGVyLm5vblNwYWNlQ2hhcikgPj0gaW5kZW50IHx8ICFuZXh0TGluZS50cmltKCkpIHtcbiAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzICs9IFwiXFxuXCIgKyBuZXh0TGluZVdpdGhvdXRUYWJzLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxpbmUucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLnRhYkNoYXJHbG9iYWwsIFwiICAgIFwiKS5zZWFyY2godGhpcy5ydWxlcy5vdGhlci5ub25TcGFjZUNoYXIpID49IDQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmVuY2VzQmVnaW5SZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaHJSZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzICs9IFwiXFxuXCIgKyBuZXh0TGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYmxhbmtMaW5lICYmICFuZXh0TGluZS50cmltKCkpIHtcbiAgICAgICAgICAgICAgYmxhbmtMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhdyArPSByYXdMaW5lICsgXCJcXG5cIjtcbiAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgIGxpbmUgPSBuZXh0TGluZVdpdGhvdXRUYWJzLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbGlzdDIubG9vc2UpIHtcbiAgICAgICAgICBpZiAoZW5kc1dpdGhCbGFua0xpbmUpIHtcbiAgICAgICAgICAgIGxpc3QyLmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucnVsZXMub3RoZXIuZG91YmxlQmxhbmtMaW5lLnRlc3QocmF3KSkge1xuICAgICAgICAgICAgZW5kc1dpdGhCbGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaXN0YXNrID0gbnVsbDtcbiAgICAgICAgbGV0IGlzY2hlY2tlZDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICAgICAgICBpc3Rhc2sgPSB0aGlzLnJ1bGVzLm90aGVyLmxpc3RJc1Rhc2suZXhlYyhpdGVtQ29udGVudHMpO1xuICAgICAgICAgIGlmIChpc3Rhc2spIHtcbiAgICAgICAgICAgIGlzY2hlY2tlZCA9IGlzdGFza1swXSAhPT0gXCJbIF0gXCI7XG4gICAgICAgICAgICBpdGVtQ29udGVudHMgPSBpdGVtQ29udGVudHMucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLmxpc3RSZXBsYWNlVGFzaywgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpc3QyLml0ZW1zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwibGlzdF9pdGVtXCIsXG4gICAgICAgICAgcmF3LFxuICAgICAgICAgIHRhc2s6ICEhaXN0YXNrLFxuICAgICAgICAgIGNoZWNrZWQ6IGlzY2hlY2tlZCxcbiAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgdGV4dDogaXRlbUNvbnRlbnRzLFxuICAgICAgICAgIHRva2VuczogW11cbiAgICAgICAgfSk7XG4gICAgICAgIGxpc3QyLnJhdyArPSByYXc7XG4gICAgICB9XG4gICAgICBjb25zdCBsYXN0SXRlbSA9IGxpc3QyLml0ZW1zLmF0KC0xKTtcbiAgICAgIGlmIChsYXN0SXRlbSkge1xuICAgICAgICBsYXN0SXRlbS5yYXcgPSBsYXN0SXRlbS5yYXcudHJpbUVuZCgpO1xuICAgICAgICBsYXN0SXRlbS50ZXh0ID0gbGFzdEl0ZW0udGV4dC50cmltRW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsaXN0Mi5yYXcgPSBsaXN0Mi5yYXcudHJpbUVuZCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Mi5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IGZhbHNlO1xuICAgICAgICBsaXN0Mi5pdGVtc1tpXS50b2tlbnMgPSB0aGlzLmxleGVyLmJsb2NrVG9rZW5zKGxpc3QyLml0ZW1zW2ldLnRleHQsIFtdKTtcbiAgICAgICAgaWYgKCFsaXN0Mi5sb29zZSkge1xuICAgICAgICAgIGNvbnN0IHNwYWNlcnMgPSBsaXN0Mi5pdGVtc1tpXS50b2tlbnMuZmlsdGVyKCh0KSA9PiB0LnR5cGUgPT09IFwic3BhY2VcIik7XG4gICAgICAgICAgY29uc3QgaGFzTXVsdGlwbGVMaW5lQnJlYWtzID0gc3BhY2Vycy5sZW5ndGggPiAwICYmIHNwYWNlcnMuc29tZSgodCkgPT4gdGhpcy5ydWxlcy5vdGhlci5hbnlMaW5lLnRlc3QodC5yYXcpKTtcbiAgICAgICAgICBsaXN0Mi5sb29zZSA9IGhhc011bHRpcGxlTGluZUJyZWFrcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxpc3QyLmxvb3NlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdDIuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsaXN0Mi5pdGVtc1tpXS5sb29zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0MjtcbiAgICB9XG4gIH1cbiAgaHRtbChzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmh0bWwuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICB0eXBlOiBcImh0bWxcIixcbiAgICAgICAgYmxvY2s6IHRydWUsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICBwcmU6IGNhcFsxXSA9PT0gXCJwcmVcIiB8fCBjYXBbMV0gPT09IFwic2NyaXB0XCIgfHwgY2FwWzFdID09PSBcInN0eWxlXCIsXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gIH1cbiAgZGVmKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZGVmLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0YWcyID0gY2FwWzFdLnRvTG93ZXJDYXNlKCkucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLm11bHRpcGxlU3BhY2VHbG9iYWwsIFwiIFwiKTtcbiAgICAgIGNvbnN0IGhyZWYgPSBjYXBbMl0gPyBjYXBbMl0ucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLmhyZWZCcmFja2V0cywgXCIkMVwiKS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLCBcIiQxXCIpIDogXCJcIjtcbiAgICAgIGNvbnN0IHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnN1YnN0cmluZygxLCBjYXBbM10ubGVuZ3RoIC0gMSkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgXCIkMVwiKSA6IGNhcFszXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZGVmXCIsXG4gICAgICAgIHRhZzogdGFnMixcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIGhyZWYsXG4gICAgICAgIHRpdGxlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICB0YWJsZShzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRhYmxlLmV4ZWMoc3JjKTtcbiAgICBpZiAoIWNhcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucnVsZXMub3RoZXIudGFibGVEZWxpbWl0ZXIudGVzdChjYXBbMl0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSBzcGxpdENlbGxzKGNhcFsxXSk7XG4gICAgY29uc3QgYWxpZ25zID0gY2FwWzJdLnJlcGxhY2UodGhpcy5ydWxlcy5vdGhlci50YWJsZUFsaWduQ2hhcnMsIFwiXCIpLnNwbGl0KFwifFwiKTtcbiAgICBjb25zdCByb3dzID0gY2FwWzNdPy50cmltKCkgPyBjYXBbM10ucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLnRhYmxlUm93QmxhbmtMaW5lLCBcIlwiKS5zcGxpdChcIlxcblwiKSA6IFtdO1xuICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgICByYXc6IGNhcFswXSxcbiAgICAgIGhlYWRlcjogW10sXG4gICAgICBhbGlnbjogW10sXG4gICAgICByb3dzOiBbXVxuICAgIH07XG4gICAgaWYgKGhlYWRlcnMubGVuZ3RoICE9PSBhbGlnbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgYWxpZ24gb2YgYWxpZ25zKSB7XG4gICAgICBpZiAodGhpcy5ydWxlcy5vdGhlci50YWJsZUFsaWduUmlnaHQudGVzdChhbGlnbikpIHtcbiAgICAgICAgaXRlbS5hbGlnbi5wdXNoKFwicmlnaHRcIik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucnVsZXMub3RoZXIudGFibGVBbGlnbkNlbnRlci50ZXN0KGFsaWduKSkge1xuICAgICAgICBpdGVtLmFsaWduLnB1c2goXCJjZW50ZXJcIik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucnVsZXMub3RoZXIudGFibGVBbGlnbkxlZnQudGVzdChhbGlnbikpIHtcbiAgICAgICAgaXRlbS5hbGlnbi5wdXNoKFwibGVmdFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW0uYWxpZ24ucHVzaChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpdGVtLmhlYWRlci5wdXNoKHtcbiAgICAgICAgdGV4dDogaGVhZGVyc1tpXSxcbiAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShoZWFkZXJzW2ldKSxcbiAgICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgICBhbGlnbjogaXRlbS5hbGlnbltpXVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgIGl0ZW0ucm93cy5wdXNoKHNwbGl0Q2VsbHMocm93LCBpdGVtLmhlYWRlci5sZW5ndGgpLm1hcCgoY2VsbCwgaSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRleHQ6IGNlbGwsXG4gICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShjZWxsKSxcbiAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxuICAgICAgICAgIGFsaWduOiBpdGVtLmFsaWduW2ldXG4gICAgICAgIH07XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9XG4gIGxoZWFkaW5nKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGhlYWRpbmcuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgZGVwdGg6IGNhcFsyXS5jaGFyQXQoMCkgPT09IFwiPVwiID8gMSA6IDIsXG4gICAgICAgIHRleHQ6IGNhcFsxXSxcbiAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShjYXBbMV0pXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBwYXJhZ3JhcGgoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5wYXJhZ3JhcGguZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGNvbnN0IHRleHQgPSBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gXCJcXG5cIiA/IGNhcFsxXS5zbGljZSgwLCAtMSkgOiBjYXBbMV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInBhcmFncmFwaFwiLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZSh0ZXh0KVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgdGV4dChzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRleHQuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dDogY2FwWzBdLFxuICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFswXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGVzY2FwZShzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZXNjYXBlXCIsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0OiBjYXBbMV1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHRhZyhzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50YWcuZXhlYyhzcmMpO1xuICAgIGlmIChjYXApIHtcbiAgICAgIGlmICghdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgJiYgdGhpcy5ydWxlcy5vdGhlci5zdGFydEFUYWcudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgJiYgdGhpcy5ydWxlcy5vdGhlci5lbmRBVGFnLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgJiYgdGhpcy5ydWxlcy5vdGhlci5zdGFydFByZVNjcmlwdFRhZy50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrICYmIHRoaXMucnVsZXMub3RoZXIuZW5kUHJlU2NyaXB0VGFnLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiaHRtbFwiLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgaW5MaW5rOiB0aGlzLmxleGVyLnN0YXRlLmluTGluayxcbiAgICAgICAgaW5SYXdCbG9jazogdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrLFxuICAgICAgICBibG9jazogZmFsc2UsXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgbGluayhzcmMpIHtcbiAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5saW5rLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBjb25zdCB0cmltbWVkVXJsID0gY2FwWzJdLnRyaW0oKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnBlZGFudGljICYmIHRoaXMucnVsZXMub3RoZXIuc3RhcnRBbmdsZUJyYWNrZXQudGVzdCh0cmltbWVkVXJsKSkge1xuICAgICAgICBpZiAoIXRoaXMucnVsZXMub3RoZXIuZW5kQW5nbGVCcmFja2V0LnRlc3QodHJpbW1lZFVybCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnRyaW1TbGFzaCA9IHJ0cmltKHRyaW1tZWRVcmwuc2xpY2UoMCwgLTEpLCBcIlxcXFxcIik7XG4gICAgICAgIGlmICgodHJpbW1lZFVybC5sZW5ndGggLSBydHJpbVNsYXNoLmxlbmd0aCkgJSAyID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsYXN0UGFyZW5JbmRleCA9IGZpbmRDbG9zaW5nQnJhY2tldChjYXBbMl0sIFwiKClcIik7XG4gICAgICAgIGlmIChsYXN0UGFyZW5JbmRleCA9PT0gLTIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQYXJlbkluZGV4ID4gLTEpIHtcbiAgICAgICAgICBjb25zdCBzdGFydCA9IGNhcFswXS5pbmRleE9mKFwiIVwiKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgIGNvbnN0IGxpbmtMZW4gPSBzdGFydCArIGNhcFsxXS5sZW5ndGggKyBsYXN0UGFyZW5JbmRleDtcbiAgICAgICAgICBjYXBbMl0gPSBjYXBbMl0uc3Vic3RyaW5nKDAsIGxhc3RQYXJlbkluZGV4KTtcbiAgICAgICAgICBjYXBbMF0gPSBjYXBbMF0uc3Vic3RyaW5nKDAsIGxpbmtMZW4pLnRyaW0oKTtcbiAgICAgICAgICBjYXBbM10gPSBcIlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgaHJlZiA9IGNhcFsyXTtcbiAgICAgIGxldCB0aXRsZSA9IFwiXCI7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgIGNvbnN0IGxpbmsyID0gdGhpcy5ydWxlcy5vdGhlci5wZWRhbnRpY0hyZWZUaXRsZS5leGVjKGhyZWYpO1xuICAgICAgICBpZiAobGluazIpIHtcbiAgICAgICAgICBocmVmID0gbGluazJbMV07XG4gICAgICAgICAgdGl0bGUgPSBsaW5rMlszXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGl0bGUgPSBjYXBbM10gPyBjYXBbM10uc2xpY2UoMSwgLTEpIDogXCJcIjtcbiAgICAgIH1cbiAgICAgIGhyZWYgPSBocmVmLnRyaW0oKTtcbiAgICAgIGlmICh0aGlzLnJ1bGVzLm90aGVyLnN0YXJ0QW5nbGVCcmFja2V0LnRlc3QoaHJlZikpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYyAmJiAhdGhpcy5ydWxlcy5vdGhlci5lbmRBbmdsZUJyYWNrZXQudGVzdCh0cmltbWVkVXJsKSkge1xuICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgIGhyZWY6IGhyZWYgPyBocmVmLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24sIFwiJDFcIikgOiBocmVmLFxuICAgICAgICB0aXRsZTogdGl0bGUgPyB0aXRsZS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLCBcIiQxXCIpIDogdGl0bGVcbiAgICAgIH0sIGNhcFswXSwgdGhpcy5sZXhlciwgdGhpcy5ydWxlcyk7XG4gICAgfVxuICB9XG4gIHJlZmxpbmsoc3JjLCBsaW5rcykge1xuICAgIGxldCBjYXA7XG4gICAgaWYgKChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5yZWZsaW5rLmV4ZWMoc3JjKSkgfHwgKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICBjb25zdCBsaW5rU3RyaW5nID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UodGhpcy5ydWxlcy5vdGhlci5tdWx0aXBsZVNwYWNlR2xvYmFsLCBcIiBcIik7XG4gICAgICBjb25zdCBsaW5rMiA9IGxpbmtzW2xpbmtTdHJpbmcudG9Mb3dlckNhc2UoKV07XG4gICAgICBpZiAoIWxpbmsyKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIGxpbmsyLCBjYXBbMF0sIHRoaXMubGV4ZXIsIHRoaXMucnVsZXMpO1xuICAgIH1cbiAgfVxuICBlbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIgPSBcIlwiKSB7XG4gICAgbGV0IG1hdGNoID0gdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmdMRGVsaW0uZXhlYyhzcmMpO1xuICAgIGlmICghbWF0Y2gpIHJldHVybjtcbiAgICBpZiAobWF0Y2hbM10gJiYgcHJldkNoYXIubWF0Y2godGhpcy5ydWxlcy5vdGhlci51bmljb2RlQWxwaGFOdW1lcmljKSkgcmV0dXJuO1xuICAgIGNvbnN0IG5leHRDaGFyID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgXCJcIjtcbiAgICBpZiAoIW5leHRDaGFyIHx8ICFwcmV2Q2hhciB8fCB0aGlzLnJ1bGVzLmlubGluZS5wdW5jdHVhdGlvbi5leGVjKHByZXZDaGFyKSkge1xuICAgICAgY29uc3QgbExlbmd0aCA9IFsuLi5tYXRjaFswXV0ubGVuZ3RoIC0gMTtcbiAgICAgIGxldCByRGVsaW0sIHJMZW5ndGgsIGRlbGltVG90YWwgPSBsTGVuZ3RoLCBtaWREZWxpbVRvdGFsID0gMDtcbiAgICAgIGNvbnN0IGVuZFJlZyA9IG1hdGNoWzBdWzBdID09PSBcIipcIiA/IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nUkRlbGltQXN0IDogdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmdSRGVsaW1VbmQ7XG4gICAgICBlbmRSZWcubGFzdEluZGV4ID0gMDtcbiAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgtMSAqIHNyYy5sZW5ndGggKyBsTGVuZ3RoKTtcbiAgICAgIHdoaWxlICgobWF0Y2ggPSBlbmRSZWcuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgIHJEZWxpbSA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8IG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IG1hdGNoWzZdO1xuICAgICAgICBpZiAoIXJEZWxpbSkgY29udGludWU7XG4gICAgICAgIHJMZW5ndGggPSBbLi4uckRlbGltXS5sZW5ndGg7XG4gICAgICAgIGlmIChtYXRjaFszXSB8fCBtYXRjaFs0XSkge1xuICAgICAgICAgIGRlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFs1XSB8fCBtYXRjaFs2XSkge1xuICAgICAgICAgIGlmIChsTGVuZ3RoICUgMyAmJiAhKChsTGVuZ3RoICsgckxlbmd0aCkgJSAzKSkge1xuICAgICAgICAgICAgbWlkRGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlbGltVG90YWwgLT0gckxlbmd0aDtcbiAgICAgICAgaWYgKGRlbGltVG90YWwgPiAwKSBjb250aW51ZTtcbiAgICAgICAgckxlbmd0aCA9IE1hdGgubWluKHJMZW5ndGgsIHJMZW5ndGggKyBkZWxpbVRvdGFsICsgbWlkRGVsaW1Ub3RhbCk7XG4gICAgICAgIGNvbnN0IGxhc3RDaGFyTGVuZ3RoID0gWy4uLm1hdGNoWzBdXVswXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJhdyA9IHNyYy5zbGljZSgwLCBsTGVuZ3RoICsgbWF0Y2guaW5kZXggKyBsYXN0Q2hhckxlbmd0aCArIHJMZW5ndGgpO1xuICAgICAgICBpZiAoTWF0aC5taW4obExlbmd0aCwgckxlbmd0aCkgJSAyKSB7XG4gICAgICAgICAgY29uc3QgdGV4dDIgPSByYXcuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImVtXCIsXG4gICAgICAgICAgICByYXcsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dDIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0ID0gcmF3LnNsaWNlKDIsIC0yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInN0cm9uZ1wiLFxuICAgICAgICAgIHJhdyxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29kZXNwYW4oc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuY29kZS5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgbGV0IHRleHQgPSBjYXBbMl0ucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLm5ld0xpbmVDaGFyR2xvYmFsLCBcIiBcIik7XG4gICAgICBjb25zdCBoYXNOb25TcGFjZUNoYXJzID0gdGhpcy5ydWxlcy5vdGhlci5ub25TcGFjZUNoYXIudGVzdCh0ZXh0KTtcbiAgICAgIGNvbnN0IGhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzID0gdGhpcy5ydWxlcy5vdGhlci5zdGFydGluZ1NwYWNlQ2hhci50ZXN0KHRleHQpICYmIHRoaXMucnVsZXMub3RoZXIuZW5kaW5nU3BhY2VDaGFyLnRlc3QodGV4dCk7XG4gICAgICBpZiAoaGFzTm9uU3BhY2VDaGFycyAmJiBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcykge1xuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY29kZXNwYW5cIixcbiAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgIHRleHRcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGJyKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmJyLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImJyXCIsXG4gICAgICAgIHJhdzogY2FwWzBdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBkZWwoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZGVsLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImRlbFwiLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dDogY2FwWzJdLFxuICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKGNhcFsyXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGF1dG9saW5rKHNyYykge1xuICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmF1dG9saW5rLmV4ZWMoc3JjKTtcbiAgICBpZiAoY2FwKSB7XG4gICAgICBsZXQgdGV4dCwgaHJlZjtcbiAgICAgIGlmIChjYXBbMl0gPT09IFwiQFwiKSB7XG4gICAgICAgIHRleHQgPSBjYXBbMV07XG4gICAgICAgIGhyZWYgPSBcIm1haWx0bzpcIiArIHRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gY2FwWzFdO1xuICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibGlua1wiLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgaHJlZixcbiAgICAgICAgdG9rZW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICB1cmwoc3JjKSB7XG4gICAgbGV0IGNhcDtcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgbGV0IHRleHQsIGhyZWY7XG4gICAgICBpZiAoY2FwWzJdID09PSBcIkBcIikge1xuICAgICAgICB0ZXh0ID0gY2FwWzBdO1xuICAgICAgICBocmVmID0gXCJtYWlsdG86XCIgKyB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHByZXZDYXBaZXJvO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcHJldkNhcFplcm8gPSBjYXBbMF07XG4gICAgICAgICAgY2FwWzBdID0gdGhpcy5ydWxlcy5pbmxpbmUuX2JhY2twZWRhbC5leGVjKGNhcFswXSk/LlswXSA/PyBcIlwiO1xuICAgICAgICB9IHdoaWxlIChwcmV2Q2FwWmVybyAhPT0gY2FwWzBdKTtcbiAgICAgICAgdGV4dCA9IGNhcFswXTtcbiAgICAgICAgaWYgKGNhcFsxXSA9PT0gXCJ3d3cuXCIpIHtcbiAgICAgICAgICBocmVmID0gXCJodHRwOi8vXCIgKyBjYXBbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaHJlZiA9IGNhcFswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJsaW5rXCIsXG4gICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICB0ZXh0LFxuICAgICAgICBocmVmLFxuICAgICAgICB0b2tlbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGlubGluZVRleHQoc3JjKSB7XG4gICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGV4dC5leGVjKHNyYyk7XG4gICAgaWYgKGNhcCkge1xuICAgICAgY29uc3QgZXNjYXBlZCA9IHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jaztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgdGV4dDogY2FwWzBdLFxuICAgICAgICBlc2NhcGVkXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL0xleGVyLnRzXG52YXIgX0xleGVyID0gY2xhc3MgX19MZXhlciB7XG4gIHRva2VucztcbiAgb3B0aW9ucztcbiAgc3RhdGU7XG4gIHRva2VuaXplcjtcbiAgaW5saW5lUXVldWU7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMyKSB7XG4gICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICB0aGlzLnRva2Vucy5saW5rcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMyIHx8IF9kZWZhdWx0cztcbiAgICB0aGlzLm9wdGlvbnMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplciB8fCBuZXcgX1Rva2VuaXplcigpO1xuICAgIHRoaXMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplcjtcbiAgICB0aGlzLnRva2VuaXplci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMudG9rZW5pemVyLmxleGVyID0gdGhpcztcbiAgICB0aGlzLmlubGluZVF1ZXVlID0gW107XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGluTGluazogZmFsc2UsXG4gICAgICBpblJhd0Jsb2NrOiBmYWxzZSxcbiAgICAgIHRvcDogdHJ1ZVxuICAgIH07XG4gICAgY29uc3QgcnVsZXMgPSB7XG4gICAgICBvdGhlcixcbiAgICAgIGJsb2NrOiBibG9jay5ub3JtYWwsXG4gICAgICBpbmxpbmU6IGlubGluZS5ub3JtYWxcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2sucGVkYW50aWM7XG4gICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUucGVkYW50aWM7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICBydWxlcy5ibG9jayA9IGJsb2NrLmdmbTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnJlYWtzKSB7XG4gICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5icmVha3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUuZ2ZtO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRva2VuaXplci5ydWxlcyA9IHJ1bGVzO1xuICB9XG4gIC8qKlxuICAgKiBFeHBvc2UgUnVsZXNcbiAgICovXG4gIHN0YXRpYyBnZXQgcnVsZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJsb2NrLFxuICAgICAgaW5saW5lXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU3RhdGljIExleCBNZXRob2RcbiAgICovXG4gIHN0YXRpYyBsZXgoc3JjLCBvcHRpb25zMikge1xuICAgIGNvbnN0IGxleGVyMiA9IG5ldyBfX0xleGVyKG9wdGlvbnMyKTtcbiAgICByZXR1cm4gbGV4ZXIyLmxleChzcmMpO1xuICB9XG4gIC8qKlxuICAgKiBTdGF0aWMgTGV4IElubGluZSBNZXRob2RcbiAgICovXG4gIHN0YXRpYyBsZXhJbmxpbmUoc3JjLCBvcHRpb25zMikge1xuICAgIGNvbnN0IGxleGVyMiA9IG5ldyBfX0xleGVyKG9wdGlvbnMyKTtcbiAgICByZXR1cm4gbGV4ZXIyLmlubGluZVRva2VucyhzcmMpO1xuICB9XG4gIC8qKlxuICAgKiBQcmVwcm9jZXNzaW5nXG4gICAqL1xuICBsZXgoc3JjKSB7XG4gICAgc3JjID0gc3JjLnJlcGxhY2Uob3RoZXIuY2FycmlhZ2VSZXR1cm4sIFwiXFxuXCIpO1xuICAgIHRoaXMuYmxvY2tUb2tlbnMoc3JjLCB0aGlzLnRva2Vucyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlubGluZVF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBuZXh0ID0gdGhpcy5pbmxpbmVRdWV1ZVtpXTtcbiAgICAgIHRoaXMuaW5saW5lVG9rZW5zKG5leHQuc3JjLCBuZXh0LnRva2Vucyk7XG4gICAgfVxuICAgIHRoaXMuaW5saW5lUXVldWUgPSBbXTtcbiAgICByZXR1cm4gdGhpcy50b2tlbnM7XG4gIH1cbiAgYmxvY2tUb2tlbnMoc3JjLCB0b2tlbnMgPSBbXSwgbGFzdFBhcmFncmFwaENsaXBwZWQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKG90aGVyLnRhYkNoYXJHbG9iYWwsIFwiICAgIFwiKS5yZXBsYWNlKG90aGVyLnNwYWNlTGluZSwgXCJcIik7XG4gICAgfVxuICAgIHdoaWxlIChzcmMpIHtcbiAgICAgIGxldCB0b2tlbjtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucz8uYmxvY2s/LnNvbWUoKGV4dFRva2VuaXplcikgPT4ge1xuICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7IGxleGVyOiB0aGlzIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3BhY2Uoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBsYXN0VG9rZW4gPSB0b2tlbnMuYXQoLTEpO1xuICAgICAgICBpZiAodG9rZW4ucmF3Lmxlbmd0aCA9PT0gMSAmJiBsYXN0VG9rZW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gXCJcXG5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2RlKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGFzdFRva2VuID0gdG9rZW5zLmF0KC0xKTtcbiAgICAgICAgaWYgKGxhc3RUb2tlbj8udHlwZSA9PT0gXCJwYXJhZ3JhcGhcIiB8fCBsYXN0VG9rZW4/LnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSBcIlxcblwiICsgdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IFwiXFxuXCIgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUuYXQoLTEpLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmZlbmNlcyhzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5oZWFkaW5nKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhyKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJsb2NrcXVvdGUoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGlzdChzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5odG1sKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlZihzcmMpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGxhc3RUb2tlbiA9IHRva2Vucy5hdCgtMSk7XG4gICAgICAgIGlmIChsYXN0VG9rZW4/LnR5cGUgPT09IFwicGFyYWdyYXBoXCIgfHwgbGFzdFRva2VuPy50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gXCJcXG5cIiArIHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSBcIlxcblwiICsgdG9rZW4ucmF3O1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUuYXQoLTEpLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddKSB7XG4gICAgICAgICAgdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSA9IHtcbiAgICAgICAgICAgIGhyZWY6IHRva2VuLmhyZWYsXG4gICAgICAgICAgICB0aXRsZTogdG9rZW4udGl0bGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGFibGUoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGhlYWRpbmcoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGN1dFNyYyA9IHNyYztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucz8uc3RhcnRCbG9jaykge1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICBjb25zdCB0ZW1wU3JjID0gc3JjLnNsaWNlKDEpO1xuICAgICAgICBsZXQgdGVtcFN0YXJ0O1xuICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrLmZvckVhY2goKGdldFN0YXJ0SW5kZXgpID0+IHtcbiAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoeyBsZXhlcjogdGhpcyB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gXCJudW1iZXJcIiAmJiB0ZW1wU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIHRlbXBTdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBJbmZpbml0eSAmJiBzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICBjdXRTcmMgPSBzcmMuc3Vic3RyaW5nKDAsIHN0YXJ0SW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhdGUudG9wICYmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnBhcmFncmFwaChjdXRTcmMpKSkge1xuICAgICAgICBjb25zdCBsYXN0VG9rZW4gPSB0b2tlbnMuYXQoLTEpO1xuICAgICAgICBpZiAobGFzdFBhcmFncmFwaENsaXBwZWQgJiYgbGFzdFRva2VuPy50eXBlID09PSBcInBhcmFncmFwaFwiKSB7XG4gICAgICAgICAgbGFzdFRva2VuLnJhdyArPSBcIlxcblwiICsgdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IFwiXFxuXCIgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUucG9wKCk7XG4gICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5hdCgtMSkuc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQYXJhZ3JhcGhDbGlwcGVkID0gY3V0U3JjLmxlbmd0aCAhPT0gc3JjLmxlbmd0aDtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50ZXh0KHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGFzdFRva2VuID0gdG9rZW5zLmF0KC0xKTtcbiAgICAgICAgaWYgKGxhc3RUb2tlbj8udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IFwiXFxuXCIgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gXCJcXG5cIiArIHRva2VuLnRleHQ7XG4gICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wb3AoKTtcbiAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLmF0KC0xKS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoc3JjKSB7XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IFwiSW5maW5pdGUgbG9vcCBvbiBieXRlOiBcIiArIHNyYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgcmV0dXJuIHRva2VucztcbiAgfVxuICBpbmxpbmUoc3JjLCB0b2tlbnMgPSBbXSkge1xuICAgIHRoaXMuaW5saW5lUXVldWUucHVzaCh7IHNyYywgdG9rZW5zIH0pO1xuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cbiAgLyoqXG4gICAqIExleGluZy9Db21waWxpbmdcbiAgICovXG4gIGlubGluZVRva2VucyhzcmMsIHRva2VucyA9IFtdKSB7XG4gICAgbGV0IG1hc2tlZFNyYyA9IHNyYztcbiAgICBsZXQgbWF0Y2ggPSBudWxsO1xuICAgIGlmICh0aGlzLnRva2Vucy5saW5rcykge1xuICAgICAgY29uc3QgbGlua3MgPSBPYmplY3Qua2V5cyh0aGlzLnRva2Vucy5saW5rcyk7XG4gICAgICBpZiAobGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLnJlZmxpbmtTZWFyY2guZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGxpbmtzLmluY2x1ZGVzKG1hdGNoWzBdLnNsaWNlKG1hdGNoWzBdLmxhc3RJbmRleE9mKFwiW1wiKSArIDEsIC0xKSkpIHtcbiAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyBcIltcIiArIFwiYVwiLnJlcGVhdChtYXRjaFswXS5sZW5ndGggLSAyKSArIFwiXVwiICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmxhc3RJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24uZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgXCIrK1wiICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbi5sYXN0SW5kZXgpO1xuICAgIH1cbiAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyBcIltcIiArIFwiYVwiLnJlcGVhdChtYXRjaFswXS5sZW5ndGggLSAyKSArIFwiXVwiICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5ibG9ja1NraXAubGFzdEluZGV4KTtcbiAgICB9XG4gICAgbGV0IGtlZXBQcmV2Q2hhciA9IGZhbHNlO1xuICAgIGxldCBwcmV2Q2hhciA9IFwiXCI7XG4gICAgd2hpbGUgKHNyYykge1xuICAgICAgaWYgKCFrZWVwUHJldkNoYXIpIHtcbiAgICAgICAgcHJldkNoYXIgPSBcIlwiO1xuICAgICAgfVxuICAgICAga2VlcFByZXZDaGFyID0gZmFsc2U7XG4gICAgICBsZXQgdG9rZW47XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnM/LmlubGluZT8uc29tZSgoZXh0VG9rZW5pemVyKSA9PiB7XG4gICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lc2NhcGUoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGFnKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxpbmsoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucmVmbGluayhzcmMsIHRoaXMudG9rZW5zLmxpbmtzKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBsYXN0VG9rZW4gPSB0b2tlbnMuYXQoLTEpO1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgbGFzdFRva2VuPy50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZXNwYW4oc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYnIoc3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVsKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmF1dG9saW5rKHNyYykpIHtcbiAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zdGF0ZS5pbkxpbmsgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudXJsKHNyYykpKSB7XG4gICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgY3V0U3JjID0gc3JjO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zPy5zdGFydElubGluZSkge1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICBjb25zdCB0ZW1wU3JjID0gc3JjLnNsaWNlKDEpO1xuICAgICAgICBsZXQgdGVtcFN0YXJ0O1xuICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZS5mb3JFYWNoKChnZXRTdGFydEluZGV4KSA9PiB7XG4gICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgdGVtcFNyYyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wU3RhcnQgPT09IFwibnVtYmVyXCIgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydEluZGV4LCB0ZW1wU3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgY3V0U3JjID0gc3JjLnN1YnN0cmluZygwLCBzdGFydEluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmlubGluZVRleHQoY3V0U3JjKSkge1xuICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICBpZiAodG9rZW4ucmF3LnNsaWNlKC0xKSAhPT0gXCJfXCIpIHtcbiAgICAgICAgICBwcmV2Q2hhciA9IHRva2VuLnJhdy5zbGljZSgtMSk7XG4gICAgICAgIH1cbiAgICAgICAga2VlcFByZXZDaGFyID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbGFzdFRva2VuID0gdG9rZW5zLmF0KC0xKTtcbiAgICAgICAgaWYgKGxhc3RUb2tlbj8udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gXCJJbmZpbml0ZSBsb29wIG9uIGJ5dGU6IFwiICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cbn07XG5cbi8vIHNyYy9SZW5kZXJlci50c1xudmFyIF9SZW5kZXJlciA9IGNsYXNzIHtcbiAgb3B0aW9ucztcbiAgcGFyc2VyO1xuICAvLyBzZXQgYnkgdGhlIHBhcnNlclxuICBjb25zdHJ1Y3RvcihvcHRpb25zMikge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMyIHx8IF9kZWZhdWx0cztcbiAgfVxuICBzcGFjZSh0b2tlbikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvZGUoeyB0ZXh0LCBsYW5nLCBlc2NhcGVkIH0pIHtcbiAgICBjb25zdCBsYW5nU3RyaW5nID0gKGxhbmcgfHwgXCJcIikubWF0Y2gob3RoZXIubm90U3BhY2VTdGFydCk/LlswXTtcbiAgICBjb25zdCBjb2RlID0gdGV4dC5yZXBsYWNlKG90aGVyLmVuZGluZ05ld2xpbmUsIFwiXCIpICsgXCJcXG5cIjtcbiAgICBpZiAoIWxhbmdTdHJpbmcpIHtcbiAgICAgIHJldHVybiBcIjxwcmU+PGNvZGU+XCIgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUyKGNvZGUsIHRydWUpKSArIFwiPC9jb2RlPjwvcHJlPlxcblwiO1xuICAgIH1cbiAgICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS0nICsgZXNjYXBlMihsYW5nU3RyaW5nKSArICdcIj4nICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlMihjb2RlLCB0cnVlKSkgKyBcIjwvY29kZT48L3ByZT5cXG5cIjtcbiAgfVxuICBibG9ja3F1b3RlKHsgdG9rZW5zIH0pIHtcbiAgICBjb25zdCBib2R5ID0gdGhpcy5wYXJzZXIucGFyc2UodG9rZW5zKTtcbiAgICByZXR1cm4gYDxibG9ja3F1b3RlPlxuJHtib2R5fTwvYmxvY2txdW90ZT5cbmA7XG4gIH1cbiAgaHRtbCh7IHRleHQgfSkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIGhlYWRpbmcoeyB0b2tlbnMsIGRlcHRoIH0pIHtcbiAgICByZXR1cm4gYDxoJHtkZXB0aH0+JHt0aGlzLnBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpfTwvaCR7ZGVwdGh9PlxuYDtcbiAgfVxuICBocih0b2tlbikge1xuICAgIHJldHVybiBcIjxocj5cXG5cIjtcbiAgfVxuICBsaXN0KHRva2VuKSB7XG4gICAgY29uc3Qgb3JkZXJlZCA9IHRva2VuLm9yZGVyZWQ7XG4gICAgY29uc3Qgc3RhcnQgPSB0b2tlbi5zdGFydDtcbiAgICBsZXQgYm9keSA9IFwiXCI7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0b2tlbi5pdGVtcy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgaXRlbSA9IHRva2VuLml0ZW1zW2pdO1xuICAgICAgYm9keSArPSB0aGlzLmxpc3RpdGVtKGl0ZW0pO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gb3JkZXJlZCA/IFwib2xcIiA6IFwidWxcIjtcbiAgICBjb25zdCBzdGFydEF0dHIgPSBvcmRlcmVkICYmIHN0YXJ0ICE9PSAxID8gJyBzdGFydD1cIicgKyBzdGFydCArICdcIicgOiBcIlwiO1xuICAgIHJldHVybiBcIjxcIiArIHR5cGUgKyBzdGFydEF0dHIgKyBcIj5cXG5cIiArIGJvZHkgKyBcIjwvXCIgKyB0eXBlICsgXCI+XFxuXCI7XG4gIH1cbiAgbGlzdGl0ZW0oaXRlbSkge1xuICAgIGxldCBpdGVtQm9keSA9IFwiXCI7XG4gICAgaWYgKGl0ZW0udGFzaykge1xuICAgICAgY29uc3QgY2hlY2tib3ggPSB0aGlzLmNoZWNrYm94KHsgY2hlY2tlZDogISFpdGVtLmNoZWNrZWQgfSk7XG4gICAgICBpZiAoaXRlbS5sb29zZSkge1xuICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0/LnR5cGUgPT09IFwicGFyYWdyYXBoXCIpIHtcbiAgICAgICAgICBpdGVtLnRva2Vuc1swXS50ZXh0ID0gY2hlY2tib3ggKyBcIiBcIiArIGl0ZW0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgaWYgKGl0ZW0udG9rZW5zWzBdLnRva2VucyAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnMubGVuZ3RoID4gMCAmJiBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0ID0gY2hlY2tib3ggKyBcIiBcIiArIGVzY2FwZTIoaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQpO1xuICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLnRva2Vucy51bnNoaWZ0KHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgcmF3OiBjaGVja2JveCArIFwiIFwiLFxuICAgICAgICAgICAgdGV4dDogY2hlY2tib3ggKyBcIiBcIixcbiAgICAgICAgICAgIGVzY2FwZWQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbUJvZHkgKz0gY2hlY2tib3ggKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaXRlbUJvZHkgKz0gdGhpcy5wYXJzZXIucGFyc2UoaXRlbS50b2tlbnMsICEhaXRlbS5sb29zZSk7XG4gICAgcmV0dXJuIGA8bGk+JHtpdGVtQm9keX08L2xpPlxuYDtcbiAgfVxuICBjaGVja2JveCh7IGNoZWNrZWQgfSkge1xuICAgIHJldHVybiBcIjxpbnB1dCBcIiArIChjaGVja2VkID8gJ2NoZWNrZWQ9XCJcIiAnIDogXCJcIikgKyAnZGlzYWJsZWQ9XCJcIiB0eXBlPVwiY2hlY2tib3hcIj4nO1xuICB9XG4gIHBhcmFncmFwaCh7IHRva2VucyB9KSB7XG4gICAgcmV0dXJuIGA8cD4ke3RoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyl9PC9wPlxuYDtcbiAgfVxuICB0YWJsZSh0b2tlbikge1xuICAgIGxldCBoZWFkZXIgPSBcIlwiO1xuICAgIGxldCBjZWxsID0gXCJcIjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRva2VuLmhlYWRlci5sZW5ndGg7IGorKykge1xuICAgICAgY2VsbCArPSB0aGlzLnRhYmxlY2VsbCh0b2tlbi5oZWFkZXJbal0pO1xuICAgIH1cbiAgICBoZWFkZXIgKz0gdGhpcy50YWJsZXJvdyh7IHRleHQ6IGNlbGwgfSk7XG4gICAgbGV0IGJvZHkgPSBcIlwiO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdG9rZW4ucm93cy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3Qgcm93ID0gdG9rZW4ucm93c1tqXTtcbiAgICAgIGNlbGwgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3cubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgY2VsbCArPSB0aGlzLnRhYmxlY2VsbChyb3dba10pO1xuICAgICAgfVxuICAgICAgYm9keSArPSB0aGlzLnRhYmxlcm93KHsgdGV4dDogY2VsbCB9KTtcbiAgICB9XG4gICAgaWYgKGJvZHkpIGJvZHkgPSBgPHRib2R5PiR7Ym9keX08L3Rib2R5PmA7XG4gICAgcmV0dXJuIFwiPHRhYmxlPlxcbjx0aGVhZD5cXG5cIiArIGhlYWRlciArIFwiPC90aGVhZD5cXG5cIiArIGJvZHkgKyBcIjwvdGFibGU+XFxuXCI7XG4gIH1cbiAgdGFibGVyb3coeyB0ZXh0IH0pIHtcbiAgICByZXR1cm4gYDx0cj5cbiR7dGV4dH08L3RyPlxuYDtcbiAgfVxuICB0YWJsZWNlbGwodG9rZW4pIHtcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5wYXJzZXIucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKTtcbiAgICBjb25zdCB0eXBlID0gdG9rZW4uaGVhZGVyID8gXCJ0aFwiIDogXCJ0ZFwiO1xuICAgIGNvbnN0IHRhZzIgPSB0b2tlbi5hbGlnbiA/IGA8JHt0eXBlfSBhbGlnbj1cIiR7dG9rZW4uYWxpZ259XCI+YCA6IGA8JHt0eXBlfT5gO1xuICAgIHJldHVybiB0YWcyICsgY29udGVudCArIGA8LyR7dHlwZX0+XG5gO1xuICB9XG4gIC8qKlxuICAgKiBzcGFuIGxldmVsIHJlbmRlcmVyXG4gICAqL1xuICBzdHJvbmcoeyB0b2tlbnMgfSkge1xuICAgIHJldHVybiBgPHN0cm9uZz4ke3RoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyl9PC9zdHJvbmc+YDtcbiAgfVxuICBlbSh7IHRva2VucyB9KSB7XG4gICAgcmV0dXJuIGA8ZW0+JHt0aGlzLnBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpfTwvZW0+YDtcbiAgfVxuICBjb2Rlc3Bhbih7IHRleHQgfSkge1xuICAgIHJldHVybiBgPGNvZGU+JHtlc2NhcGUyKHRleHQsIHRydWUpfTwvY29kZT5gO1xuICB9XG4gIGJyKHRva2VuKSB7XG4gICAgcmV0dXJuIFwiPGJyPlwiO1xuICB9XG4gIGRlbCh7IHRva2VucyB9KSB7XG4gICAgcmV0dXJuIGA8ZGVsPiR7dGhpcy5wYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKX08L2RlbD5gO1xuICB9XG4gIGxpbmsoeyBocmVmLCB0aXRsZSwgdG9rZW5zIH0pIHtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5wYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKTtcbiAgICBjb25zdCBjbGVhbkhyZWYgPSBjbGVhblVybChocmVmKTtcbiAgICBpZiAoY2xlYW5IcmVmID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgaHJlZiA9IGNsZWFuSHJlZjtcbiAgICBsZXQgb3V0ID0gJzxhIGhyZWY9XCInICsgaHJlZiArICdcIic7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyBlc2NhcGUyKHRpdGxlKSArICdcIic7XG4gICAgfVxuICAgIG91dCArPSBcIj5cIiArIHRleHQgKyBcIjwvYT5cIjtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGltYWdlKHsgaHJlZiwgdGl0bGUsIHRleHQsIHRva2VucyB9KSB7XG4gICAgaWYgKHRva2Vucykge1xuICAgICAgdGV4dCA9IHRoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2VucywgdGhpcy5wYXJzZXIudGV4dFJlbmRlcmVyKTtcbiAgICB9XG4gICAgY29uc3QgY2xlYW5IcmVmID0gY2xlYW5VcmwoaHJlZik7XG4gICAgaWYgKGNsZWFuSHJlZiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVzY2FwZTIodGV4dCk7XG4gICAgfVxuICAgIGhyZWYgPSBjbGVhbkhyZWY7XG4gICAgbGV0IG91dCA9IGA8aW1nIHNyYz1cIiR7aHJlZn1cIiBhbHQ9XCIke3RleHR9XCJgO1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgb3V0ICs9IGAgdGl0bGU9XCIke2VzY2FwZTIodGl0bGUpfVwiYDtcbiAgICB9XG4gICAgb3V0ICs9IFwiPlwiO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgdGV4dCh0b2tlbikge1xuICAgIHJldHVybiBcInRva2Vuc1wiIGluIHRva2VuICYmIHRva2VuLnRva2VucyA/IHRoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykgOiBcImVzY2FwZWRcIiBpbiB0b2tlbiAmJiB0b2tlbi5lc2NhcGVkID8gdG9rZW4udGV4dCA6IGVzY2FwZTIodG9rZW4udGV4dCk7XG4gIH1cbn07XG5cbi8vIHNyYy9UZXh0UmVuZGVyZXIudHNcbnZhciBfVGV4dFJlbmRlcmVyID0gY2xhc3Mge1xuICAvLyBubyBuZWVkIGZvciBibG9jayBsZXZlbCByZW5kZXJlcnNcbiAgc3Ryb25nKHsgdGV4dCB9KSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgZW0oeyB0ZXh0IH0pIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICBjb2Rlc3Bhbih7IHRleHQgfSkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIGRlbCh7IHRleHQgfSkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIGh0bWwoeyB0ZXh0IH0pIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICB0ZXh0KHsgdGV4dCB9KSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgbGluayh7IHRleHQgfSkge1xuICAgIHJldHVybiBcIlwiICsgdGV4dDtcbiAgfVxuICBpbWFnZSh7IHRleHQgfSkge1xuICAgIHJldHVybiBcIlwiICsgdGV4dDtcbiAgfVxuICBicigpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufTtcblxuLy8gc3JjL1BhcnNlci50c1xudmFyIF9QYXJzZXIgPSBjbGFzcyBfX1BhcnNlciB7XG4gIG9wdGlvbnM7XG4gIHJlbmRlcmVyO1xuICB0ZXh0UmVuZGVyZXI7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMyKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczIgfHwgX2RlZmF1bHRzO1xuICAgIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgX1JlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlcjtcbiAgICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy5yZW5kZXJlci5wYXJzZXIgPSB0aGlzO1xuICAgIHRoaXMudGV4dFJlbmRlcmVyID0gbmV3IF9UZXh0UmVuZGVyZXIoKTtcbiAgfVxuICAvKipcbiAgICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICAgKi9cbiAgc3RhdGljIHBhcnNlKHRva2Vucywgb3B0aW9uczIpIHtcbiAgICBjb25zdCBwYXJzZXIyID0gbmV3IF9fUGFyc2VyKG9wdGlvbnMyKTtcbiAgICByZXR1cm4gcGFyc2VyMi5wYXJzZSh0b2tlbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgKi9cbiAgc3RhdGljIHBhcnNlSW5saW5lKHRva2Vucywgb3B0aW9uczIpIHtcbiAgICBjb25zdCBwYXJzZXIyID0gbmV3IF9fUGFyc2VyKG9wdGlvbnMyKTtcbiAgICByZXR1cm4gcGFyc2VyMi5wYXJzZUlubGluZSh0b2tlbnMpO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBMb29wXG4gICAqL1xuICBwYXJzZSh0b2tlbnMsIHRvcCA9IHRydWUpIHtcbiAgICBsZXQgb3V0ID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYW55VG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnM/LnJlbmRlcmVycz8uW2FueVRva2VuLnR5cGVdKSB7XG4gICAgICAgIGNvbnN0IGdlbmVyaWNUb2tlbiA9IGFueVRva2VuO1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZ2VuZXJpY1Rva2VuLnR5cGVdLmNhbGwoeyBwYXJzZXI6IHRoaXMgfSwgZ2VuZXJpY1Rva2VuKTtcbiAgICAgICAgaWYgKHJldCAhPT0gZmFsc2UgfHwgIVtcInNwYWNlXCIsIFwiaHJcIiwgXCJoZWFkaW5nXCIsIFwiY29kZVwiLCBcInRhYmxlXCIsIFwiYmxvY2txdW90ZVwiLCBcImxpc3RcIiwgXCJodG1sXCIsIFwicGFyYWdyYXBoXCIsIFwidGV4dFwiXS5pbmNsdWRlcyhnZW5lcmljVG9rZW4udHlwZSkpIHtcbiAgICAgICAgICBvdXQgKz0gcmV0IHx8IFwiXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuID0gYW55VG9rZW47XG4gICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcInNwYWNlXCI6IHtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5zcGFjZSh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImhyXCI6IHtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5ocih0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImhlYWRpbmdcIjoge1xuICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhlYWRpbmcodG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJjb2RlXCI6IHtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2RlKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidGFibGVcIjoge1xuICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYmxvY2txdW90ZVwiOiB7XG4gICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZSh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImxpc3RcIjoge1xuICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpc3QodG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJodG1sXCI6IHtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5odG1sKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicGFyYWdyYXBoXCI6IHtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICBsZXQgdGV4dFRva2VuID0gdG9rZW47XG4gICAgICAgICAgbGV0IGJvZHkgPSB0aGlzLnJlbmRlcmVyLnRleHQodGV4dFRva2VuKTtcbiAgICAgICAgICB3aGlsZSAoaSArIDEgPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIHRleHRUb2tlbiA9IHRva2Vuc1srK2ldO1xuICAgICAgICAgICAgYm9keSArPSBcIlxcblwiICsgdGhpcy5yZW5kZXJlci50ZXh0KHRleHRUb2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgICAgICAgIHJhdzogYm9keSxcbiAgICAgICAgICAgICAgdGV4dDogYm9keSxcbiAgICAgICAgICAgICAgdG9rZW5zOiBbeyB0eXBlOiBcInRleHRcIiwgcmF3OiBib2R5LCB0ZXh0OiBib2R5LCBlc2NhcGVkOiB0cnVlIH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9IGJvZHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIElubGluZSBUb2tlbnNcbiAgICovXG4gIHBhcnNlSW5saW5lKHRva2VucywgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKSB7XG4gICAgbGV0IG91dCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGFueVRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zPy5yZW5kZXJlcnM/LlthbnlUb2tlbi50eXBlXSkge1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbYW55VG9rZW4udHlwZV0uY2FsbCh7IHBhcnNlcjogdGhpcyB9LCBhbnlUb2tlbik7XG4gICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbXCJlc2NhcGVcIiwgXCJodG1sXCIsIFwibGlua1wiLCBcImltYWdlXCIsIFwic3Ryb25nXCIsIFwiZW1cIiwgXCJjb2Rlc3BhblwiLCBcImJyXCIsIFwiZGVsXCIsIFwidGV4dFwiXS5pbmNsdWRlcyhhbnlUb2tlbi50eXBlKSkge1xuICAgICAgICAgIG91dCArPSByZXQgfHwgXCJcIjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW4gPSBhbnlUb2tlbjtcbiAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlIFwiZXNjYXBlXCI6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImh0bWxcIjoge1xuICAgICAgICAgIG91dCArPSByZW5kZXJlci5odG1sKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwibGlua1wiOiB7XG4gICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmxpbmsodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJpbWFnZVwiOiB7XG4gICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmltYWdlKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwic3Ryb25nXCI6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuc3Ryb25nKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZW1cIjoge1xuICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0b2tlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImNvZGVzcGFuXCI6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuY29kZXNwYW4odG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJiclwiOiB7XG4gICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmJyKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZGVsXCI6IHtcbiAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuZGVsKHRva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQodG9rZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn07XG5cbi8vIHNyYy9Ib29rcy50c1xudmFyIF9Ib29rcyA9IGNsYXNzIHtcbiAgb3B0aW9ucztcbiAgYmxvY2s7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMyKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczIgfHwgX2RlZmF1bHRzO1xuICB9XG4gIHN0YXRpYyBwYXNzVGhyb3VnaEhvb2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgIFwicHJlcHJvY2Vzc1wiLFxuICAgIFwicG9zdHByb2Nlc3NcIixcbiAgICBcInByb2Nlc3NBbGxUb2tlbnNcIlxuICBdKTtcbiAgLyoqXG4gICAqIFByb2Nlc3MgbWFya2Rvd24gYmVmb3JlIG1hcmtlZFxuICAgKi9cbiAgcHJlcHJvY2VzcyhtYXJrZG93bikge1xuICAgIHJldHVybiBtYXJrZG93bjtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBIVE1MIGFmdGVyIG1hcmtlZCBpcyBmaW5pc2hlZFxuICAgKi9cbiAgcG9zdHByb2Nlc3MoaHRtbDIpIHtcbiAgICByZXR1cm4gaHRtbDI7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgYWxsIHRva2VucyBiZWZvcmUgd2FsayB0b2tlbnNcbiAgICovXG4gIHByb2Nlc3NBbGxUb2tlbnModG9rZW5zKSB7XG4gICAgcmV0dXJuIHRva2VucztcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZSBmdW5jdGlvbiB0byB0b2tlbml6ZSBtYXJrZG93blxuICAgKi9cbiAgcHJvdmlkZUxleGVyKCkge1xuICAgIHJldHVybiB0aGlzLmJsb2NrID8gX0xleGVyLmxleCA6IF9MZXhlci5sZXhJbmxpbmU7XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGUgZnVuY3Rpb24gdG8gcGFyc2UgdG9rZW5zXG4gICAqL1xuICBwcm92aWRlUGFyc2VyKCkge1xuICAgIHJldHVybiB0aGlzLmJsb2NrID8gX1BhcnNlci5wYXJzZSA6IF9QYXJzZXIucGFyc2VJbmxpbmU7XG4gIH1cbn07XG5cbi8vIHNyYy9JbnN0YW5jZS50c1xudmFyIE1hcmtlZCA9IGNsYXNzIHtcbiAgZGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHMoKTtcbiAgb3B0aW9ucyA9IHRoaXMuc2V0T3B0aW9ucztcbiAgcGFyc2UgPSB0aGlzLnBhcnNlTWFya2Rvd24odHJ1ZSk7XG4gIHBhcnNlSW5saW5lID0gdGhpcy5wYXJzZU1hcmtkb3duKGZhbHNlKTtcbiAgUGFyc2VyID0gX1BhcnNlcjtcbiAgUmVuZGVyZXIgPSBfUmVuZGVyZXI7XG4gIFRleHRSZW5kZXJlciA9IF9UZXh0UmVuZGVyZXI7XG4gIExleGVyID0gX0xleGVyO1xuICBUb2tlbml6ZXIgPSBfVG9rZW5pemVyO1xuICBIb29rcyA9IF9Ib29rcztcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHRoaXMudXNlKC4uLmFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBSdW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IHRva2VuXG4gICAqL1xuICB3YWxrVG9rZW5zKHRva2VucywgY2FsbGJhY2spIHtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoY2FsbGJhY2suY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJ0YWJsZVwiOiB7XG4gICAgICAgICAgY29uc3QgdGFibGVUb2tlbiA9IHRva2VuO1xuICAgICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiB0YWJsZVRva2VuLmhlYWRlcikge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMoY2VsbC50b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlVG9rZW4ucm93cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHJvdykge1xuICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhjZWxsLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImxpc3RcIjoge1xuICAgICAgICAgIGNvbnN0IGxpc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGxpc3RUb2tlbi5pdGVtcywgY2FsbGJhY2spKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgZ2VuZXJpY1Rva2VuID0gdG9rZW47XG4gICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucz8uY2hpbGRUb2tlbnM/LltnZW5lcmljVG9rZW4udHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1tnZW5lcmljVG9rZW4udHlwZV0uZm9yRWFjaCgoY2hpbGRUb2tlbnMpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9rZW5zMiA9IGdlbmVyaWNUb2tlbltjaGlsZFRva2Vuc10uZmxhdChJbmZpbml0eSk7XG4gICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKHRva2VuczIsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGdlbmVyaWNUb2tlbi50b2tlbnMpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGdlbmVyaWNUb2tlbi50b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgdXNlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5kZWZhdWx0cy5leHRlbnNpb25zIHx8IHsgcmVuZGVyZXJzOiB7fSwgY2hpbGRUb2tlbnM6IHt9IH07XG4gICAgYXJncy5mb3JFYWNoKChwYWNrKSA9PiB7XG4gICAgICBjb25zdCBvcHRzID0geyAuLi5wYWNrIH07XG4gICAgICBvcHRzLmFzeW5jID0gdGhpcy5kZWZhdWx0cy5hc3luYyB8fCBvcHRzLmFzeW5jIHx8IGZhbHNlO1xuICAgICAgaWYgKHBhY2suZXh0ZW5zaW9ucykge1xuICAgICAgICBwYWNrLmV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0KSA9PiB7XG4gICAgICAgICAgaWYgKCFleHQubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXh0ZW5zaW9uIG5hbWUgcmVxdWlyZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcInJlbmRlcmVyXCIgaW4gZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2UmVuZGVyZXIgPSBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV07XG4gICAgICAgICAgICBpZiAocHJldlJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgIGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXSA9IGZ1bmN0aW9uKC4uLmFyZ3MyKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJldCA9IGV4dC5yZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzMik7XG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBleHQucmVuZGVyZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcInRva2VuaXplclwiIGluIGV4dCkge1xuICAgICAgICAgICAgaWYgKCFleHQubGV2ZWwgfHwgZXh0LmxldmVsICE9PSBcImJsb2NrXCIgJiYgZXh0LmxldmVsICE9PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4dGVuc2lvbiBsZXZlbCBtdXN0IGJlICdibG9jaycgb3IgJ2lubGluZSdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHRMZXZlbCA9IGV4dGVuc2lvbnNbZXh0LmxldmVsXTtcbiAgICAgICAgICAgIGlmIChleHRMZXZlbCkge1xuICAgICAgICAgICAgICBleHRMZXZlbC51bnNoaWZ0KGV4dC50b2tlbml6ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHQubGV2ZWxdID0gW2V4dC50b2tlbml6ZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dC5zdGFydCkge1xuICAgICAgICAgICAgICBpZiAoZXh0LmxldmVsID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXh0LmxldmVsID09PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0SW5saW5lID0gW2V4dC5zdGFydF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcImNoaWxkVG9rZW5zXCIgaW4gZXh0ICYmIGV4dC5jaGlsZFRva2Vucykge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1tleHQubmFtZV0gPSBleHQuY2hpbGRUb2tlbnM7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb3B0cy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICAgIH1cbiAgICAgIGlmIChwYWNrLnJlbmRlcmVyKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5kZWZhdWx0cy5yZW5kZXJlciB8fCBuZXcgX1JlbmRlcmVyKHRoaXMuZGVmYXVsdHMpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay5yZW5kZXJlcikge1xuICAgICAgICAgIGlmICghKHByb3AgaW4gcmVuZGVyZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlbmRlcmVyICcke3Byb3B9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoW1wib3B0aW9uc1wiLCBcInBhcnNlclwiXS5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlbmRlcmVyUHJvcCA9IHByb3A7XG4gICAgICAgICAgY29uc3QgcmVuZGVyZXJGdW5jID0gcGFjay5yZW5kZXJlcltyZW5kZXJlclByb3BdO1xuICAgICAgICAgIGNvbnN0IHByZXZSZW5kZXJlciA9IHJlbmRlcmVyW3JlbmRlcmVyUHJvcF07XG4gICAgICAgICAgcmVuZGVyZXJbcmVuZGVyZXJQcm9wXSA9ICguLi5hcmdzMikgPT4ge1xuICAgICAgICAgICAgbGV0IHJldCA9IHJlbmRlcmVyRnVuYy5hcHBseShyZW5kZXJlciwgYXJnczIpO1xuICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHJlbmRlcmVyLCBhcmdzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0IHx8IFwiXCI7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICB9XG4gICAgICBpZiAocGFjay50b2tlbml6ZXIpIHtcbiAgICAgICAgY29uc3QgdG9rZW5pemVyID0gdGhpcy5kZWZhdWx0cy50b2tlbml6ZXIgfHwgbmV3IF9Ub2tlbml6ZXIodGhpcy5kZWZhdWx0cyk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLnRva2VuaXplcikge1xuICAgICAgICAgIGlmICghKHByb3AgaW4gdG9rZW5pemVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0b2tlbml6ZXIgJyR7cHJvcH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChbXCJvcHRpb25zXCIsIFwicnVsZXNcIiwgXCJsZXhlclwiXS5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRva2VuaXplclByb3AgPSBwcm9wO1xuICAgICAgICAgIGNvbnN0IHRva2VuaXplckZ1bmMgPSBwYWNrLnRva2VuaXplclt0b2tlbml6ZXJQcm9wXTtcbiAgICAgICAgICBjb25zdCBwcmV2VG9rZW5pemVyID0gdG9rZW5pemVyW3Rva2VuaXplclByb3BdO1xuICAgICAgICAgIHRva2VuaXplclt0b2tlbml6ZXJQcm9wXSA9ICguLi5hcmdzMikgPT4ge1xuICAgICAgICAgICAgbGV0IHJldCA9IHRva2VuaXplckZ1bmMuYXBwbHkodG9rZW5pemVyLCBhcmdzMik7XG4gICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXQgPSBwcmV2VG9rZW5pemVyLmFwcGx5KHRva2VuaXplciwgYXJnczIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG9wdHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICAgICAgfVxuICAgICAgaWYgKHBhY2suaG9va3MpIHtcbiAgICAgICAgY29uc3QgaG9va3MgPSB0aGlzLmRlZmF1bHRzLmhvb2tzIHx8IG5ldyBfSG9va3MoKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHBhY2suaG9va3MpIHtcbiAgICAgICAgICBpZiAoIShwcm9wIGluIGhvb2tzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBob29rICcke3Byb3B9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoW1wib3B0aW9uc1wiLCBcImJsb2NrXCJdLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaG9va3NQcm9wID0gcHJvcDtcbiAgICAgICAgICBjb25zdCBob29rc0Z1bmMgPSBwYWNrLmhvb2tzW2hvb2tzUHJvcF07XG4gICAgICAgICAgY29uc3QgcHJldkhvb2sgPSBob29rc1tob29rc1Byb3BdO1xuICAgICAgICAgIGlmIChfSG9va3MucGFzc1Rocm91Z2hIb29rcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgIGhvb2tzW2hvb2tzUHJvcF0gPSAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRzLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShob29rc0Z1bmMuY2FsbChob29rcywgYXJnKSkudGhlbigocmV0MikgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZIb29rLmNhbGwoaG9va3MsIHJldDIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHJldCA9IGhvb2tzRnVuYy5jYWxsKGhvb2tzLCBhcmcpO1xuICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvb2tzW2hvb2tzUHJvcF0gPSAoLi4uYXJnczIpID0+IHtcbiAgICAgICAgICAgICAgbGV0IHJldCA9IGhvb2tzRnVuYy5hcHBseShob29rcywgYXJnczIpO1xuICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldCA9IHByZXZIb29rLmFwcGx5KGhvb2tzLCBhcmdzMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdHMuaG9va3MgPSBob29rcztcbiAgICAgIH1cbiAgICAgIGlmIChwYWNrLndhbGtUb2tlbnMpIHtcbiAgICAgICAgY29uc3Qgd2Fsa1Rva2VuczIgPSB0aGlzLmRlZmF1bHRzLndhbGtUb2tlbnM7XG4gICAgICAgIGNvbnN0IHBhY2tXYWxrdG9rZW5zID0gcGFjay53YWxrVG9rZW5zO1xuICAgICAgICBvcHRzLndhbGtUb2tlbnMgPSBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICB2YWx1ZXMucHVzaChwYWNrV2Fsa3Rva2Vucy5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgICAgaWYgKHdhbGtUb2tlbnMyKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHdhbGtUb2tlbnMyLmNhbGwodGhpcywgdG9rZW4pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVmYXVsdHMgPSB7IC4uLnRoaXMuZGVmYXVsdHMsIC4uLm9wdHMgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRPcHRpb25zKG9wdCkge1xuICAgIHRoaXMuZGVmYXVsdHMgPSB7IC4uLnRoaXMuZGVmYXVsdHMsIC4uLm9wdCB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxleGVyKHNyYywgb3B0aW9uczIpIHtcbiAgICByZXR1cm4gX0xleGVyLmxleChzcmMsIG9wdGlvbnMyID8/IHRoaXMuZGVmYXVsdHMpO1xuICB9XG4gIHBhcnNlcih0b2tlbnMsIG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIF9QYXJzZXIucGFyc2UodG9rZW5zLCBvcHRpb25zMiA/PyB0aGlzLmRlZmF1bHRzKTtcbiAgfVxuICBwYXJzZU1hcmtkb3duKGJsb2NrVHlwZSkge1xuICAgIGNvbnN0IHBhcnNlMiA9IChzcmMsIG9wdGlvbnMyKSA9PiB7XG4gICAgICBjb25zdCBvcmlnT3B0ID0geyAuLi5vcHRpb25zMiB9O1xuICAgICAgY29uc3Qgb3B0ID0geyAuLi50aGlzLmRlZmF1bHRzLCAuLi5vcmlnT3B0IH07XG4gICAgICBjb25zdCB0aHJvd0Vycm9yID0gdGhpcy5vbkVycm9yKCEhb3B0LnNpbGVudCwgISFvcHQuYXN5bmMpO1xuICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuYXN5bmMgPT09IHRydWUgJiYgb3JpZ09wdC5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IEVycm9yKFwibWFya2VkKCk6IFRoZSBhc3luYyBvcHRpb24gd2FzIHNldCB0byB0cnVlIGJ5IGFuIGV4dGVuc2lvbi4gUmVtb3ZlIGFzeW5jOiBmYWxzZSBmcm9tIHRoZSBwYXJzZSBvcHRpb25zIG9iamVjdCB0byByZXR1cm4gYSBQcm9taXNlLlwiKSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNyYyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IEVycm9yKFwibWFya2VkKCk6IGlucHV0IHBhcmFtZXRlciBpcyB1bmRlZmluZWQgb3IgbnVsbFwiKSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNyYyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoXCJtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgXCIgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKSArIFwiLCBzdHJpbmcgZXhwZWN0ZWRcIikpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICBvcHQuaG9va3Mub3B0aW9ucyA9IG9wdDtcbiAgICAgICAgb3B0Lmhvb2tzLmJsb2NrID0gYmxvY2tUeXBlO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV4ZXIyID0gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByb3ZpZGVMZXhlcigpIDogYmxvY2tUeXBlID8gX0xleGVyLmxleCA6IF9MZXhlci5sZXhJbmxpbmU7XG4gICAgICBjb25zdCBwYXJzZXIyID0gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByb3ZpZGVQYXJzZXIoKSA6IGJsb2NrVHlwZSA/IF9QYXJzZXIucGFyc2UgOiBfUGFyc2VyLnBhcnNlSW5saW5lO1xuICAgICAgaWYgKG9wdC5hc3luYykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9wdC5ob29rcyA/IG9wdC5ob29rcy5wcmVwcm9jZXNzKHNyYykgOiBzcmMpLnRoZW4oKHNyYzIpID0+IGxleGVyMihzcmMyLCBvcHQpKS50aGVuKCh0b2tlbnMpID0+IG9wdC5ob29rcyA/IG9wdC5ob29rcy5wcm9jZXNzQWxsVG9rZW5zKHRva2VucykgOiB0b2tlbnMpLnRoZW4oKHRva2VucykgPT4gb3B0LndhbGtUb2tlbnMgPyBQcm9taXNlLmFsbCh0aGlzLndhbGtUb2tlbnModG9rZW5zLCBvcHQud2Fsa1Rva2VucykpLnRoZW4oKCkgPT4gdG9rZW5zKSA6IHRva2VucykudGhlbigodG9rZW5zKSA9PiBwYXJzZXIyKHRva2Vucywgb3B0KSkudGhlbigoaHRtbDIpID0+IG9wdC5ob29rcyA/IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sMikgOiBodG1sMikuY2F0Y2godGhyb3dFcnJvcik7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgc3JjID0gb3B0Lmhvb2tzLnByZXByb2Nlc3Moc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9rZW5zID0gbGV4ZXIyKHNyYywgb3B0KTtcbiAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgIHRva2VucyA9IG9wdC5ob29rcy5wcm9jZXNzQWxsVG9rZW5zKHRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgdGhpcy53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBodG1sMiA9IHBhcnNlcjIodG9rZW5zLCBvcHQpO1xuICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgaHRtbDIgPSBvcHQuaG9va3MucG9zdHByb2Nlc3MoaHRtbDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodG1sMjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2UyO1xuICB9XG4gIG9uRXJyb3Ioc2lsZW50LCBhc3luYykge1xuICAgIHJldHVybiAoZSkgPT4ge1xuICAgICAgZS5tZXNzYWdlICs9IFwiXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWQuXCI7XG4gICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IFwiPHA+QW4gZXJyb3Igb2NjdXJyZWQ6PC9wPjxwcmU+XCIgKyBlc2NhcGUyKGUubWVzc2FnZSArIFwiXCIsIHRydWUpICsgXCI8L3ByZT5cIjtcbiAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgICB9XG4gICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvbWFya2VkLnRzXG52YXIgbWFya2VkSW5zdGFuY2UgPSBuZXcgTWFya2VkKCk7XG5mdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQpIHtcbiAgcmV0dXJuIG1hcmtlZEluc3RhbmNlLnBhcnNlKHNyYywgb3B0KTtcbn1cbm1hcmtlZC5vcHRpb25zID0gbWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zMikge1xuICBtYXJrZWRJbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMyKTtcbiAgbWFya2VkLmRlZmF1bHRzID0gbWFya2VkSW5zdGFuY2UuZGVmYXVsdHM7XG4gIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gIHJldHVybiBtYXJrZWQ7XG59O1xubWFya2VkLmdldERlZmF1bHRzID0gX2dldERlZmF1bHRzO1xubWFya2VkLmRlZmF1bHRzID0gX2RlZmF1bHRzO1xubWFya2VkLnVzZSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgbWFya2VkSW5zdGFuY2UudXNlKC4uLmFyZ3MpO1xuICBtYXJrZWQuZGVmYXVsdHMgPSBtYXJrZWRJbnN0YW5jZS5kZWZhdWx0cztcbiAgY2hhbmdlRGVmYXVsdHMobWFya2VkLmRlZmF1bHRzKTtcbiAgcmV0dXJuIG1hcmtlZDtcbn07XG5tYXJrZWQud2Fsa1Rva2VucyA9IGZ1bmN0aW9uKHRva2VucywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIG1hcmtlZEluc3RhbmNlLndhbGtUb2tlbnModG9rZW5zLCBjYWxsYmFjayk7XG59O1xubWFya2VkLnBhcnNlSW5saW5lID0gbWFya2VkSW5zdGFuY2UucGFyc2VJbmxpbmU7XG5tYXJrZWQuUGFyc2VyID0gX1BhcnNlcjtcbm1hcmtlZC5wYXJzZXIgPSBfUGFyc2VyLnBhcnNlO1xubWFya2VkLlJlbmRlcmVyID0gX1JlbmRlcmVyO1xubWFya2VkLlRleHRSZW5kZXJlciA9IF9UZXh0UmVuZGVyZXI7XG5tYXJrZWQuTGV4ZXIgPSBfTGV4ZXI7XG5tYXJrZWQubGV4ZXIgPSBfTGV4ZXIubGV4O1xubWFya2VkLlRva2VuaXplciA9IF9Ub2tlbml6ZXI7XG5tYXJrZWQuSG9va3MgPSBfSG9va3M7XG5tYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG52YXIgb3B0aW9ucyA9IG1hcmtlZC5vcHRpb25zO1xudmFyIHNldE9wdGlvbnMgPSBtYXJrZWQuc2V0T3B0aW9ucztcbnZhciB1c2UgPSBtYXJrZWQudXNlO1xudmFyIHdhbGtUb2tlbnMgPSBtYXJrZWQud2Fsa1Rva2VucztcbnZhciBwYXJzZUlubGluZSA9IG1hcmtlZC5wYXJzZUlubGluZTtcbnZhciBwYXJzZSA9IG1hcmtlZDtcbnZhciBwYXJzZXIgPSBfUGFyc2VyLnBhcnNlO1xudmFyIGxleGVyID0gX0xleGVyLmxleDtcbmV4cG9ydCB7XG4gIF9Ib29rcyBhcyBIb29rcyxcbiAgX0xleGVyIGFzIExleGVyLFxuICBNYXJrZWQsXG4gIF9QYXJzZXIgYXMgUGFyc2VyLFxuICBfUmVuZGVyZXIgYXMgUmVuZGVyZXIsXG4gIF9UZXh0UmVuZGVyZXIgYXMgVGV4dFJlbmRlcmVyLFxuICBfVG9rZW5pemVyIGFzIFRva2VuaXplcixcbiAgX2RlZmF1bHRzIGFzIGRlZmF1bHRzLFxuICBfZ2V0RGVmYXVsdHMgYXMgZ2V0RGVmYXVsdHMsXG4gIGxleGVyLFxuICBtYXJrZWQsXG4gIG9wdGlvbnMsXG4gIHBhcnNlLFxuICBwYXJzZUlubGluZSxcbiAgcGFyc2VyLFxuICBzZXRPcHRpb25zLFxuICB1c2UsXG4gIHdhbGtUb2tlbnNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXJrZWQuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9nZXREZWZhdWx0cyIsImFzeW5jIiwiYnJlYWtzIiwiZXh0ZW5zaW9ucyIsImdmbSIsImhvb2tzIiwicGVkYW50aWMiLCJyZW5kZXJlciIsInNpbGVudCIsInRva2VuaXplciIsIndhbGtUb2tlbnMiLCJfZGVmYXVsdHMiLCJjaGFuZ2VEZWZhdWx0cyIsIm5ld0RlZmF1bHRzIiwibm9vcFRlc3QiLCJleGVjIiwiZWRpdCIsInJlZ2V4Iiwib3B0Iiwic291cmNlIiwib2JqIiwicmVwbGFjZSIsIm5hbWUiLCJ2YWwiLCJ2YWxTb3VyY2UiLCJvdGhlciIsImNhcmV0IiwiZ2V0UmVnZXgiLCJSZWdFeHAiLCJjb2RlUmVtb3ZlSW5kZW50Iiwib3V0cHV0TGlua1JlcGxhY2UiLCJpbmRlbnRDb2RlQ29tcGVuc2F0aW9uIiwiYmVnaW5uaW5nU3BhY2UiLCJlbmRpbmdIYXNoIiwic3RhcnRpbmdTcGFjZUNoYXIiLCJlbmRpbmdTcGFjZUNoYXIiLCJub25TcGFjZUNoYXIiLCJuZXdMaW5lQ2hhckdsb2JhbCIsInRhYkNoYXJHbG9iYWwiLCJtdWx0aXBsZVNwYWNlR2xvYmFsIiwiYmxhbmtMaW5lIiwiZG91YmxlQmxhbmtMaW5lIiwiYmxvY2txdW90ZVN0YXJ0IiwiYmxvY2txdW90ZVNldGV4dFJlcGxhY2UiLCJibG9ja3F1b3RlU2V0ZXh0UmVwbGFjZTIiLCJsaXN0UmVwbGFjZVRhYnMiLCJsaXN0UmVwbGFjZU5lc3RpbmciLCJsaXN0SXNUYXNrIiwibGlzdFJlcGxhY2VUYXNrIiwiYW55TGluZSIsImhyZWZCcmFja2V0cyIsInRhYmxlRGVsaW1pdGVyIiwidGFibGVBbGlnbkNoYXJzIiwidGFibGVSb3dCbGFua0xpbmUiLCJ0YWJsZUFsaWduUmlnaHQiLCJ0YWJsZUFsaWduQ2VudGVyIiwidGFibGVBbGlnbkxlZnQiLCJzdGFydEFUYWciLCJlbmRBVGFnIiwic3RhcnRQcmVTY3JpcHRUYWciLCJlbmRQcmVTY3JpcHRUYWciLCJzdGFydEFuZ2xlQnJhY2tldCIsImVuZEFuZ2xlQnJhY2tldCIsInBlZGFudGljSHJlZlRpdGxlIiwidW5pY29kZUFscGhhTnVtZXJpYyIsImVzY2FwZVRlc3QiLCJlc2NhcGVSZXBsYWNlIiwiZXNjYXBlVGVzdE5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZU5vRW5jb2RlIiwidW5lc2NhcGVUZXN0IiwicGVyY2VudERlY29kZSIsImZpbmRQaXBlIiwic3BsaXRQaXBlIiwic2xhc2hQaXBlIiwiY2FycmlhZ2VSZXR1cm4iLCJzcGFjZUxpbmUiLCJub3RTcGFjZVN0YXJ0IiwiZW5kaW5nTmV3bGluZSIsImxpc3RJdGVtUmVnZXgiLCJidWxsIiwibmV4dEJ1bGxldFJlZ2V4IiwiaW5kZW50IiwiTWF0aCIsIm1pbiIsImhyUmVnZXgiLCJmZW5jZXNCZWdpblJlZ2V4IiwiaGVhZGluZ0JlZ2luUmVnZXgiLCJodG1sQmVnaW5SZWdleCIsIm5ld2xpbmUiLCJibG9ja0NvZGUiLCJmZW5jZXMiLCJociIsImhlYWRpbmciLCJidWxsZXQiLCJsaGVhZGluZ0NvcmUiLCJsaGVhZGluZyIsImxoZWFkaW5nR2ZtIiwiX3BhcmFncmFwaCIsImJsb2NrVGV4dCIsIl9ibG9ja0xhYmVsIiwiZGVmIiwibGlzdCIsIl90YWciLCJfY29tbWVudCIsImh0bWwiLCJwYXJhZ3JhcGgiLCJibG9ja3F1b3RlIiwiYmxvY2tOb3JtYWwiLCJjb2RlIiwidGFibGUiLCJ0ZXh0IiwiZ2ZtVGFibGUiLCJibG9ja0dmbSIsImJsb2NrUGVkYW50aWMiLCJlc2NhcGUiLCJpbmxpbmVDb2RlIiwiYnIiLCJpbmxpbmVUZXh0IiwiX3B1bmN0dWF0aW9uIiwiX3B1bmN0dWF0aW9uT3JTcGFjZSIsIl9ub3RQdW5jdHVhdGlvbk9yU3BhY2UiLCJwdW5jdHVhdGlvbiIsIl9wdW5jdHVhdGlvbkdmbVN0cm9uZ0VtIiwiX3B1bmN0dWF0aW9uT3JTcGFjZUdmbVN0cm9uZ0VtIiwiX25vdFB1bmN0dWF0aW9uT3JTcGFjZUdmbVN0cm9uZ0VtIiwiYmxvY2tTa2lwIiwiZW1TdHJvbmdMRGVsaW1Db3JlIiwiZW1TdHJvbmdMRGVsaW0iLCJlbVN0cm9uZ0xEZWxpbUdmbSIsImVtU3Ryb25nUkRlbGltQXN0Q29yZSIsImVtU3Ryb25nUkRlbGltQXN0IiwiZW1TdHJvbmdSRGVsaW1Bc3RHZm0iLCJlbVN0cm9uZ1JEZWxpbVVuZCIsImFueVB1bmN0dWF0aW9uIiwiYXV0b2xpbmsiLCJfaW5saW5lQ29tbWVudCIsInRhZyIsIl9pbmxpbmVMYWJlbCIsImxpbmsiLCJyZWZsaW5rIiwibm9saW5rIiwicmVmbGlua1NlYXJjaCIsImlubGluZU5vcm1hbCIsIl9iYWNrcGVkYWwiLCJkZWwiLCJ1cmwiLCJpbmxpbmVQZWRhbnRpYyIsImlubGluZUdmbSIsImlubGluZUJyZWFrcyIsImJsb2NrIiwibm9ybWFsIiwiaW5saW5lIiwiZXNjYXBlUmVwbGFjZW1lbnRzIiwiZ2V0RXNjYXBlUmVwbGFjZW1lbnQiLCJjaCIsImVzY2FwZTIiLCJodG1sMiIsImVuY29kZSIsInRlc3QiLCJjbGVhblVybCIsImhyZWYiLCJlbmNvZGVVUkkiLCJzcGxpdENlbGxzIiwidGFibGVSb3ciLCJjb3VudCIsImNlbGxzIiwicm93IiwibWF0Y2giLCJvZmZzZXQiLCJzdHIiLCJlc2NhcGVkIiwiY3VyciIsInNwbGl0IiwiaSIsInRyaW0iLCJzaGlmdCIsImxlbmd0aCIsImF0IiwicG9wIiwic3BsaWNlIiwicHVzaCIsInJ0cmltIiwiYyIsImludmVydCIsImwiLCJzdWZmTGVuIiwiY3VyckNoYXIiLCJjaGFyQXQiLCJzbGljZSIsImZpbmRDbG9zaW5nQnJhY2tldCIsImIiLCJpbmRleE9mIiwibGV2ZWwiLCJvdXRwdXRMaW5rIiwiY2FwIiwibGluazIiLCJyYXciLCJsZXhlcjIiLCJydWxlcyIsInRpdGxlIiwic3RhdGUiLCJpbkxpbmsiLCJ0b2tlbiIsInR5cGUiLCJ0b2tlbnMiLCJpbmxpbmVUb2tlbnMiLCJtYXRjaEluZGVudFRvQ29kZSIsImluZGVudFRvQ29kZSIsIm1hcCIsIm5vZGUiLCJtYXRjaEluZGVudEluTm9kZSIsImluZGVudEluTm9kZSIsImpvaW4iLCJfVG9rZW5pemVyIiwic3BhY2UiLCJzcmMiLCJjb2RlQmxvY2tTdHlsZSIsIm9wdGlvbnMiLCJsYW5nIiwidHJpbW1lZCIsImRlcHRoIiwibGV4ZXIiLCJsaW5lcyIsImluQmxvY2txdW90ZSIsImN1cnJlbnRMaW5lcyIsImN1cnJlbnRSYXciLCJjdXJyZW50VGV4dCIsInRvcCIsImJsb2NrVG9rZW5zIiwibGFzdFRva2VuIiwib2xkVG9rZW4iLCJuZXdUZXh0IiwibmV3VG9rZW4iLCJzdWJzdHJpbmciLCJpc29yZGVyZWQiLCJsaXN0MiIsIm9yZGVyZWQiLCJzdGFydCIsImxvb3NlIiwiaXRlbXMiLCJpdGVtUmVnZXgiLCJlbmRzV2l0aEJsYW5rTGluZSIsImVuZEVhcmx5IiwiaXRlbUNvbnRlbnRzIiwibGluZSIsInQiLCJyZXBlYXQiLCJuZXh0TGluZSIsInRyaW1TdGFydCIsInNlYXJjaCIsInJhd0xpbmUiLCJuZXh0TGluZVdpdGhvdXRUYWJzIiwiaXN0YXNrIiwiaXNjaGVja2VkIiwidGFzayIsImNoZWNrZWQiLCJsYXN0SXRlbSIsInRyaW1FbmQiLCJzcGFjZXJzIiwiZmlsdGVyIiwiaGFzTXVsdGlwbGVMaW5lQnJlYWtzIiwic29tZSIsInByZSIsInRhZzIiLCJ0b0xvd2VyQ2FzZSIsImhlYWRlcnMiLCJhbGlnbnMiLCJyb3dzIiwiaXRlbSIsImhlYWRlciIsImFsaWduIiwiY2VsbCIsImluUmF3QmxvY2siLCJ0cmltbWVkVXJsIiwicnRyaW1TbGFzaCIsImxhc3RQYXJlbkluZGV4IiwibGlua0xlbiIsImxpbmtzIiwibGlua1N0cmluZyIsImVtU3Ryb25nIiwibWFza2VkU3JjIiwicHJldkNoYXIiLCJuZXh0Q2hhciIsImxMZW5ndGgiLCJyRGVsaW0iLCJyTGVuZ3RoIiwiZGVsaW1Ub3RhbCIsIm1pZERlbGltVG90YWwiLCJlbmRSZWciLCJsYXN0SW5kZXgiLCJsYXN0Q2hhckxlbmd0aCIsImluZGV4IiwidGV4dDIiLCJjb2Rlc3BhbiIsImhhc05vblNwYWNlQ2hhcnMiLCJoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcyIsInByZXZDYXBaZXJvIiwiY29uc3RydWN0b3IiLCJvcHRpb25zMiIsIl9MZXhlciIsIl9fTGV4ZXIiLCJsZXgiLCJsZXhJbmxpbmUiLCJpbmxpbmVRdWV1ZSIsIm5leHQiLCJsYXN0UGFyYWdyYXBoQ2xpcHBlZCIsImV4dFRva2VuaXplciIsImNhbGwiLCJjdXRTcmMiLCJzdGFydEJsb2NrIiwic3RhcnRJbmRleCIsIkluZmluaXR5IiwidGVtcFNyYyIsInRlbXBTdGFydCIsImZvckVhY2giLCJnZXRTdGFydEluZGV4IiwiZXJyTXNnIiwiY2hhckNvZGVBdCIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwiT2JqZWN0Iiwia2V5cyIsImluY2x1ZGVzIiwibGFzdEluZGV4T2YiLCJrZWVwUHJldkNoYXIiLCJzdGFydElubGluZSIsImNyZWF0ZSIsIl9SZW5kZXJlciIsImxhbmdTdHJpbmciLCJib2R5IiwicGFyc2VyIiwicGFyc2UiLCJwYXJzZUlubGluZSIsImoiLCJsaXN0aXRlbSIsInN0YXJ0QXR0ciIsIml0ZW1Cb2R5IiwiY2hlY2tib3giLCJ1bnNoaWZ0IiwidGFibGVjZWxsIiwidGFibGVyb3ciLCJrIiwiY29udGVudCIsInN0cm9uZyIsImVtIiwiY2xlYW5IcmVmIiwib3V0IiwiaW1hZ2UiLCJ0ZXh0UmVuZGVyZXIiLCJfVGV4dFJlbmRlcmVyIiwiX1BhcnNlciIsIl9fUGFyc2VyIiwicGFyc2VyMiIsImFueVRva2VuIiwicmVuZGVyZXJzIiwiZ2VuZXJpY1Rva2VuIiwicmV0IiwidGV4dFRva2VuIiwiX0hvb2tzIiwicHJlcHJvY2VzcyIsIm1hcmtkb3duIiwicG9zdHByb2Nlc3MiLCJwcm9jZXNzQWxsVG9rZW5zIiwicHJvdmlkZUxleGVyIiwicHJvdmlkZVBhcnNlciIsInBhc3NUaHJvdWdoSG9va3MiLCJTZXQiLCJNYXJrZWQiLCJjYWxsYmFjayIsInZhbHVlcyIsImNvbmNhdCIsInRhYmxlVG9rZW4iLCJsaXN0VG9rZW4iLCJkZWZhdWx0cyIsImNoaWxkVG9rZW5zIiwidG9rZW5zMiIsImZsYXQiLCJ1c2UiLCJhcmdzIiwicGFjayIsIm9wdHMiLCJleHQiLCJwcmV2UmVuZGVyZXIiLCJhcmdzMiIsImFwcGx5IiwiZXh0TGV2ZWwiLCJwcm9wIiwicmVuZGVyZXJQcm9wIiwicmVuZGVyZXJGdW5jIiwidG9rZW5pemVyUHJvcCIsInRva2VuaXplckZ1bmMiLCJwcmV2VG9rZW5pemVyIiwiaG9va3NQcm9wIiwiaG9va3NGdW5jIiwicHJldkhvb2siLCJoYXMiLCJhcmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJyZXQyIiwid2Fsa1Rva2VuczIiLCJwYWNrV2Fsa3Rva2VucyIsInNldE9wdGlvbnMiLCJwYXJzZU1hcmtkb3duIiwiYmxvY2tUeXBlIiwicGFyc2UyIiwib3JpZ09wdCIsInRocm93RXJyb3IiLCJvbkVycm9yIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJzcmMyIiwiYWxsIiwiY2F0Y2giLCJlIiwibWVzc2FnZSIsIm1zZyIsInJlamVjdCIsIlBhcnNlciIsIlJlbmRlcmVyIiwiVGV4dFJlbmRlcmVyIiwiTGV4ZXIiLCJUb2tlbml6ZXIiLCJIb29rcyIsIm1hcmtlZEluc3RhbmNlIiwibWFya2VkIiwiZ2V0RGVmYXVsdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/marked/lib/marked.esm.js\n"));

/***/ })

});